<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Viking Longship Haven - Nexus World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #00bfea, #0072C6, #bfa059);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        .world-origin {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        .world-origin.visible {
            display: block;
        }

        .origin-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8em;
        }

        .origin-world {
            color: #00bfea;
            font-weight: 500;
        }

        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .portal-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            max-width: 300px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .portal-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #00bfea;
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #0072C6;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Mobile controls */
        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;
            }
            
            .world-description {
                font-size: 1em;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div class="look-area" id="look-area"></div>
    
    <div class="world-ui">
        <h1 class="world-title" id="world-title">VIKING LONGSHIP HAVEN</h1>
        <p class="world-description" id="world-description">A mysterious portal shimmers on a rocky northern shore, leading onto the deck of a legendary Viking longship beneath an aurora-lit sky. The scene features carved wooden dragons, flickering lanterns, icy fjords, pine trees, and mystical runes glowing along the hull. Upon entering the portal, adventurers are greeted with the sound of waves and distant Viking horns.</p>
    </div>
    
    <div class="world-origin" id="world-origin">
        <span class="origin-label">Arrived from:</span>
        <span class="origin-world" id="origin-world-name">Origin</span>
    </div>
    
    <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around, Click on portals to travel</div>
    
    <div class="mobile-controls" id="mobile-controls">
        <div class="controls-container">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
    </div>
    
    <div class="portal-tooltip" id="portal-tooltip">
        <h3 class="tooltip-title"></h3>
        <p class="tooltip-description"></p>
        <p class="tooltip-instruction">Click to enter world</p>
    </div>
    
    <div class="loading" id="loading">Materializing world...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration
        const REPO_OWNER = 'kody-w';
        const REPO_NAME = 'nexus-worlds';
        const BRANCH = 'main';
        
        // World attributes
        const DEFAULT_WORLD_ATTRIBUTES = {
            name: "Viking Longship Haven",
            description: "A mysterious portal shimmers on a rocky northern shore, leading onto the deck of a legendary Viking longship beneath an aurora-lit sky. The scene features carved wooden dragons, flickering lanterns, icy fjords, pine trees, and mystical runes glowing along the hull. Upon entering the portal, adventurers are greeted with the sound of waves and distant Viking horns.",
            ambientColor: 0x1a232f,
            fogColor: 0x466381,
            groundColor: 0x575a5c,
            skyColor: 0x223455,
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            portalColor1: 0x00bfea,
            portalColor2: 0x0072C6,
            particleCount: 1500,
            cameraHeight: 2.2,
            fogNear: 15,
            fogFar: 90
        };
        
        // Parse inherited attributes from URL
        function parseInheritedAttributes() {
            let paramString = window.INJECTED_PARAMS || window.location.search;
            
            if (window.location.protocol === 'blob:') {
                const storedParams = sessionStorage.getItem('worldInheritanceParams');
                if (storedParams) {
                    paramString = storedParams;
                }
            }
            
            if (!paramString || paramString === '?') {
                const transitionData = localStorage.getItem('worldTransition');
                if (transitionData) {
                    try {
                        const data = JSON.parse(transitionData);
                        if (Date.now() - data.timestamp < 5000) {
                            paramString = '?' + data.params;
                        }
                    } catch (e) {
                        console.error('Error parsing transition data:', e);
                    }
                    localStorage.removeItem('worldTransition');
                }
            }
            
            const params = new URLSearchParams(paramString);
            const inherited = {};
            
            inherited.sourceWorld = params.get('from') || null;
            inherited.sourceWorldName = params.get('fromName') || null;
            
            if (params.has('moveSpeed')) inherited.moveSpeed = parseFloat(params.get('moveSpeed'));
            if (params.has('lookSpeed')) inherited.lookSpeed = parseFloat(params.get('lookSpeed'));
            if (params.has('ambientColor')) inherited.ambientColor = parseInt(params.get('ambientColor'), 16);
            if (params.has('fogColor')) inherited.fogColor = parseInt(params.get('fogColor'), 16);
            if (params.has('portalColor1')) inherited.portalColor1 = parseInt(params.get('portalColor1'), 16);
            if (params.has('portalColor2')) inherited.portalColor2 = parseInt(params.get('portalColor2'), 16);
            if (params.has('particleCount')) inherited.particleCount = parseInt(params.get('particleCount'));
            if (params.has('cameraHeight')) inherited.cameraHeight = parseFloat(params.get('cameraHeight'));
            if (params.has('fogNear')) inherited.fogNear = parseFloat(params.get('fogNear'));
            if (params.has('fogFar')) inherited.fogFar = parseFloat(params.get('fogFar'));
            
            console.log('Parsed inherited attributes:', inherited);
            return inherited;
        }
        
        // Merge inherited attributes with defaults
        const inheritedAttributes = parseInheritedAttributes();
        const CURRENT_WORLD = { ...DEFAULT_WORLD_ATTRIBUTES, ...inheritedAttributes };
        
        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
        
        class WorldNavigator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.portals = [];
                this.worlds = [];
                this.raycaster = new THREE.Raycaster();
                this.clock = new THREE.Clock();
                
                this.moveSpeed = CURRENT_WORLD.moveSpeed;
                this.lookSpeed = CURRENT_WORLD.lookSpeed;
                this.keys = { w: false, a: false, s: false, d: false };
                this.rotation = { x: 0, y: 0 };
                
                this.isMobile = isMobile;
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;
                
                this.hoveredPortal = null;
                this.tooltip = document.getElementById('portal-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
                this.isPointerLocked = false;
                
                this.inheritedAttributes = inheritedAttributes;
            }
            
            async init() {
                if (this.inheritedAttributes.sourceWorldName) {
                    const originDiv = document.getElementById('world-origin');
                    const originName = document.getElementById('origin-world-name');
                    originName.textContent = this.inheritedAttributes.sourceWorldName;
                    originDiv.classList.add('visible');
                }
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
                
                document.getElementById('world-title').textContent = CURRENT_WORLD.name.toUpperCase();
                document.getElementById('world-description').textContent = CURRENT_WORLD.description;
                
                this.setupScene();
                this.setupLighting();
                await this.loadWorlds();
                this.createEnvironment();
                this.createPortals();
                this.setupEventListeners();
                
                if (this.isMobile) {
                    document.getElementById('controls-hint').textContent = 'Touch & drag to look around, Use joystick to move, Tap on portals to travel';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                this.animate();
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(CURRENT_WORLD.fogColor, CURRENT_WORLD.fogNear, CURRENT_WORLD.fogFar);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, CURRENT_WORLD.cameraHeight, 10);
                
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(CURRENT_WORLD.ambientColor, 0.5);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 100;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);
                
                
// Additional point lights

                const pointLight0 = new THREE.PointLight(0xffeebb, 1.2, 30);
                pointLight0.position.set(0, 2.6, -8);
                pointLight0.castShadow = true;
                this.scene.add(pointLight0);
            
            }
            
            async loadWorlds() {
                try {
                    const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    this.worlds = data.tree
                        .filter(item => 
                            item.type === 'blob' && 
                            item.path.endsWith('.html') && 
                            !item.path.includes('/') &&
                            !item.path.toLowerCase().includes('index') &&
                            !item.path.toLowerCase().includes('readme')
                        )
                        .map(item => ({
                            path: item.path,
                            name: this.formatWorldName(item.path),
                            url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                            raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`
                        }));
                    
                    // Always include a portal back to the hub
                    this.worlds.unshift({
                        name: "Nexus Hub",
                        description: "Return to the central hub",
                        url: "https://raw.githubusercontent.com/" + REPO_OWNER + "/" + REPO_NAME + "/" + BRANCH + "/index.html"
                    });
                    
                    console.log(`Found ${this.worlds.length} worlds to connect`);
                    
                } catch (error) {
                    console.error("Error loading worlds:", error);
                    this.worlds = this.getDemoWorlds();
                }
            }
            
            formatWorldName(filename) {
                return filename
                    .replace('.html', '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
            
            getDemoWorlds() {
                return [
                    { name: "Nexus Hub", description: "Return to the central hub" },
                    { name: "Crystal Caves", description: "A world of glowing crystals" },
                    { name: "Sky Islands", description: "Floating islands in the clouds" }
                ];
            }
            
            createEnvironment() {
                // Ground with terrain
                const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: CURRENT_WORLD.groundColor,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                // Apply terrain displacement
                const vertices = groundGeometry.attributes.position.array;
                
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 2;
                }
            
                groundGeometry.computeVertexNormals();
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Grid overlay
                const gridHelper = new THREE.GridHelper(200, 100, 0x444444, 0x222222);
                gridHelper.position.y = 0.1;
                this.scene.add(gridHelper);
                
                // Skybox
                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(CURRENT_WORLD.skyColor) },
                        bottomColor: { value: new THREE.Color(CURRENT_WORLD.fogColor) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);
                
                // Particles
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = CURRENT_WORLD.particleCount;
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i + 1] = Math.random() * 50;
                    positions[i + 2] = (Math.random() - 0.5) * 100;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });
                
                this.particles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(this.particles);
                
                
// World structures

                // Structure 1: cube
                const structure0Geometry = new THREE.BoxGeometry(18, 18, 18);
                const structure0Material = new THREE.MeshStandardMaterial({
                    color: 0x7e5d3a,
                    metalness: 0.5,
                    roughness: 0.3
                });
                const structure0 = new THREE.Mesh(structure0Geometry, structure0Material);
                structure0.position.set(0, 0, -8);
                structure0.castShadow = true;
                structure0.receiveShadow = true;
                this.scene.add(structure0);
            
                // Structure 2: ring
                const structure1Geometry = new THREE.TorusGeometry(4.800000000000001, 1.6, 16, 32);
                const structure1Material = new THREE.MeshStandardMaterial({
                    color: 0x00bfea,
                    metalness: 0.5,
                    roughness: 0.3,
                    emissive: 0x00bfea,
                    emissiveIntensity: 0.5
                });
                const structure1 = new THREE.Mesh(structure1Geometry, structure1Material);
                structure1.position.set(0, 2, -8);
                structure1.castShadow = true;
                structure1.receiveShadow = true;
                this.scene.add(structure1);
            
                // Structure 3: pyramid
                const structure2Geometry = new THREE.ConeGeometry(3.5999999999999996, 4.8, 4);
                const structure2Material = new THREE.MeshStandardMaterial({
                    color: 0xa8926a,
                    metalness: 0.5,
                    roughness: 0.3
                });
                const structure2 = new THREE.Mesh(structure2Geometry, structure2Material);
                structure2.position.set(-2, 0, -8);
                structure2.castShadow = true;
                structure2.receiveShadow = true;
                this.scene.add(structure2);
            
                // Structure 4: sphere
                const structure3Geometry = new THREE.SphereGeometry(1.6, 32, 16);
                const structure3Material = new THREE.MeshStandardMaterial({
                    color: 0x2c3f50,
                    metalness: 0.5,
                    roughness: 0.3,
                    emissive: 0x2c3f50,
                    emissiveIntensity: 0.5
                });
                const structure3 = new THREE.Mesh(structure3Geometry, structure3Material);
                structure3.position.set(2, 0.5, -8);
                structure3.castShadow = true;
                structure3.receiveShadow = true;
                this.scene.add(structure3);
            
                
                
            // Water plane
            const waterGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                metalness: 0.1,
                roughness: 0.1
            });
            
            this.water = new THREE.Mesh(waterGeometry, waterMaterial);
            this.water.rotation.x = -Math.PI / 2;
            this.water.position.y = 0.2;
            this.scene.add(this.water);
            
            // Water animation function
            this.animateWater = function(time) {
                const vertices = this.water.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const y = vertices[i + 1];
                    vertices[i + 2] = Math.sin(x * 0.1 + time) * Math.cos(y * 0.1 + time) * 0.5;
                }
                this.water.geometry.attributes.position.needsUpdate = true;
                this.water.geometry.computeVertexNormals();
            };
        
            }
            
            createPortals() {
                const numPortals = Math.min(this.worlds.length, 8);
                const radius = 15;
                
                for (let i = 0; i < numPortals; i++) {
                    const world = this.worlds[i];
                    const angle = (i / numPortals) * Math.PI * 2;
                    
                    const portalGroup = new THREE.Group();
                    
                    const frameGeometry = new THREE.TorusGeometry(3, 0.3, 16, 32);
                    const frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0xbfa059,
                        emissive: 0xbfa059,
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    
                    const portalGeometry = new THREE.CircleGeometry(2.7, 32);
                    const portalMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color1: { value: new THREE.Color(CURRENT_WORLD.portalColor1) },
                            color2: { value: new THREE.Color(CURRENT_WORLD.portalColor2) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color1;
                            uniform vec3 color2;
                            varying vec2 vUv;
                            
                            void main() {
                                vec2 center = vUv - 0.5;
                                float dist = length(center);
                                float wave = sin(dist * 10.0 - time * 2.0) * 0.5 + 0.5;
                                vec3 color = mix(color1, color2, wave);
                                float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                                gl_FragColor = vec4(color, alpha * 0.8);
                            }
                        `,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                    portal.position.z = 0.1;
                    
                    portalGroup.add(frame);
                    portalGroup.add(portal);
                    
                    portalGroup.position.x = Math.cos(angle) * radius;
                    portalGroup.position.z = Math.sin(angle) * radius;
                    portalGroup.position.y = 3;
                    portalGroup.rotation.y = -angle + Math.PI;
                    
                    const light = new THREE.PointLight(0xbfa059, 1, 10);
                    light.position.copy(portalGroup.position);
                    this.scene.add(light);
                    
                    portal.userData = {
                        world: world,
                        material: portalMaterial,
                        light: light,
                        url: world.url || world.raw_url,
                        name: world.name,
                        description: world.description || `Enter the ${world.name} world`
                    };
                    
                    this.portals.push(portal);
                    this.scene.add(portalGroup);
                    
                    const platformGeometry = new THREE.CylinderGeometry(4, 4, 0.5, 32);
                    const platformMaterial = new THREE.MeshStandardMaterial({
                        color: 0x444444,
                        metalness: 0.5,
                        roughness: 0.5
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.copy(portalGroup.position);
                    platform.position.y = 0.25;
                    platform.receiveShadow = true;
                    platform.castShadow = true;
                    this.scene.add(platform);
                }
            }
            
            buildInheritanceParams() {
                const params = new URLSearchParams();
                
                params.set('from', window.location.pathname.split('/').pop() || 'viking_longship_haven.html');
                params.set('fromName', CURRENT_WORLD.name);
                params.set('moveSpeed', this.moveSpeed.toString());
                params.set('lookSpeed', this.lookSpeed.toString());
                params.set('ambientColor', CURRENT_WORLD.ambientColor.toString(16).padStart(6, '0'));
                params.set('fogColor', CURRENT_WORLD.fogColor.toString(16).padStart(6, '0'));
                params.set('portalColor1', CURRENT_WORLD.portalColor1.toString(16).padStart(6, '0'));
                params.set('portalColor2', CURRENT_WORLD.portalColor2.toString(16).padStart(6, '0'));
                params.set('particleCount', CURRENT_WORLD.particleCount.toString());
                params.set('cameraHeight', this.camera.position.y.toString());
                params.set('fogNear', CURRENT_WORLD.fogNear.toString());
                params.set('fogFar', CURRENT_WORLD.fogFar.toString());
                
                return params.toString();
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
            }
            
            setupDesktopControls() {
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    } else {
                        this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                        const intersects = this.raycaster.intersectObjects(this.portals);
                        
                        if (intersects.length > 0) {
                            const portal = intersects[0].object;
                            if (portal.userData.url) {
                                this.enterWorld(portal.userData.url);
                            }
                        }
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }
            
            setupMobileControls() {
                const lookArea = document.getElementById('look-area');
                
                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.portals);
                    
                    if (intersects.length > 0) {
                        const portal = intersects[0].object;
                        if (portal.userData.url) {
                            e.preventDefault();
                            this.enterWorld(portal.userData.url);
                            return;
                        }
                    }
                    
                    this.lookTouch = {
                        id: touch.identifier,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                }, { passive: true });
                
                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;
                            
                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                            
                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;
                            
                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });
                
                lookArea.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                }, { passive: true });
                
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const touch = e.touches[0];
                    this.joystickTouch = {
                        id: touch.identifier
                    };
                    
                    this.joystickActive = true;
                    this.updateJoystick(touch, joystick, handle);
                }, { passive: false });
                
                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive || !this.joystickTouch) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.joystickTouch.id) {
                            this.updateJoystick(touch, joystick, handle);
                            break;
                        }
                    }
                }, { passive: false });
                
                joystick.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.joystickTouch && touch.identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickTouch = null;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';
                            
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                    }
                }, { passive: false });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            updateHover() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.portals);
                
                if (intersects.length > 0) {
                    const portal = intersects[0].object;
                    
                    if (portal !== this.hoveredPortal) {
                        this.hoveredPortal = portal;
                        
                        this.tooltipTitle.textContent = portal.userData.name;
                        this.tooltipDescription.textContent = portal.userData.description;
                        this.tooltip.classList.add('visible');
                        
                        const vector = new THREE.Vector3();
                        portal.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 320)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 200)}px`;
                    }
                } else {
                    if (this.hoveredPortal) {
                        this.hoveredPortal = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }
            
            async enterWorld(url) {
                try {
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').innerHTML = 'Entering new world...';
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Failed to load world (${response.status})`);
                    }
                    
                    let htmlContent = await response.text();
                    
                    const inheritanceParams = this.buildInheritanceParams();
                    
                    sessionStorage.setItem('worldInheritanceParams', '?' + inheritanceParams);
                    
                    const inheritanceData = {
                        params: inheritanceParams,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('worldTransition', JSON.stringify(inheritanceData));
                    
                    const paramScript = `<script>
                        window.INJECTED_PARAMS = '?${inheritanceParams}';
                        sessionStorage.setItem('worldInheritanceParams', '?${inheritanceParams}');
                        console.log('Injected params:', window.INJECTED_PARAMS);
                    <\/script>`;
                    
                    htmlContent = htmlContent.replace('<body>', `<body>${paramScript}`);
                    
                    const blob = new Blob([htmlContent], { type: 'text/html' });
                    const blobUrl = URL.createObjectURL(blob);
                    
                    window.location.href = blobUrl;
                    
                } catch (error) {
                    console.error('Error entering world:', error);
                    document.getElementById('loading').innerHTML = 'Failed to enter world. Please try again.';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 3000);
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = this.clock.getElapsedTime();
                
                this.updateMovement();
                this.updateHover();
                
                this.portals.forEach((portal, index) => {
                    if (portal.userData.material) {
                        portal.userData.material.uniforms.time.value = time;
                        
                        const intensity = 0.5 + Math.sin(time * 2 + index) * 0.3;
                        portal.userData.light.intensity = intensity;
                    }
                    
                    portal.rotation.z = Math.sin(time * 0.5 + index) * 0.1;
                });
                
                if (this.particles) {
                    this.particles.rotation.y = time * 0.05;
                    this.particles.position.y = Math.sin(time * 0.2) * 2;
                }
                
                
// Animations

                // Floating structures
                this.scene.traverse((child) => {
                    if (child.isMesh && child.geometry.type.includes('Geometry')) {
                        child.position.y += Math.sin(time + child.position.x * 0.1) * 0.01;
                    }
                });
                
                // Pulsing lights
                this.scene.traverse((child) => {
                    if (child.isLight && child.type === 'PointLight') {
                        const baseIntensity = child.userData.baseIntensity || child.intensity;
                        child.userData.baseIntensity = baseIntensity;
                        child.intensity = baseIntensity * (0.5 + Math.sin(time * 2) * 0.5);
                    }
                });
                
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            const navigator = new WorldNavigator();
            navigator.init();
        });
    </script>
</body>
</html>