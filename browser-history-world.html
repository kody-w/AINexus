<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Browser History World - Your Digital Footprint Made Physical</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0f;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 2.5em;
            font-weight: 100;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #00d4ff, #7b2fff, #ff0080, #00d4ff);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .world-description {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        .stats-panel {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            z-index: 1001;
            min-width: 220px;
        }

        .stats-title {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .stat-value {
            color: #00d4ff;
            font-weight: 500;
        }

        .import-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .import-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #7b2fff, #ff0080);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.85em;
        }

        .import-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(123, 47, 255, 0.4);
        }

        .demo-btn {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .demo-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .island-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(0, 212, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            max-width: 350px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(20px);
        }

        .island-tooltip.visible {
            display: block;
        }

        .tooltip-favicon {
            width: 32px;
            height: 32px;
            margin-right: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .tooltip-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .tooltip-title {
            font-size: 1.3em;
            font-weight: 400;
            color: #00d4ff;
        }

        .tooltip-url {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 10px;
            word-break: break-all;
        }

        .tooltip-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tooltip-stat {
            text-align: center;
        }

        .tooltip-stat-value {
            font-size: 1.4em;
            color: #ff0080;
            font-weight: 300;
        }

        .tooltip-stat-label {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
        }

        .tooltip-embarrassing {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(255, 0, 128, 0.2);
            border-radius: 8px;
            font-size: 0.85em;
            color: #ff6b9d;
            text-align: center;
        }

        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 212, 255, 0.5);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(0, 212, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
        }

        .loading-title {
            font-size: 1.5em;
            color: #00d4ff;
            margin-bottom: 20px;
            font-weight: 300;
        }

        .loading-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2fff, #ff0080);
            background-size: 200% 100%;
            animation: loadingShimmer 1.5s ease-in-out infinite;
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes loadingShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .fog-warning {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 128, 0.3);
            border: 1px solid rgba(255, 0, 128, 0.5);
            padding: 15px 30px;
            border-radius: 25px;
            color: #ff6b9d;
            font-size: 0.9em;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .fog-warning.visible {
            opacity: 1;
        }

        .multiplayer-panel {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            z-index: 1001;
            min-width: 180px;
        }

        .multiplayer-title {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }

        .player-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .player-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00d4ff, #7b2fff);
        }

        .player-name {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
        }

        .connect-btn {
            width: 100%;
            padding: 10px;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            color: #00d4ff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
            margin-top: 10px;
        }

        .connect-btn:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 1.8em;
            }

            .stats-panel {
                top: auto;
                bottom: 180px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }

            .multiplayer-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    <div class="look-area" id="look-area"></div>

    <div class="world-ui">
        <h1 class="world-title">BROWSER HISTORY WORLD</h1>
        <p class="world-description">Your digital footprint made physical. Every site is an island. Time spent = island size. The embarrassing ones hide in fog.</p>
    </div>

    <div class="stats-panel" id="stats-panel">
        <div class="stats-title">Your Digital Universe</div>
        <div class="stat-row">
            <span class="stat-label">Total Islands</span>
            <span class="stat-value" id="stat-islands">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Time Recorded</span>
            <span class="stat-value" id="stat-time">0h</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Hidden in Fog</span>
            <span class="stat-value" id="stat-hidden">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Largest Island</span>
            <span class="stat-value" id="stat-largest">-</span>
        </div>
        <div class="import-section">
            <button class="import-btn" onclick="importHistory()">Import Your History</button>
            <button class="demo-btn" onclick="loadDemoHistory()">Load Demo Universe</button>
            <input type="file" id="history-file" accept=".json,.csv" style="display: none;" onchange="handleFileImport(event)">
        </div>
    </div>

    <div class="multiplayer-panel" id="multiplayer-panel">
        <div class="multiplayer-title">Visitors</div>
        <div class="player-list" id="player-list">
            <div class="player-item">
                <div class="player-avatar"></div>
                <span class="player-name">You (Host)</span>
            </div>
        </div>
        <button class="connect-btn" id="connect-btn" onclick="toggleMultiplayer()">Share Universe</button>
    </div>

    <div class="island-tooltip" id="island-tooltip">
        <div class="tooltip-header">
            <img class="tooltip-favicon" id="tooltip-favicon" src="" alt="">
            <span class="tooltip-title" id="tooltip-title"></span>
        </div>
        <div class="tooltip-url" id="tooltip-url"></div>
        <div class="tooltip-stats">
            <div class="tooltip-stat">
                <div class="tooltip-stat-value" id="tooltip-visits">0</div>
                <div class="tooltip-stat-label">Visits</div>
            </div>
            <div class="tooltip-stat">
                <div class="tooltip-stat-value" id="tooltip-time">0m</div>
                <div class="tooltip-stat-label">Time Spent</div>
            </div>
        </div>
        <div class="tooltip-embarrassing" id="tooltip-embarrassing" style="display: none;">
            Hidden in fog for your protection
        </div>
    </div>

    <div class="controls-hint" id="controls-hint">
        WASD to fly between islands | Mouse to look | Click islands to explore | Space to ascend
    </div>

    <div class="fog-warning" id="fog-warning">
        Entering fog zone... some things are best left hidden
    </div>

    <div class="mobile-controls" id="mobile-controls">
        <div class="controls-container">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="loading-title">Materializing Your History...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loading-progress"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // Site categories and their visual properties
        const SITE_CATEGORIES = {
            social: {
                color: 0x1da1f2,
                keywords: ['facebook', 'twitter', 'instagram', 'tiktok', 'snapchat', 'linkedin', 'reddit', 'discord'],
                icon: 'ðŸ’¬'
            },
            entertainment: {
                color: 0xff0000,
                keywords: ['youtube', 'netflix', 'twitch', 'spotify', 'hulu', 'disney', 'hbo', 'vimeo'],
                icon: 'ðŸŽ¬'
            },
            shopping: {
                color: 0xff9900,
                keywords: ['amazon', 'ebay', 'etsy', 'walmart', 'target', 'aliexpress', 'shopify'],
                icon: 'ðŸ›’'
            },
            work: {
                color: 0x00a4ef,
                keywords: ['github', 'gitlab', 'slack', 'notion', 'trello', 'asana', 'jira', 'confluence', 'office', 'google'],
                icon: 'ðŸ’¼'
            },
            news: {
                color: 0x666666,
                keywords: ['cnn', 'bbc', 'nytimes', 'reuters', 'news', 'times', 'post', 'guardian'],
                icon: 'ðŸ“°'
            },
            education: {
                color: 0x00c853,
                keywords: ['wikipedia', 'stackoverflow', 'coursera', 'udemy', 'khan', 'edu', 'learn'],
                icon: 'ðŸ“š'
            },
            gaming: {
                color: 0x9147ff,
                keywords: ['steam', 'epic', 'playstation', 'xbox', 'nintendo', 'itch.io', 'game'],
                icon: 'ðŸŽ®'
            },
            adult: {
                color: 0xff0080,
                keywords: ['porn', 'xxx', 'adult', 'nsfw', 'onlyfans'],
                embarrassing: true,
                icon: 'ðŸ”ž'
            },
            dating: {
                color: 0xfe3c72,
                keywords: ['tinder', 'bumble', 'hinge', 'okcupid', 'match', 'dating'],
                embarrassing: true,
                icon: 'ðŸ’•'
            },
            health: {
                color: 0x4caf50,
                keywords: ['webmd', 'mayoclinic', 'health', 'symptom', 'doctor'],
                embarrassing: true,
                icon: 'ðŸ¥'
            },
            finance: {
                color: 0x2e7d32,
                keywords: ['bank', 'paypal', 'venmo', 'crypto', 'coinbase', 'robinhood', 'fidelity'],
                icon: 'ðŸ’°'
            },
            other: {
                color: 0x9e9e9e,
                keywords: [],
                icon: 'ðŸŒ'
            }
        };

        // Demo history data
        const DEMO_HISTORY = [
            { url: 'youtube.com', title: 'YouTube', visits: 847, timeSpent: 14400 },
            { url: 'github.com', title: 'GitHub', visits: 523, timeSpent: 28800 },
            { url: 'twitter.com', title: 'Twitter', visits: 412, timeSpent: 7200 },
            { url: 'reddit.com', title: 'Reddit', visits: 389, timeSpent: 10800 },
            { url: 'stackoverflow.com', title: 'Stack Overflow', visits: 256, timeSpent: 5400 },
            { url: 'amazon.com', title: 'Amazon', visits: 178, timeSpent: 3600 },
            { url: 'netflix.com', title: 'Netflix', visits: 156, timeSpent: 21600 },
            { url: 'linkedin.com', title: 'LinkedIn', visits: 134, timeSpent: 1800 },
            { url: 'spotify.com', title: 'Spotify', visits: 298, timeSpent: 43200 },
            { url: 'google.com', title: 'Google', visits: 1247, timeSpent: 3600 },
            { url: 'wikipedia.org', title: 'Wikipedia', visits: 189, timeSpent: 5400 },
            { url: 'twitch.tv', title: 'Twitch', visits: 167, timeSpent: 18000 },
            { url: 'discord.com', title: 'Discord', visits: 445, timeSpent: 36000 },
            { url: 'notion.so', title: 'Notion', visits: 234, timeSpent: 14400 },
            { url: 'figma.com', title: 'Figma', visits: 145, timeSpent: 10800 },
            { url: 'webmd.com', title: 'WebMD', visits: 23, timeSpent: 1200 },
            { url: 'tinder.com', title: 'Tinder', visits: 89, timeSpent: 2700 },
            { url: 'chatgpt.com', title: 'ChatGPT', visits: 567, timeSpent: 21600 },
            { url: 'medium.com', title: 'Medium', visits: 98, timeSpent: 4500 },
            { url: 'nytimes.com', title: 'NY Times', visits: 145, timeSpent: 5400 },
            { url: 'steam.com', title: 'Steam', visits: 178, timeSpent: 3600 },
            { url: 'ebay.com', title: 'eBay', visits: 67, timeSpent: 2400 },
            { url: 'instagram.com', title: 'Instagram', visits: 334, timeSpent: 9000 },
            { url: 'tiktok.com', title: 'TikTok', visits: 267, timeSpent: 12600 },
            { url: 'slack.com', title: 'Slack', visits: 389, timeSpent: 28800 },
            { url: 'pornhub.com', title: 'Research', visits: 45, timeSpent: 1800 },
            { url: 'zillow.com', title: 'Zillow', visits: 78, timeSpent: 5400 },
            { url: 'airbnb.com', title: 'Airbnb', visits: 34, timeSpent: 2700 },
            { url: 'craigslist.org', title: 'Craigslist', visits: 23, timeSpent: 900 },
            { url: 'hulu.com', title: 'Hulu', visits: 89, timeSpent: 10800 }
        ];

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);

        class BrowserHistoryWorld {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.islands = [];
                this.historyData = [];
                this.raycaster = new THREE.Raycaster();
                this.clock = new THREE.Clock();

                this.moveSpeed = 0.5;
                this.lookSpeed = 0.002;
                this.keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
                this.rotation = { x: 0, y: 0 };
                this.velocity = new THREE.Vector3();

                this.isMobile = isMobile;
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;

                this.hoveredIsland = null;
                this.tooltip = document.getElementById('island-tooltip');
                this.isPointerLocked = false;

                this.fogZones = [];
                this.inFogZone = false;

                // Multiplayer
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.playerId = this.generateId();

                // Particles
                this.particles = null;
                this.connectionLines = [];
            }

            generateId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            async init() {
                this.setupScene();
                this.setupLighting();
                this.createSkybox();
                this.createParticles();
                this.setupEventListeners();

                if (this.isMobile) {
                    document.getElementById('controls-hint').textContent = 'Touch & drag to look | Joystick to fly | Tap islands to explore';
                    document.getElementById('mobile-controls').classList.add('show');
                }

                // Load demo history by default
                setTimeout(() => {
                    this.loadDemoHistory();
                }, 500);
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x0a0a15, 0.008);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.camera.position.set(0, 50, 100);

                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
                this.scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                sunLight.position.set(100, 200, 100);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                this.scene.add(sunLight);

                // Colored point lights for atmosphere
                const lights = [
                    { color: 0x00d4ff, position: [-100, 80, -100], intensity: 0.5 },
                    { color: 0x7b2fff, position: [100, 60, 100], intensity: 0.4 },
                    { color: 0xff0080, position: [0, 100, -150], intensity: 0.3 }
                ];

                lights.forEach(l => {
                    const light = new THREE.PointLight(l.color, l.intensity, 300);
                    light.position.set(...l.position);
                    this.scene.add(light);
                });
            }

            createSkybox() {
                // Create a gradient sphere for the sky
                const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(0x0a0a20) },
                        bottomColor: { value: new THREE.Color(0x000005) },
                        offset: { value: 400 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                // Add stars
                const starsGeometry = new THREE.BufferGeometry();
                const starPositions = [];
                for (let i = 0; i < 5000; i++) {
                    const radius = 800 + Math.random() * 200;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    starPositions.push(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 1.5,
                    transparent: true,
                    opacity: 0.8
                });
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(stars);
            }

            createParticles() {
                const particleCount = 2000;
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];

                for (let i = 0; i < particleCount; i++) {
                    positions.push(
                        (Math.random() - 0.5) * 600,
                        Math.random() * 200 - 50,
                        (Math.random() - 0.5) * 600
                    );

                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.3 + 0.5, 0.8, 0.6);
                    colors.push(color.r, color.g, color.b);
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });

                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }

            categorySite(url) {
                const urlLower = url.toLowerCase();
                for (const [category, data] of Object.entries(SITE_CATEGORIES)) {
                    if (data.keywords.some(keyword => urlLower.includes(keyword))) {
                        return { category, ...data };
                    }
                }
                return { category: 'other', ...SITE_CATEGORIES.other };
            }

            createIsland(site, index, total) {
                const category = this.categorySite(site.url);
                const isEmbarrassing = category.embarrassing || false;

                // Calculate size based on time spent (logarithmic scale)
                const baseSize = Math.log(site.timeSpent / 60 + 1) * 2 + 3;
                const size = Math.min(baseSize, 25);

                // Position islands in a spiral galaxy pattern
                const angle = (index / total) * Math.PI * 8;
                const radius = 30 + (index / total) * 200;
                const heightVariation = Math.sin(angle * 3) * 30;

                const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 40;
                const y = heightVariation + (Math.random() - 0.5) * 20;
                const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 40;

                // Create floating island group
                const islandGroup = new THREE.Group();
                islandGroup.position.set(x, y, z);

                // Main island body - organic shape
                const islandGeometry = new THREE.DodecahedronGeometry(size, 1);
                const vertices = islandGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const noise = (Math.random() - 0.5) * size * 0.3;
                    vertices[i] += noise;
                    vertices[i + 1] = vertices[i + 1] * 0.4 + (vertices[i + 1] > 0 ? size * 0.3 : -size * 0.2);
                    vertices[i + 2] += noise;
                }
                islandGeometry.computeVertexNormals();

                const islandMaterial = new THREE.MeshStandardMaterial({
                    color: category.color,
                    roughness: 0.7,
                    metalness: 0.2,
                    emissive: category.color,
                    emissiveIntensity: isEmbarrassing ? 0.1 : 0.2
                });

                const island = new THREE.Mesh(islandGeometry, islandMaterial);
                island.castShadow = true;
                island.receiveShadow = true;
                islandGroup.add(island);

                // Add glowing core
                const coreGeometry = new THREE.SphereGeometry(size * 0.3, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: category.color,
                    transparent: true,
                    opacity: 0.6
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = size * 0.5;
                islandGroup.add(core);

                // Add point light
                const light = new THREE.PointLight(category.color, 0.5, size * 4);
                light.position.y = size * 0.5;
                islandGroup.add(light);

                // Add structures based on visits
                const structureCount = Math.min(Math.floor(site.visits / 50), 8);
                for (let i = 0; i < structureCount; i++) {
                    const structureHeight = Math.random() * size * 0.8 + size * 0.3;
                    const structureGeometry = new THREE.CylinderGeometry(
                        size * 0.05,
                        size * 0.1,
                        structureHeight,
                        6
                    );
                    const structureMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: category.color,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.8
                    });
                    const structure = new THREE.Mesh(structureGeometry, structureMaterial);

                    const structureAngle = (i / structureCount) * Math.PI * 2;
                    const structureRadius = size * 0.5;
                    structure.position.set(
                        Math.cos(structureAngle) * structureRadius,
                        size * 0.3 + structureHeight / 2,
                        Math.sin(structureAngle) * structureRadius
                    );
                    islandGroup.add(structure);
                }

                // Add fog zone for embarrassing sites
                if (isEmbarrassing) {
                    const fogGeometry = new THREE.SphereGeometry(size * 3, 16, 16);
                    const fogMaterial = new THREE.MeshBasicMaterial({
                        color: 0x1a0a1a,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.BackSide
                    });
                    const fog = new THREE.Mesh(fogGeometry, fogMaterial);
                    islandGroup.add(fog);

                    this.fogZones.push({
                        position: new THREE.Vector3(x, y, z),
                        radius: size * 3
                    });
                }

                // Store metadata
                island.userData = {
                    site: site,
                    category: category,
                    size: size,
                    isEmbarrassing: isEmbarrassing,
                    light: light,
                    core: core,
                    baseY: y,
                    floatOffset: Math.random() * Math.PI * 2
                };

                this.scene.add(islandGroup);
                this.islands.push({ group: islandGroup, mesh: island, data: island.userData });

                return islandGroup;
            }

            createConnectionLines() {
                // Remove old lines
                this.connectionLines.forEach(line => this.scene.remove(line));
                this.connectionLines = [];

                // Create lines between related islands
                const categories = {};
                this.islands.forEach((island, index) => {
                    const cat = island.data.category.category;
                    if (!categories[cat]) categories[cat] = [];
                    categories[cat].push(index);
                });

                Object.values(categories).forEach(indices => {
                    if (indices.length < 2) return;

                    for (let i = 0; i < indices.length - 1; i++) {
                        const from = this.islands[indices[i]].group.position;
                        const to = this.islands[indices[i + 1]].group.position;

                        const points = [from, to];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: this.islands[indices[i]].data.category.color,
                            transparent: true,
                            opacity: 0.15
                        });
                        const line = new THREE.Line(geometry, material);
                        this.scene.add(line);
                        this.connectionLines.push(line);
                    }
                });
            }

            loadHistory(data) {
                // Clear existing islands
                this.islands.forEach(island => this.scene.remove(island.group));
                this.islands = [];
                this.fogZones = [];

                // Sort by time spent
                const sortedData = [...data].sort((a, b) => b.timeSpent - a.timeSpent);
                this.historyData = sortedData;

                // Create islands with loading progress
                const loadingProgress = document.getElementById('loading-progress');
                let loaded = 0;

                sortedData.forEach((site, index) => {
                    setTimeout(() => {
                        this.createIsland(site, index, sortedData.length);
                        loaded++;
                        loadingProgress.style.width = (loaded / sortedData.length * 100) + '%';

                        if (loaded === sortedData.length) {
                            this.createConnectionLines();
                            setTimeout(() => {
                                document.getElementById('loading').style.display = 'none';
                            }, 500);
                        }
                    }, index * 50);
                });

                this.updateStats(sortedData);
            }

            loadDemoHistory() {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading-progress').style.width = '0%';
                this.loadHistory(DEMO_HISTORY);
            }

            updateStats(data) {
                const totalTime = data.reduce((sum, site) => sum + site.timeSpent, 0);
                const hiddenCount = data.filter(site => this.categorySite(site.url).embarrassing).length;
                const largest = data[0];

                document.getElementById('stat-islands').textContent = data.length;
                document.getElementById('stat-time').textContent = Math.round(totalTime / 3600) + 'h';
                document.getElementById('stat-hidden').textContent = hiddenCount;
                document.getElementById('stat-largest').textContent = largest ? largest.title.substring(0, 12) : '-';
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
            }

            setupDesktopControls() {
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys) this.keys[key] = true;
                    if (e.code === 'Space') { this.keys.space = true; e.preventDefault(); }
                    if (key === 'shift') this.keys.shift = true;
                });

                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys) this.keys[key] = false;
                    if (e.code === 'Space') this.keys.space = false;
                    if (key === 'shift') this.keys.shift = false;
                });

                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    } else {
                        this.checkIslandClick();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }

            setupMobileControls() {
                const lookArea = document.getElementById('look-area');

                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.lookTouch = {
                        id: touch.identifier,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                }, { passive: true });

                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;
                    for (let touch of e.touches) {
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;
                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;
                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });

                lookArea.addEventListener('touchend', (e) => {
                    for (let touch of e.changedTouches) {
                        if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                }, { passive: true });

                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.joystickTouch = { id: e.touches[0].identifier };
                    this.updateJoystick(e.touches[0], joystick, handle);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive) return;
                    e.preventDefault();
                    for (let touch of e.touches) {
                        if (touch.identifier === this.joystickTouch.id) {
                            this.updateJoystick(touch, joystick, handle);
                            break;
                        }
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    for (let touch of e.changedTouches) {
                        if (this.joystickTouch && touch.identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickTouch = null;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';
                            break;
                        }
                    }
                }, { passive: false });
            }

            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }

            checkIslandClick() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const meshes = this.islands.map(i => i.mesh);
                const intersects = this.raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const island = intersects[0].object;
                    const site = island.userData.site;
                    if (site && site.url) {
                        // Could open the actual URL or show more info
                        console.log('Clicked:', site.url);
                    }
                }
            }

            checkFogZone() {
                const wasInFog = this.inFogZone;
                this.inFogZone = false;

                for (const zone of this.fogZones) {
                    const distance = this.camera.position.distanceTo(zone.position);
                    if (distance < zone.radius) {
                        this.inFogZone = true;
                        break;
                    }
                }

                const warning = document.getElementById('fog-warning');
                if (this.inFogZone && !wasInFog) {
                    warning.classList.add('visible');
                } else if (!this.inFogZone && wasInFog) {
                    warning.classList.remove('visible');
                }
            }

            updateHover() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const meshes = this.islands.map(i => i.mesh);
                const intersects = this.raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const island = intersects[0].object;

                    if (island !== this.hoveredIsland) {
                        this.hoveredIsland = island;
                        const data = island.userData;
                        const site = data.site;

                        document.getElementById('tooltip-title').textContent = site.title;
                        document.getElementById('tooltip-url').textContent = site.url;
                        document.getElementById('tooltip-visits').textContent = site.visits;
                        document.getElementById('tooltip-time').textContent = Math.round(site.timeSpent / 60) + 'm';

                        const embarrassingNote = document.getElementById('tooltip-embarrassing');
                        embarrassingNote.style.display = data.isEmbarrassing ? 'block' : 'none';

                        // Try to load favicon
                        const favicon = document.getElementById('tooltip-favicon');
                        favicon.src = `https://www.google.com/s2/favicons?domain=${site.url}&sz=64`;
                        favicon.onerror = () => { favicon.src = ''; };

                        this.tooltip.classList.add('visible');

                        const vector = new THREE.Vector3();
                        island.getWorldPosition(vector);
                        vector.project(this.camera);
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 370)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 250)}px`;
                    }
                } else {
                    if (this.hoveredIsland) {
                        this.hoveredIsland = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }

            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                this.camera.getWorldDirection(forward);
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

                const acceleration = 0.02;
                const friction = 0.95;

                if (this.isMobile) {
                    if (this.joystickActive) {
                        this.velocity.add(forward.multiplyScalar(this.joystickVector.y * acceleration));
                        forward.set(0, 0, 0);
                        this.camera.getWorldDirection(forward);
                        this.velocity.add(right.multiplyScalar(this.joystickVector.x * acceleration));
                    }
                } else {
                    if (this.keys.w) this.velocity.add(forward.clone().multiplyScalar(acceleration));
                    if (this.keys.s) this.velocity.add(forward.clone().multiplyScalar(-acceleration));
                    if (this.keys.a) this.velocity.add(right.clone().multiplyScalar(-acceleration));
                    if (this.keys.d) this.velocity.add(right.clone().multiplyScalar(acceleration));
                    if (this.keys.space) this.velocity.y += acceleration;
                    if (this.keys.shift) this.velocity.y -= acceleration;
                }

                this.velocity.multiplyScalar(friction);
                this.velocity.clampLength(0, this.moveSpeed);
                this.camera.position.add(this.velocity);

                // Boundary limits
                this.camera.position.y = Math.max(-50, Math.min(200, this.camera.position.y));

                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                this.updateMovement();
                this.updateHover();
                this.checkFogZone();

                // Animate islands
                this.islands.forEach((island, index) => {
                    const data = island.data;

                    // Floating motion
                    island.group.position.y = data.baseY + Math.sin(time + data.floatOffset) * 2;

                    // Rotate slowly
                    island.group.rotation.y += 0.001;

                    // Pulse lights
                    if (data.light) {
                        data.light.intensity = 0.3 + Math.sin(time * 2 + index) * 0.2;
                    }

                    // Pulse core
                    if (data.core) {
                        data.core.scale.setScalar(1 + Math.sin(time * 3 + index) * 0.1);
                    }
                });

                // Animate particles
                if (this.particles) {
                    const positions = this.particles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + positions[i] * 0.01) * 0.05;
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                    this.particles.rotation.y += 0.0002;
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Global functions
        let world;

        function importHistory() {
            document.getElementById('history-file').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // Normalize data format
                    const normalized = data.map(item => ({
                        url: item.url || item.domain || '',
                        title: item.title || item.name || item.url,
                        visits: item.visits || item.visitCount || 1,
                        timeSpent: item.timeSpent || item.duration || item.visits * 60
                    }));
                    document.getElementById('loading').style.display = 'block';
                    world.loadHistory(normalized);
                } catch (err) {
                    alert('Could not parse history file. Please use JSON format.');
                }
            };
            reader.readAsText(file);
        }

        function loadDemoHistory() {
            world.loadDemoHistory();
        }

        function toggleMultiplayer() {
            const btn = document.getElementById('connect-btn');
            if (!world.peer) {
                world.peer = new Peer(world.playerId);
                world.peer.on('open', (id) => {
                    btn.textContent = 'Connected: ' + id.substring(0, 8);
                    world.isHost = true;
                });
                world.peer.on('connection', (conn) => {
                    world.connections.set(conn.peer, conn);
                    conn.on('data', (data) => {
                        console.log('Received:', data);
                    });
                });
            } else {
                // Share link
                const url = window.location.href + '?join=' + world.playerId;
                navigator.clipboard.writeText(url).then(() => {
                    btn.textContent = 'Link Copied!';
                    setTimeout(() => {
                        btn.textContent = 'Share Universe';
                    }, 2000);
                });
            }
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            world = new BrowserHistoryWorld();
            world.init();
            world.animate();
        });
    </script>
</body>
</html>
