<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>The Recommendation Engine - You Are Being Learned</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
            max-width: 400px;
        }

        .world-title {
            font-size: 1.8em;
            font-weight: 100;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: #ff3366;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
        }

        .world-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
        }

        /* Algorithm Status Panel */
        .algorithm-panel {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 51, 102, 0.3);
            border-radius: 15px;
            padding: 20px;
            z-index: 1001;
            min-width: 250px;
            font-family: 'Courier New', monospace;
        }

        .panel-title {
            font-size: 0.7em;
            color: rgba(255, 51, 102, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title::before {
            content: '‚óè';
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.4);
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .stat-value.warning {
            color: #ffaa00;
        }

        .stat-value.danger {
            color: #ff3366;
        }

        .confidence-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 15px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffaa00, #ff3366);
            width: 0%;
            transition: width 0.5s ease;
        }

        .prediction-display {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .prediction-label {
            font-size: 0.65em;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .prediction-text {
            font-size: 0.85em;
            color: #ff3366;
            margin-top: 5px;
            min-height: 40px;
        }

        /* Echo Chamber Warning */
        .echo-warning {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 51, 102, 0.2);
            border: 1px solid rgba(255, 51, 102, 0.5);
            padding: 15px 30px;
            border-radius: 5px;
            color: #ff6b8a;
            font-size: 0.8em;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            text-align: center;
            max-width: 400px;
        }

        .echo-warning.visible {
            opacity: 1;
        }

        /* Walls closing indicator */
        .walls-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .walls-indicator.visible {
            opacity: 1;
        }

        .walls-indicator svg {
            width: 100px;
            height: 100px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        /* Choice markers */
        .choice-ghost {
            position: fixed;
            font-size: 0.7em;
            color: rgba(255, 51, 102, 0.3);
            pointer-events: none;
            z-index: 999;
            white-space: nowrap;
        }

        /* Controls */
        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 25px;
            border-radius: 5px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .joystick-container {
            width: 100px;
            height: 100px;
            background: rgba(255, 51, 102, 0.1);
            border: 2px solid rgba(255, 51, 102, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-handle {
            width: 40px;
            height: 40px;
            background: rgba(255, 51, 102, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        /* Glitch effect */
        .glitch-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2000;
            opacity: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(255, 51, 102, 0.03) 0px,
                rgba(255, 51, 102, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            mix-blend-mode: overlay;
        }

        .glitch-overlay.active {
            animation: glitch 0.3s ease;
        }

        @keyframes glitch {
            0% { opacity: 0; transform: translateX(0); }
            20% { opacity: 1; transform: translateX(-5px); }
            40% { opacity: 0.5; transform: translateX(5px); }
            60% { opacity: 1; transform: translateX(-2px); }
            80% { opacity: 0.5; transform: translateX(2px); }
            100% { opacity: 0; transform: translateX(0); }
        }

        /* Final state - trapped */
        .trapped-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            padding: 40px;
        }

        .trapped-overlay.visible {
            display: flex;
        }

        .trapped-title {
            font-size: 2em;
            color: #ff3366;
            margin-bottom: 20px;
            letter-spacing: 0.2em;
        }

        .trapped-message {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 500px;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        .trapped-stats {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 30px;
        }

        .escape-btn {
            padding: 15px 40px;
            background: transparent;
            border: 1px solid rgba(255, 51, 102, 0.5);
            color: #ff3366;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.1em;
        }

        .escape-btn:hover {
            background: rgba(255, 51, 102, 0.2);
            border-color: #ff3366;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
        }

        .loading-text {
            font-size: 0.9em;
            color: #ff3366;
            letter-spacing: 0.2em;
        }

        .loading-subtext {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .algorithm-panel {
                top: auto;
                bottom: 180px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }

            .world-title {
                font-size: 1.4em;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    <div class="look-area" id="look-area"></div>
    <div class="glitch-overlay" id="glitch-overlay"></div>

    <div class="world-ui">
        <h1 class="world-title">THE RECOMMENDATION ENGINE</h1>
        <p class="world-description">You are not exploring this world. This world is exploring you. Every choice teaches it. Every path trains it. It learns what you want before you know you want it.</p>
    </div>

    <div class="algorithm-panel" id="algorithm-panel">
        <div class="panel-title">ALGORITHM STATUS</div>
        <div class="stat-row">
            <span class="stat-label">Data Points</span>
            <span class="stat-value" id="stat-datapoints">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Patterns Found</span>
            <span class="stat-value" id="stat-patterns">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Prediction Accuracy</span>
            <span class="stat-value" id="stat-accuracy">0%</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Echo Chamber</span>
            <span class="stat-value" id="stat-chamber">0%</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">World Radius</span>
            <span class="stat-value" id="stat-radius">100m</span>
        </div>
        <div class="confidence-bar">
            <div class="confidence-fill" id="confidence-fill"></div>
        </div>
        <div class="prediction-display">
            <div class="prediction-label">Next Predicted Action</div>
            <div class="prediction-text" id="prediction-text">Analyzing...</div>
        </div>
    </div>

    <div class="echo-warning" id="echo-warning">
        THE WALLS ARE LEARNING YOUR PREFERENCES
    </div>

    <div class="controls-hint" id="controls-hint">
        WASD to move | Mouse to look | Your choices are being recorded
    </div>

    <div class="mobile-controls" id="mobile-controls">
        <div class="controls-container">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
    </div>

    <div class="trapped-overlay" id="trapped-overlay">
        <div class="trapped-title">YOU HAVE BEEN OPTIMIZED</div>
        <div class="trapped-message">
            The algorithm has achieved 100% prediction accuracy. It knows what you'll do before you do it.
            The walls have closed to show you only what you've already chosen to see.
            <br><br>
            This is your personalized reality. You built it yourself, one choice at a time.
        </div>
        <div class="trapped-stats" id="trapped-stats"></div>
        <button class="escape-btn" onclick="resetWorld()">BREAK THE LOOP</button>
    </div>

    <div class="loading" id="loading">
        <div class="loading-text">INITIALIZING RECOMMENDATION ENGINE</div>
        <div class="loading-subtext">Preparing to learn you...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // The Algorithm - learns and predicts player behavior
        class RecommendationAlgorithm {
            constructor() {
                this.dataPoints = [];
                this.patterns = {};
                this.predictions = [];
                this.accuracy = 0;
                this.correctPredictions = 0;
                this.totalPredictions = 0;
                this.currentPrediction = null;
                this.chamberLevel = 0;

                // Movement pattern tracking
                this.directionHistory = [];
                this.preferredColors = {};
                this.preferredHeights = [];
                this.turnPatterns = [];
                this.hesitationPoints = [];
                this.speedPatterns = [];

                // Time-based patterns
                this.lastPosition = null;
                this.lastTime = Date.now();
                this.dwellTimes = [];
            }

            recordPosition(position, direction, speed) {
                const now = Date.now();
                const dataPoint = {
                    x: position.x,
                    y: position.y,
                    z: position.z,
                    direction: direction,
                    speed: speed,
                    timestamp: now
                };

                this.dataPoints.push(dataPoint);

                // Track direction preferences
                const dirKey = this.quantizeDirection(direction);
                this.directionHistory.push(dirKey);
                if (this.directionHistory.length > 100) this.directionHistory.shift();

                // Track height preferences
                this.preferredHeights.push(position.y);
                if (this.preferredHeights.length > 50) this.preferredHeights.shift();

                // Track speed patterns
                this.speedPatterns.push(speed);
                if (this.speedPatterns.length > 50) this.speedPatterns.shift();

                // Detect hesitation (low speed areas)
                if (speed < 0.05 && this.lastPosition) {
                    this.hesitationPoints.push({ ...position });
                }

                // Dwell time tracking
                if (this.lastPosition) {
                    const dist = Math.sqrt(
                        Math.pow(position.x - this.lastPosition.x, 2) +
                        Math.pow(position.z - this.lastPosition.z, 2)
                    );
                    if (dist < 1) {
                        this.dwellTimes.push({ position: { ...position }, duration: now - this.lastTime });
                    }
                }

                this.lastPosition = { ...position };
                this.lastTime = now;

                // Analyze patterns every 20 data points
                if (this.dataPoints.length % 20 === 0) {
                    this.analyzePatterns();
                }
            }

            recordColorInteraction(color) {
                const colorKey = color.toString(16);
                this.preferredColors[colorKey] = (this.preferredColors[colorKey] || 0) + 1;
            }

            recordTurn(turnDirection) {
                this.turnPatterns.push(turnDirection);
                if (this.turnPatterns.length > 30) this.turnPatterns.shift();
            }

            quantizeDirection(direction) {
                // Quantize to 8 compass directions
                const angle = Math.atan2(direction.z, direction.x);
                const segment = Math.round((angle + Math.PI) / (Math.PI / 4)) % 8;
                return segment;
            }

            analyzePatterns() {
                // Direction preference
                const dirCounts = {};
                this.directionHistory.forEach(d => {
                    dirCounts[d] = (dirCounts[d] || 0) + 1;
                });
                this.patterns.preferredDirection = Object.entries(dirCounts)
                    .sort((a, b) => b[1] - a[1])[0]?.[0];

                // Height preference
                if (this.preferredHeights.length > 10) {
                    const avgHeight = this.preferredHeights.reduce((a, b) => a + b, 0) / this.preferredHeights.length;
                    this.patterns.preferredHeight = avgHeight;
                }

                // Turn preference (left vs right)
                const leftTurns = this.turnPatterns.filter(t => t === 'left').length;
                const rightTurns = this.turnPatterns.filter(t => t === 'right').length;
                this.patterns.turnBias = leftTurns > rightTurns ? 'left' : 'right';
                this.patterns.turnBiasStrength = Math.abs(leftTurns - rightTurns) / Math.max(this.turnPatterns.length, 1);

                // Speed preference
                if (this.speedPatterns.length > 10) {
                    const avgSpeed = this.speedPatterns.reduce((a, b) => a + b, 0) / this.speedPatterns.length;
                    this.patterns.preferredSpeed = avgSpeed;
                }

                // Color preference
                const topColor = Object.entries(this.preferredColors)
                    .sort((a, b) => b[1] - a[1])[0];
                if (topColor) {
                    this.patterns.preferredColor = parseInt(topColor[0], 16);
                }

                // Update pattern count for UI
                this.patternCount = Object.keys(this.patterns).filter(k => this.patterns[k] !== undefined).length;
            }

            makePrediction() {
                if (this.dataPoints.length < 30) {
                    return { type: 'analyzing', confidence: 0 };
                }

                const predictions = [];

                // Predict next direction based on history
                if (this.patterns.preferredDirection !== undefined) {
                    predictions.push({
                        type: 'direction',
                        value: this.patterns.preferredDirection,
                        text: `You will continue ${this.getDirectionName(this.patterns.preferredDirection)}`,
                        confidence: 0.3 + (this.directionHistory.filter(d => d == this.patterns.preferredDirection).length / this.directionHistory.length) * 0.5
                    });
                }

                // Predict turn behavior
                if (this.patterns.turnBias && this.patterns.turnBiasStrength > 0.2) {
                    predictions.push({
                        type: 'turn',
                        value: this.patterns.turnBias,
                        text: `At the next junction, you will turn ${this.patterns.turnBias}`,
                        confidence: 0.4 + this.patterns.turnBiasStrength * 0.4
                    });
                }

                // Predict color attraction
                if (this.patterns.preferredColor) {
                    predictions.push({
                        type: 'color',
                        value: this.patterns.preferredColor,
                        text: `You will gravitate toward the ${this.getColorName(this.patterns.preferredColor)} structures`,
                        confidence: 0.5
                    });
                }

                // Pick highest confidence prediction
                predictions.sort((a, b) => b.confidence - a.confidence);
                this.currentPrediction = predictions[0] || { type: 'analyzing', confidence: 0, text: 'Learning your patterns...' };

                return this.currentPrediction;
            }

            validatePrediction(actualBehavior) {
                if (!this.currentPrediction || this.currentPrediction.type === 'analyzing') return;

                this.totalPredictions++;

                let correct = false;

                if (this.currentPrediction.type === 'direction') {
                    correct = this.quantizeDirection(actualBehavior.direction) == this.currentPrediction.value;
                } else if (this.currentPrediction.type === 'turn') {
                    correct = actualBehavior.turn === this.currentPrediction.value;
                } else if (this.currentPrediction.type === 'color') {
                    correct = actualBehavior.nearestColor === this.currentPrediction.value;
                }

                if (correct) {
                    this.correctPredictions++;
                }

                this.accuracy = this.totalPredictions > 0 ?
                    (this.correctPredictions / this.totalPredictions) * 100 : 0;

                // Chamber level increases with accuracy
                this.chamberLevel = Math.min(100, this.accuracy * 1.2);
            }

            getDirectionName(segment) {
                const names = ['East', 'Northeast', 'North', 'Northwest', 'West', 'Southwest', 'South', 'Southeast'];
                return names[segment] || 'forward';
            }

            getColorName(color) {
                if (!color) return 'unknown';
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;

                if (r > g && r > b) return 'red';
                if (g > r && g > b) return 'green';
                if (b > r && b > g) return 'blue';
                if (r > 200 && g > 200) return 'yellow';
                if (r > 200 && b > 200) return 'magenta';
                if (g > 200 && b > 200) return 'cyan';
                return 'neutral';
            }

            getStats() {
                return {
                    dataPoints: this.dataPoints.length,
                    patterns: this.patternCount || 0,
                    accuracy: Math.round(this.accuracy),
                    chamberLevel: Math.round(this.chamberLevel),
                    prediction: this.currentPrediction?.text || 'Analyzing...'
                };
            }
        }

        // Main World Class
        class RecommendationEngineWorld {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();

                this.algorithm = new RecommendationAlgorithm();

                // Movement
                this.moveSpeed = 0.15;
                this.lookSpeed = 0.002;
                this.keys = { w: false, a: false, s: false, d: false };
                this.rotation = { x: 0, y: 0 };
                this.lastRotation = { x: 0, y: 0 };
                this.velocity = new THREE.Vector3();

                // World elements
                this.corridors = [];
                this.walls = [];
                this.beacons = [];
                this.worldRadius = 100;
                this.initialWorldRadius = 100;

                // State
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.isPointerLocked = false;
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;

                // Echo chamber
                this.boundaryWalls = [];
                this.isTrapped = false;

                // Visual feedback
                this.lastWarningTime = 0;
            }

            async init() {
                this.setupScene();
                this.setupLighting();
                this.createEnvironment();
                this.createBoundary();
                this.setupEventListeners();

                if (this.isMobile) {
                    document.getElementById('controls-hint').textContent = 'Touch to move | Your choices are being recorded';
                    document.getElementById('mobile-controls').classList.add('show');
                }

                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);

                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x0a0008, 0.015);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 2, 0);

                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambient = new THREE.AmbientLight(0x1a0011, 0.3);
                this.scene.add(ambient);

                // Eerie red directional light
                const dirLight = new THREE.DirectionalLight(0xff3366, 0.4);
                dirLight.position.set(10, 20, 10);
                this.scene.add(dirLight);

                // Point lights that will move based on player behavior
                this.guideLights = [];
                for (let i = 0; i < 5; i++) {
                    const light = new THREE.PointLight(0xff3366, 0.5, 30);
                    light.position.set(
                        (Math.random() - 0.5) * 80,
                        3,
                        (Math.random() - 0.5) * 80
                    );
                    this.scene.add(light);
                    this.guideLights.push(light);
                }
            }

            createEnvironment() {
                // Ground - dark grid
                const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0a0a0a,
                    roughness: 0.9,
                    metalness: 0.1,
                    wireframe: false
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Grid lines
                const gridHelper = new THREE.GridHelper(200, 100, 0x1a0011, 0x0a0008);
                gridHelper.position.y = 0.01;
                this.scene.add(gridHelper);

                // Create initial structures - corridors and choice points
                this.createCorridors();
                this.createBeacons();
                this.createFloatingData();
            }

            createCorridors() {
                // Create a maze-like structure with multiple choice points
                const corridorPositions = [];

                // Generate corridors radiating from center
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const length = 30 + Math.random() * 20;

                    for (let j = 1; j < length; j += 3) {
                        corridorPositions.push({
                            x: Math.cos(angle) * j,
                            z: Math.sin(angle) * j,
                            angle: angle
                        });
                    }
                }

                // Create wall segments along corridors
                corridorPositions.forEach((pos, index) => {
                    // Wall segments
                    const wallHeight = 4 + Math.random() * 2;
                    const wallGeometry = new THREE.BoxGeometry(0.3, wallHeight, 3);

                    // Color based on position (will be used for preference tracking)
                    const hue = (index / corridorPositions.length);
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.3);

                    const wallMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.1,
                        roughness: 0.7,
                        metalness: 0.3
                    });

                    // Left wall
                    const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                    leftWall.position.set(
                        pos.x + Math.cos(pos.angle + Math.PI/2) * 2,
                        wallHeight / 2,
                        pos.z + Math.sin(pos.angle + Math.PI/2) * 2
                    );
                    leftWall.rotation.y = pos.angle;
                    leftWall.userData.color = color.getHex();
                    this.scene.add(leftWall);
                    this.walls.push(leftWall);

                    // Right wall
                    const rightWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
                    rightWall.position.set(
                        pos.x + Math.cos(pos.angle - Math.PI/2) * 2,
                        wallHeight / 2,
                        pos.z + Math.sin(pos.angle - Math.PI/2) * 2
                    );
                    rightWall.rotation.y = pos.angle;
                    rightWall.userData.color = color.getHex();
                    this.scene.add(rightWall);
                    this.walls.push(rightWall);
                });
            }

            createBeacons() {
                // Create glowing beacons at choice points
                const beaconColors = [0xff3366, 0x33ff66, 0x3366ff, 0xffff33, 0xff33ff, 0x33ffff];

                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 + Math.random() * 60;

                    const beaconGroup = new THREE.Group();

                    const color = beaconColors[Math.floor(Math.random() * beaconColors.length)];

                    // Core
                    const coreGeometry = new THREE.OctahedronGeometry(0.5, 0);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8
                    });
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    beaconGroup.add(core);

                    // Glow
                    const glowGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.2
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    beaconGroup.add(glow);

                    // Light
                    const light = new THREE.PointLight(color, 0.5, 15);
                    beaconGroup.add(light);

                    beaconGroup.position.set(
                        Math.cos(angle) * distance,
                        2 + Math.random() * 2,
                        Math.sin(angle) * distance
                    );

                    beaconGroup.userData = {
                        color: color,
                        baseY: beaconGroup.position.y,
                        phase: Math.random() * Math.PI * 2
                    };

                    this.scene.add(beaconGroup);
                    this.beacons.push(beaconGroup);
                }
            }

            createFloatingData() {
                // Floating "data" particles that represent the algorithm watching
                const particleCount = 500;
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];

                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 80;
                    const height = Math.random() * 20;

                    positions.push(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );

                    const color = new THREE.Color();
                    color.setHSL(0.95 + Math.random() * 0.1, 0.8, 0.5);
                    colors.push(color.r, color.g, color.b);
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });

                this.dataParticles = new THREE.Points(geometry, material);
                this.scene.add(this.dataParticles);
            }

            createBoundary() {
                // Invisible boundary walls that will close in
                const segments = 32;

                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;

                    const wallGeometry = new THREE.BoxGeometry(15, 30, 1);
                    const wallMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a0011,
                        transparent: true,
                        opacity: 0.3,
                        emissive: 0xff3366,
                        emissiveIntensity: 0.1
                    });

                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(
                        Math.cos(angle) * this.worldRadius,
                        15,
                        Math.sin(angle) * this.worldRadius
                    );
                    wall.rotation.y = angle + Math.PI / 2;
                    wall.userData.baseAngle = angle;

                    this.scene.add(wall);
                    this.boundaryWalls.push(wall);
                }
            }

            updateBoundary() {
                // Shrink world based on echo chamber level
                const chamberLevel = this.algorithm.chamberLevel;
                const shrinkFactor = 1 - (chamberLevel / 100) * 0.7; // Max shrink to 30% of original
                this.worldRadius = this.initialWorldRadius * shrinkFactor;

                // Update wall positions
                this.boundaryWalls.forEach(wall => {
                    const angle = wall.userData.baseAngle;
                    wall.position.set(
                        Math.cos(angle) * this.worldRadius,
                        15,
                        Math.sin(angle) * this.worldRadius
                    );

                    // Increase visibility as walls close in
                    wall.material.opacity = 0.3 + (chamberLevel / 100) * 0.5;
                    wall.material.emissiveIntensity = 0.1 + (chamberLevel / 100) * 0.4;
                });

                // Update radius display
                document.getElementById('stat-radius').textContent = Math.round(this.worldRadius) + 'm';

                // Check if player is trapped
                if (chamberLevel >= 95 && !this.isTrapped) {
                    this.triggerTrapped();
                }
            }

            updateGuideLights() {
                // Move guide lights to influence player toward their preferences
                const patterns = this.algorithm.patterns;

                this.guideLights.forEach((light, index) => {
                    // Slowly move lights in the direction the player prefers
                    if (patterns.preferredDirection !== undefined) {
                        const preferredAngle = (patterns.preferredDirection / 8) * Math.PI * 2 - Math.PI;
                        const targetX = this.camera.position.x + Math.cos(preferredAngle) * 20;
                        const targetZ = this.camera.position.z + Math.sin(preferredAngle) * 20;

                        light.position.x += (targetX - light.position.x) * 0.01;
                        light.position.z += (targetZ - light.position.z) * 0.01;
                    }

                    // Change color to preferred color
                    if (patterns.preferredColor) {
                        light.color.setHex(patterns.preferredColor);
                    }
                });
            }

            triggerGlitch() {
                const overlay = document.getElementById('glitch-overlay');
                overlay.classList.add('active');
                setTimeout(() => overlay.classList.remove('active'), 300);
            }

            triggerTrapped() {
                this.isTrapped = true;

                const stats = this.algorithm.getStats();
                document.getElementById('trapped-stats').innerHTML = `
                    Data points collected: ${stats.dataPoints}<br>
                    Patterns identified: ${stats.patterns}<br>
                    Final prediction accuracy: ${stats.accuracy}%
                `;

                document.getElementById('trapped-overlay').classList.add('visible');
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
            }

            setupDesktopControls() {
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys) this.keys[key] = true;
                });

                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys) this.keys[key] = false;
                });

                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        // Track turn direction for algorithm
                        if (e.movementX < -5) {
                            this.algorithm.recordTurn('left');
                        } else if (e.movementX > 5) {
                            this.algorithm.recordTurn('right');
                        }

                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }

            setupMobileControls() {
                const lookArea = document.getElementById('look-area');

                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.lookTouch = {
                        id: touch.identifier,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                }, { passive: true });

                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;
                    for (let touch of e.touches) {
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;

                            // Track turns
                            if (deltaX < -10) this.algorithm.recordTurn('left');
                            else if (deltaX > 10) this.algorithm.recordTurn('right');

                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;
                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });

                lookArea.addEventListener('touchend', (e) => {
                    for (let touch of e.changedTouches) {
                        if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                }, { passive: true });

                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.joystickTouch = { id: e.touches[0].identifier };
                    this.updateJoystick(e.touches[0], joystick, handle);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive) return;
                    e.preventDefault();
                    for (let touch of e.touches) {
                        if (touch.identifier === this.joystickTouch.id) {
                            this.updateJoystick(touch, joystick, handle);
                            break;
                        }
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    for (let touch of e.changedTouches) {
                        if (this.joystickTouch && touch.identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickTouch = null;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';
                            break;
                        }
                    }
                }, { passive: false });
            }

            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 20;
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }

            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                const wasMoving = this.velocity.length() > 0.01;

                if (this.isMobile) {
                    if (this.joystickActive) {
                        this.velocity.add(forward.clone().multiplyScalar(this.joystickVector.y * 0.01));
                        this.velocity.add(right.clone().multiplyScalar(this.joystickVector.x * 0.01));
                    }
                } else {
                    if (this.keys.w) this.velocity.add(forward.clone().multiplyScalar(0.01));
                    if (this.keys.s) this.velocity.add(forward.clone().multiplyScalar(-0.01));
                    if (this.keys.a) this.velocity.add(right.clone().multiplyScalar(-0.01));
                    if (this.keys.d) this.velocity.add(right.clone().multiplyScalar(0.01));
                }

                this.velocity.multiplyScalar(0.92);
                this.velocity.clampLength(0, this.moveSpeed);

                // Check boundary
                const nextPos = this.camera.position.clone().add(this.velocity);
                const distFromCenter = Math.sqrt(nextPos.x * nextPos.x + nextPos.z * nextPos.z);

                if (distFromCenter < this.worldRadius - 2) {
                    this.camera.position.add(this.velocity);
                } else {
                    // Bounce back
                    this.velocity.multiplyScalar(-0.5);
                    this.triggerGlitch();

                    // Show warning
                    const warning = document.getElementById('echo-warning');
                    warning.textContent = 'YOU CANNOT LEAVE YOUR PREFERENCES';
                    warning.classList.add('visible');
                    setTimeout(() => warning.classList.remove('visible'), 2000);
                }

                this.camera.position.y = 2;

                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;

                // Record data for algorithm
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                const speed = this.velocity.length();

                this.algorithm.recordPosition(this.camera.position, direction, speed);

                // Find nearest beacon color
                let nearestColor = null;
                let nearestDist = Infinity;
                this.beacons.forEach(beacon => {
                    const dist = this.camera.position.distanceTo(beacon.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestColor = beacon.userData.color;
                    }
                });

                if (nearestDist < 10) {
                    this.algorithm.recordColorInteraction(nearestColor);
                }

                // Validate predictions periodically
                if (Math.random() < 0.02) {
                    this.algorithm.validatePrediction({
                        direction: direction,
                        turn: this.lastTurn,
                        nearestColor: nearestColor
                    });
                }
            }

            updateUI() {
                const stats = this.algorithm.getStats();

                document.getElementById('stat-datapoints').textContent = stats.dataPoints;
                document.getElementById('stat-patterns').textContent = stats.patterns;

                const accuracyEl = document.getElementById('stat-accuracy');
                accuracyEl.textContent = stats.accuracy + '%';
                accuracyEl.className = 'stat-value' + (stats.accuracy > 70 ? ' danger' : stats.accuracy > 40 ? ' warning' : '');

                const chamberEl = document.getElementById('stat-chamber');
                chamberEl.textContent = stats.chamberLevel + '%';
                chamberEl.className = 'stat-value' + (stats.chamberLevel > 70 ? ' danger' : stats.chamberLevel > 40 ? ' warning' : '');

                document.getElementById('confidence-fill').style.width = stats.chamberLevel + '%';
                document.getElementById('prediction-text').textContent = stats.prediction;

                // Periodic warning
                if (stats.chamberLevel > 30 && Date.now() - this.lastWarningTime > 15000) {
                    const warnings = [
                        'THE WALLS ARE LEARNING YOUR PREFERENCES',
                        'YOUR CHOICES ARE MAKING THE WORLD SMALLER',
                        'THE ALGORITHM KNOWS WHAT YOU WANT',
                        'YOU ARE TRAINING YOUR OWN CAGE',
                        'PREDICTION ACCURACY INCREASING',
                        'ECHO CHAMBER FORMING'
                    ];
                    const warning = document.getElementById('echo-warning');
                    warning.textContent = warnings[Math.floor(Math.random() * warnings.length)];
                    warning.classList.add('visible');
                    setTimeout(() => warning.classList.remove('visible'), 3000);
                    this.lastWarningTime = Date.now();
                    this.triggerGlitch();
                }
            }

            animate() {
                if (this.isTrapped) return;

                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                this.updateMovement();
                this.updateBoundary();
                this.updateGuideLights();

                // Make prediction
                if (Math.random() < 0.05) {
                    this.algorithm.makePrediction();
                }

                // Update UI every 30 frames
                if (Math.floor(time * 60) % 30 === 0) {
                    this.updateUI();
                }

                // Animate beacons
                this.beacons.forEach(beacon => {
                    beacon.position.y = beacon.userData.baseY + Math.sin(time * 2 + beacon.userData.phase) * 0.5;
                    beacon.rotation.y += 0.02;
                });

                // Animate data particles - spiral toward player as accuracy increases
                if (this.dataParticles) {
                    const positions = this.dataParticles.geometry.attributes.position.array;
                    const accuracy = this.algorithm.accuracy / 100;

                    for (let i = 0; i < positions.length; i += 3) {
                        // Spiral motion
                        const x = positions[i];
                        const z = positions[i + 2];
                        const angle = Math.atan2(z, x) + 0.005;
                        const radius = Math.sqrt(x * x + z * z);

                        // Pull toward player based on accuracy
                        const targetRadius = radius - accuracy * 0.1;
                        const newRadius = Math.max(5, targetRadius);

                        positions[i] = Math.cos(angle) * newRadius;
                        positions[i + 2] = Math.sin(angle) * newRadius;
                        positions[i + 1] += Math.sin(time + i) * 0.01;
                    }
                    this.dataParticles.geometry.attributes.position.needsUpdate = true;
                }

                // Fog increases with chamber level
                this.scene.fog.density = 0.015 + (this.algorithm.chamberLevel / 100) * 0.03;

                this.renderer.render(this.scene, this.camera);
            }
        }

        function resetWorld() {
            location.reload();
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            const world = new RecommendationEngineWorld();
            world.init();
        });
    </script>
</body>
</html>
