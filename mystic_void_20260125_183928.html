<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Mystic Void</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .world-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            pointer-events: none;
        }

        .world-title {
            font-size: 2.5em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #9d4edd, #c77dff, #e0aaff);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .world-description {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.5);
            max-width: 400px;
            margin-top: 10px;
        }

        .portal-return {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
            z-index: 1000;
            cursor: pointer;
            border: 1px solid #9d4edd44;
            transition: all 0.3s;
        }

        .portal-return:hover {
            background: #9d4edd33;
            border-color: #9d4edd;
        }

        .stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.3);
            text-align: right;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div class="world-ui">
        <div class="world-title">Mystic Void</div>
        <div class="world-description">Quantum Particle Fields • Royal Purple Mystical</div>
    </div>

    <div class="portal-return" onclick="window.history.back()">← Return to Nexus</div>

    <div class="stats">
        <div id="fps">0 FPS</div>
        <div>Generated by AI • 20260125_183928</div>
    </div>

    <div id="loading">Materializing world...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const CONFIG = {
            primaryColor: 0x9d4edd,
            secondaryColor: 0xc77dff,
            accentColor: 0xe0aaff,
            backgroundColor: 0x10002b,
            fogColor: 0x0a0015,
            ambientColor: 0x240046,
            groundColor: 0x0a0020,
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            cameraHeight: 2
        };

        class World {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();
                this.objects = [];

                this.keys = { w: false, a: false, s: false, d: false };
                this.rotation = { x: 0, y: 0 };
                this.isPointerLocked = false;

                this.frameCount = 0;
                this.lastFpsUpdate = 0;
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.createEnvironment();
                this.createWorldElements();
                this.setupControls();

                document.getElementById('loading').style.display = 'none';
                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.backgroundColor);
                this.scene.fog = new THREE.Fog(CONFIG.fogColor, 5, 80);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, CONFIG.cameraHeight, 10);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                document.getElementById('container').appendChild(this.renderer.domElement);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupLighting() {
                const ambient = new THREE.AmbientLight(CONFIG.ambientColor, 0.4);
                this.scene.add(ambient);

                const mainLight = new THREE.PointLight(CONFIG.primaryColor, 1, 50);
                mainLight.position.set(10, 15, 10);
                mainLight.castShadow = true;
                this.scene.add(mainLight);

                const accentLight = new THREE.PointLight(CONFIG.secondaryColor, 0.8, 40);
                accentLight.position.set(-15, 10, -10);
                this.scene.add(accentLight);

                const fillLight = new THREE.PointLight(CONFIG.accentColor, 0.5, 30);
                fillLight.position.set(0, 5, -20);
                this.scene.add(fillLight);
            }

            createEnvironment() {
                // Ground plane
                const groundGeo = new THREE.PlaneGeometry(200, 200, 100, 100);
                const vertices = groundGeo.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.sin(vertices[i] * 0.05) * Math.cos(vertices[i + 1] * 0.05) * 2;
                }
                groundGeo.computeVertexNormals();

                const groundMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.groundColor,
                    roughness: 0.85,
                    metalness: 0.15
                });

                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Particle field
                const particleCount = 2000;
                const particleGeo = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i + 1] = Math.random() * 40;
                    positions[i + 2] = (Math.random() - 0.5) * 100;

                    const c = new THREE.Color(
                        Math.random() > 0.5 ? CONFIG.primaryColor : CONFIG.secondaryColor
                    );
                    colors[i] = c.r;
                    colors[i + 1] = c.g;
                    colors[i + 2] = c.b;
                }

                particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMat = new THREE.PointsMaterial({
                    size: 0.15,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7
                });

                this.particles = new THREE.Points(particleGeo, particleMat);
                this.scene.add(this.particles);
            }

            createWorldElements() {
                
                // Crystalline structures
                const crystalColors = [CONFIG.primaryColor, CONFIG.secondaryColor, CONFIG.accentColor];
                for (let i = 0; i < 15; i++) {
                    const geo = new THREE.OctahedronGeometry(Math.random() * 2 + 0.5);
                    const mat = new THREE.MeshPhysicalMaterial({
                        color: crystalColors[i % 3],
                        emissive: crystalColors[i % 3],
                        emissiveIntensity: 0.3,
                        metalness: 0.2,
                        roughness: 0.1,
                        transparent: true,
                        opacity: 0.8,
                        clearcoat: 1
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(
                        (Math.random() - 0.5) * 60,
                        Math.random() * 8 + 2,
                        (Math.random() - 0.5) * 60
                    );
                    mesh.userData.baseY = mesh.position.y;
                    mesh.userData.animate = true;
                    this.objects.push(mesh);
                    this.scene.add(mesh);
                }
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) this.keys[e.key.toLowerCase()] = true;
                });

                document.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) this.keys[e.key.toLowerCase()] = false;
                });

                document.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * CONFIG.lookSpeed;
                        this.rotation.x -= e.movementY * CONFIG.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rotation.x));
                    }
                });
            }

            updateMovement() {
                const direction = new THREE.Vector3();

                if (this.keys.w) direction.z -= 1;
                if (this.keys.s) direction.z += 1;
                if (this.keys.a) direction.x -= 1;
                if (this.keys.d) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize().multiplyScalar(CONFIG.moveSpeed);
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation.y);
                    this.camera.position.add(direction);
                }

                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                this.updateMovement();

                // Animate particles
                if (this.particles) {
                    this.particles.rotation.y = time * 0.02;
                }

                // Animate world objects
                this.objects.forEach((obj, i) => {
                    if (obj.userData.animate) {
                        obj.position.y = obj.userData.baseY + Math.sin(time * 2 + i) * 0.5;
                        obj.rotation.y = time * 0.5 + i;
                    }
                });

                this.renderer.render(this.scene, this.camera);

                // FPS counter
                this.frameCount++;
                if (time - this.lastFpsUpdate > 1) {
                    document.getElementById('fps').textContent = this.frameCount + ' FPS';
                    this.frameCount = 0;
                    this.lastFpsUpdate = time;
                }
            }
        }

        const world = new World();
        world.init();
    </script>
</body>
</html>