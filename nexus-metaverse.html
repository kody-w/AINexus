<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Metaverse - AI-Human Collaborative Space</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0f;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* Top Bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(10, 10, 20, 0.95);
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1.1em;
        }

        .logo-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .mode-pill {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-pill.active {
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
        }

        .mode-pill:not(.active) {
            background: rgba(255,255,255,0.1);
        }

        .mode-pill:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }

        /* Entity List Panel */
        .entity-panel {
            position: fixed;
            left: 0;
            top: 50px;
            width: 280px;
            height: calc(100% - 50px);
            background: rgba(10, 10, 20, 0.95);
            border-right: 1px solid rgba(100, 200, 255, 0.2);
            z-index: 90;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .entity-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .entity-card {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .entity-card:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(100, 200, 255, 0.3);
        }

        .entity-card.selected {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .entity-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .entity-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }

        .entity-avatar.human { background: linear-gradient(135deg, #00d4ff, #0088ff); }
        .entity-avatar.ai { background: linear-gradient(135deg, #7b2fff, #ff2f8b); }
        .entity-avatar.twin { background: linear-gradient(135deg, #00ff88, #00d4ff); }

        .entity-name {
            font-weight: 500;
            flex: 1;
        }

        .entity-type {
            font-size: 0.75em;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
        }

        .entity-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
            color: rgba(255,255,255,0.7);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.working { background: #00ff88; animation: pulse 1.5s infinite; }
        .status-dot.thinking { background: #ffaa00; animation: pulse 0.8s infinite; }
        .status-dot.idle { background: #666; }
        .status-dot.controlled { background: #00d4ff; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .entity-task {
            font-size: 0.8em;
            color: rgba(255,255,255,0.5);
            margin-top: 4px;
            font-style: italic;
        }

        /* Over-the-Shoulder Panel */
        .observation-panel {
            position: fixed;
            right: 0;
            top: 50px;
            width: 350px;
            height: calc(100% - 50px);
            background: rgba(10, 10, 20, 0.95);
            border-left: 1px solid rgba(100, 200, 255, 0.2);
            z-index: 90;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .observation-panel.visible { display: flex; }

        .obs-viewport {
            height: 200px;
            background: #000;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .obs-viewport-label {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 0.75em;
            padding: 4px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
        }

        .obs-entity-info {
            padding: 15px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .obs-entity-name {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .obs-control-mode {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .control-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .control-btn.observe {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        .control-btn.guide {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }

        .control-btn.takeover {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .control-btn.active {
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-1px);
        }

        .obs-activity-log {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .activity-item {
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            font-size: 0.85em;
            border-left: 3px solid #444;
        }

        .activity-item.action { border-left-color: #00d4ff; }
        .activity-item.thought { border-left-color: #7b2fff; }
        .activity-item.output { border-left-color: #00ff88; }

        .activity-time {
            font-size: 0.75em;
            color: rgba(255,255,255,0.4);
            margin-bottom: 3px;
        }

        /* World Builder Panel */
        .builder-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            z-index: 95;
            display: none;
            backdrop-filter: blur(10px);
        }

        .builder-panel.visible { display: block; }

        .builder-toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .builder-tool {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            transition: all 0.2s;
        }

        .builder-tool:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .builder-tool.selected {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .object-palette {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-width: 400px;
        }

        .palette-item {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            transition: all 0.2s;
        }

        .palette-item:hover {
            background: rgba(255,255,255,0.1);
            transform: scale(1.05);
        }

        .palette-item span {
            font-size: 0.5em;
            margin-top: 4px;
            color: rgba(255,255,255,0.6);
        }

        /* Chat Panel */
        .chat-panel {
            position: fixed;
            bottom: 20px;
            right: 370px;
            width: 350px;
            height: 300px;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 12px;
            z-index: 90;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        .chat-message.ai {
            background: rgba(123, 47, 255, 0.1);
            border-left: 3px solid #7b2fff;
        }

        .chat-message.human {
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid #00d4ff;
        }

        .chat-sender {
            font-size: 0.8em;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .chat-input-area {
            padding: 10px;
            border-top: 1px solid rgba(100, 200, 255, 0.1);
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 6px;
            padding: 10px;
            color: #fff;
            font-size: 0.9em;
        }

        .chat-input::placeholder { color: rgba(255,255,255,0.4); }

        .chat-send {
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
            border: none;
            border-radius: 6px;
            padding: 10px 15px;
            color: #fff;
            cursor: pointer;
            font-weight: 500;
        }

        /* Connection Status */
        .connection-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: rgba(10, 10, 20, 0.95);
            border-top: 1px solid rgba(100, 200, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-size: 0.8em;
            color: rgba(255,255,255,0.6);
            z-index: 85;
        }

        .conn-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .conn-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
        }

        /* Controls Help */
        .controls-help {
            position: fixed;
            bottom: 40px;
            left: 300px;
            background: rgba(10, 10, 20, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em;
            color: rgba(255,255,255,0.6);
            border: 1px solid rgba(100, 200, 255, 0.1);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0f;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(100, 200, 255, 0.2);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Minimap */
        .minimap {
            position: fixed;
            top: 60px;
            right: 10px;
            width: 150px;
            height: 150px;
            background: rgba(10, 10, 20, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 8px;
            z-index: 80;
        }

        .minimap canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        /* Performance Stats */
        .perf-stats {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(10, 10, 20, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 0.75em;
            font-family: 'Courier New', monospace;
            z-index: 80;
            min-width: 150px;
        }

        .perf-stats-title {
            color: #00d4ff;
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.85em;
        }

        .perf-stat-line {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            color: rgba(255,255,255,0.7);
        }

        .perf-stat-value {
            color: #00ff88;
            font-weight: 500;
        }

        .perf-stat-value.warning {
            color: #ffaa00;
        }

        .perf-stat-value.critical {
            color: #ff4444;
        }

        /* Add Entity Button */
        .add-entity-btn {
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
        }

        /* Modal for adding entities */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.visible { display: flex; }

        /* 3D World-Space Dialog Action Menu - Pinned to Entity */
        .world-action-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 250;
            display: none;
        }

        .world-action-menu.visible {
            display: block;
        }

        /* Dialog container that follows entity */
        .world-action-dialog {
            position: absolute;
            background: rgba(5, 15, 30, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 8px;
            padding: 0;
            min-width: 160px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3), 0 4px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            transform: translateX(-50%);
            pointer-events: auto;
        }

        .world-action-dialog-header {
            background: linear-gradient(135deg, rgba(0, 120, 200, 0.9), rgba(0, 80, 160, 0.9));
            padding: 10px 16px;
            font-weight: 600;
            font-size: 1em;
            border-bottom: 1px solid rgba(100, 200, 255, 0.4);
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .world-action-option {
            padding: 10px 16px;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(100, 200, 255, 0.15);
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.08s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
            position: relative;
        }

        .world-action-option:last-child {
            border-bottom: none;
        }

        .world-action-option .icon {
            font-size: 1.1em;
            width: 24px;
            text-align: center;
        }

        .world-action-option .label {
            font-weight: 500;
            font-size: 0.95em;
        }

        .world-action-option.gazed {
            background: rgba(0, 150, 255, 0.6);
            box-shadow: inset 0 0 20px rgba(0, 200, 255, 0.3);
        }

        .world-action-option.gazed .label {
            color: #fff;
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
        }

        .world-action-option.gazed::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #00d4ff;
            box-shadow: 0 0 10px #00d4ff;
        }

        /* Subtle crosshair - small dot */
        .gaze-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            pointer-events: none;
            z-index: 260;
            display: none;
        }

        .gaze-crosshair.visible {
            display: block;
        }

        .gaze-crosshair .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: rgba(0, 212, 255, 0.7);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px #00d4ff, 0 0 15px rgba(0, 212, 255, 0.5);
        }

        /* Instruction hint */
        .world-action-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            font-size: 0.85em;
            opacity: 0.8;
            pointer-events: none;
        }

        .modal {
            background: rgba(20, 20, 35, 0.98);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            padding: 25px;
            width: 400px;
            max-width: 90%;
        }

        .modal-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .modal-field {
            margin-bottom: 15px;
        }

        .modal-field label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.9em;
            color: rgba(255,255,255,0.7);
        }

        .modal-field input,
        .modal-field select {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.95em;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
            color: #fff;
        }

        .modal-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        /* Hide panels when not needed */
        .entity-panel.hidden,
        .observation-panel.hidden,
        .chat-panel.hidden {
            display: none !important;
        }

        /* Reality Portal - Webcam Portal */
        .reality-mirror {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 320px;
            background: rgba(10, 10, 20, 0.95);
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            overflow: hidden;
            z-index: 95;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        .reality-mirror.hidden {
            display: none;
        }

        .reality-mirror.minimized {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            bottom: 20px;
            cursor: pointer;
        }

        .reality-mirror.minimized .mirror-content,
        .reality-mirror.minimized .mirror-header {
            display: none;
        }

        .reality-mirror.minimized .mirror-minimized-icon {
            display: flex;
        }

        .mirror-minimized-icon {
            display: none;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            background: linear-gradient(135deg, #00d4ff20, #7b2fff20);
        }

        .mirror-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 15px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(123, 47, 255, 0.1));
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
        }

        .mirror-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .mirror-title-icon {
            font-size: 1.2em;
        }

        .mirror-controls {
            display: flex;
            gap: 8px;
        }

        .mirror-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .mirror-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .mirror-btn.active {
            background: rgba(0, 212, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .mirror-content {
            position: relative;
        }

        .mirror-video-container {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            background: #000;
            overflow: hidden;
        }

        #reality-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        .mirror-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .mirror-scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.5), transparent);
            animation: scanLine 3s ease-in-out infinite;
        }

        @keyframes scanLine {
            0%, 100% { top: 0; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        .mirror-corners {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .mirror-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: rgba(0, 212, 255, 0.6);
            border-style: solid;
            border-width: 0;
        }

        .mirror-corner.tl { top: 8px; left: 8px; border-top-width: 2px; border-left-width: 2px; }
        .mirror-corner.tr { top: 8px; right: 8px; border-top-width: 2px; border-right-width: 2px; }
        .mirror-corner.bl { bottom: 8px; left: 8px; border-bottom-width: 2px; border-left-width: 2px; }
        .mirror-corner.br { bottom: 8px; right: 8px; border-bottom-width: 2px; border-right-width: 2px; }

        /* Gesture Recognition Overlay */
        #gesture-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1); /* Mirror to match video */
        }

        .gesture-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.5);
            border-radius: 20px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .gesture-indicator.active {
            opacity: 1;
        }

        .gesture-icon {
            font-size: 1.5em;
            animation: gestureGlow 1s ease-in-out infinite;
        }

        .gesture-name {
            font-size: 0.9em;
            font-weight: 600;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @keyframes gestureGlow {
            0%, 100% { filter: drop-shadow(0 0 5px rgba(0, 212, 255, 0.5)); }
            50% { filter: drop-shadow(0 0 15px rgba(0, 212, 255, 0.8)); }
        }

        /* Gesture action feedback */
        .gesture-action-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00d4ff;
            border-radius: 16px;
            padding: 20px 40px;
            z-index: 9999;
            text-align: center;
            animation: gestureFeedback 1.5s ease-out forwards;
            pointer-events: none;
        }

        .gesture-action-feedback .icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .gesture-action-feedback .action {
            font-size: 1.2em;
            color: #00d4ff;
            font-weight: bold;
        }

        @keyframes gestureFeedback {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            30% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }

        /* Virtual Pinch Cursor */
        .pinch-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 99999;
            transform: translate(-50%, -50%);
            transition: opacity 0.2s ease;
            opacity: 0;
        }

        .pinch-cursor.visible {
            opacity: 1;
        }

        .pinch-cursor-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(0, 212, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5),
                        inset 0 0 10px rgba(0, 212, 255, 0.2);
            transition: all 0.15s ease;
        }

        .pinch-cursor.pinching .pinch-cursor-ring {
            transform: scale(0.6);
            border-color: #00ff88;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.8),
                        inset 0 0 15px rgba(0, 255, 136, 0.4);
        }

        .pinch-cursor.hovering .pinch-cursor-ring {
            border-color: #ff00d4;
            box-shadow: 0 0 20px rgba(255, 0, 212, 0.6);
        }

        .pinch-cursor-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: #00d4ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s ease;
        }

        .pinch-cursor.pinching .pinch-cursor-dot {
            width: 16px;
            height: 16px;
            background: #00ff88;
        }

        .pinch-cursor-progress {
            position: absolute;
            top: -3px;
            left: -3px;
            width: calc(100% + 6px);
            height: calc(100% + 6px);
            border-radius: 50%;
            background: conic-gradient(
                rgba(0, 255, 136, 0.8) calc(var(--progress) * 100%),
                transparent calc(var(--progress) * 100%)
            );
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .pinch-cursor.pinch-progress .pinch-cursor-progress {
            opacity: 1;
        }

        /* Cursor trail */
        .pinch-cursor-trail {
            position: fixed;
            pointer-events: none;
            z-index: 99998;
        }

        .trail-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 212, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Click ripple effect */
        .pinch-click-ripple {
            position: fixed;
            width: 60px;
            height: 60px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 99997;
            animation: pinchRipple 0.6s ease-out forwards;
        }

        @keyframes pinchRipple {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }

        /* Cursor mode indicator */
        .cursor-mode-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 212, 255, 0.5);
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.7em;
            color: #00d4ff;
            z-index: 11;
            display: none;
        }

        .cursor-mode-indicator.active {
            display: block;
        }

        /* Highlight clickable elements when cursor hovers */
        .pinch-hoverable {
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }

        .pinch-hoverable.pinch-hovered {
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.6) !important;
            transform: scale(1.02);
        }

        .mirror-status {
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .mirror-status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mirror-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .mirror-status-dot.active {
            background: #00ff88;
            animation: pulse 1.5s infinite;
        }

        .mirror-status-dot.watching {
            background: #00d4ff;
            animation: pulse 0.8s infinite;
        }

        .ai-gaze-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            color: rgba(255,255,255,0.6);
        }

        .ai-gaze-indicator.active {
            color: #00d4ff;
        }

        .ai-gaze-indicator .eye {
            font-size: 1em;
        }

        .mirror-perception {
            padding: 10px 15px;
            font-size: 0.8em;
            color: rgba(255,255,255,0.7);
            border-top: 1px solid rgba(100, 200, 255, 0.1);
            max-height: 80px;
            overflow-y: auto;
        }

        .perception-label {
            color: rgba(0, 212, 255, 0.8);
            font-weight: 500;
            margin-bottom: 4px;
        }

        .mirror-offline {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: rgba(255,255,255,0.5);
        }

        .mirror-offline-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .mirror-enable-btn {
            margin-top: 10px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .mirror-enable-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
        }

        /* Reality Portal Toggle Button (when hidden) */
        .reality-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #7b2fff);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            z-index: 94;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .reality-toggle:hover {
            transform: scale(1.1);
        }

        .reality-toggle.hidden {
            display: none;
        }

        /* CYCLE 2: Knowledge Timeline Panel */
        .knowledge-panel {
            position: fixed;
            bottom: 340px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: rgba(10, 10, 20, 0.95);
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            overflow: hidden;
            z-index: 95;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(123, 47, 255, 0.2);
        }

        .knowledge-panel.hidden {
            display: none;
        }

        .knowledge-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 15px;
            background: linear-gradient(135deg, rgba(123, 47, 255, 0.1), rgba(0, 212, 255, 0.1));
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
        }

        .knowledge-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .knowledge-timeline {
            max-height: 340px;
            overflow-y: auto;
            padding: 10px;
        }

        .timeline-item {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            border-left: 3px solid #7b2fff;
            font-size: 0.8em;
            transition: all 0.2s;
        }

        .timeline-item:hover {
            background: rgba(255,255,255,0.08);
        }

        .timeline-time {
            font-size: 0.75em;
            color: rgba(255,255,255,0.4);
            margin-bottom: 4px;
        }

        .timeline-entity {
            font-weight: 600;
            color: #00d4ff;
            margin-bottom: 4px;
        }

        .timeline-content {
            color: rgba(255,255,255,0.9);
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .timeline-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(123, 47, 255, 0.2);
            color: #7b2fff;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .knowledge-toggle {
            position: fixed;
            bottom: 340px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #7b2fff, #00d4ff);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            z-index: 94;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(123, 47, 255, 0.3);
        }

        .knowledge-toggle:hover {
            transform: scale(1.1);
        }

        .knowledge-toggle.hidden {
            display: none;
        }

        /* Emotion indicator tooltip */
        .emotion-indicator {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div>Initializing Nexus Metaverse...</div>
    </div>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="logo">
            <div class="logo-icon">N</div>
            Nexus Metaverse
        </div>
        <div class="mode-indicator">
            <div class="mode-pill active" data-mode="explore">Explore</div>
            <div class="mode-pill" data-mode="observe">Observe</div>
            <div class="mode-pill" data-mode="build">Build</div>
        </div>
        <div style="display: flex; align-items: center; gap: 15px;">
            <span id="room-id" style="font-size: 0.85em; color: rgba(255,255,255,0.5);">Room: ---</span>
            <button class="add-entity-btn" onclick="nexus.showAddEntityModal()">+ Add Entity</button>
        </div>
    </div>

    <!-- Entity List Panel -->
    <div class="entity-panel" id="entity-panel">
        <div class="panel-header">
            <span>Entities</span>
            <span id="entity-count">0</span>
        </div>
        <div class="entity-list" id="entity-list">
            <!-- Entities populated dynamically -->
        </div>
    </div>

    <!-- Over-the-Shoulder Observation Panel -->
    <div class="observation-panel" id="observation-panel">
        <div class="obs-viewport" id="obs-viewport">
            <div class="obs-viewport-label">Entity Portal</div>
            <canvas id="obs-canvas" width="350" height="200"></canvas>
        </div>
        <div class="obs-entity-info">
            <div class="obs-entity-name" id="obs-entity-name">Select an entity</div>
            <div class="entity-status">
                <div class="status-dot" id="obs-status-dot"></div>
                <span id="obs-status-text">No entity selected</span>
            </div>
            <div class="obs-control-mode">
                <button class="control-btn observe active" onclick="nexus.setControlMode('observe')">Watch</button>
                <button class="control-btn guide" onclick="nexus.setControlMode('guide')">Guide</button>
                <button class="control-btn takeover" onclick="nexus.setControlMode('takeover')">Take Over</button>
            </div>
        </div>
        <div class="panel-header" style="border-bottom: 1px solid rgba(100, 200, 255, 0.1);">
            Activity Log
        </div>
        <div class="obs-activity-log" id="activity-log">
            <!-- Activity items populated dynamically -->
        </div>
    </div>

    <!-- Reality Portal - Webcam Portal for AI to See Physical World -->
    <div class="reality-mirror" id="reality-mirror">
        <div class="mirror-minimized-icon" onclick="nexus.toggleRealityMirror()">
            <span>üëÅÔ∏è</span>
        </div>
        <div class="mirror-header">
            <div class="mirror-title">
                <span class="mirror-title-icon">ü™û</span>
                Reality Portal
            </div>
            <div class="mirror-controls">
                <button class="mirror-btn" id="mirror-cursor-toggle" onclick="nexus.togglePinchCursor()" title="Toggle Pinch Cursor">
                    üéØ
                </button>
                <button class="mirror-btn" id="mirror-gesture-toggle" onclick="nexus.toggleGestureRecognition()" title="Toggle Gesture Recognition">
                    ü§ö
                </button>
                <button class="mirror-btn" id="mirror-ai-gaze" onclick="nexus.toggleAIGaze()" title="Toggle AI Perception">
                    üëÅÔ∏è
                </button>
                <button class="mirror-btn" id="mirror-minimize" onclick="nexus.minimizeRealityMirror()" title="Minimize">
                    ‚àí
                </button>
                <button class="mirror-btn" id="mirror-close" onclick="nexus.hideRealityMirror()" title="Close">
                    √ó
                </button>
            </div>
        </div>
        <div class="mirror-content">
            <div class="mirror-video-container">
                <video id="reality-video" autoplay playsinline muted></video>
                <canvas id="reality-canvas" style="display: none;"></canvas>
                <canvas id="gesture-canvas"></canvas>
                <div class="mirror-overlay">
                    <div class="mirror-scan-line"></div>
                    <div class="mirror-corners">
                        <div class="mirror-corner tl"></div>
                        <div class="mirror-corner tr"></div>
                        <div class="mirror-corner bl"></div>
                        <div class="mirror-corner br"></div>
                    </div>
                </div>
                <!-- Gesture indicator -->
                <div class="gesture-indicator" id="gesture-indicator">
                    <div class="gesture-icon" id="gesture-icon">‚úã</div>
                    <div class="gesture-name" id="gesture-name">No gesture</div>
                </div>
                <!-- Cursor mode indicator -->
                <div class="cursor-mode-indicator" id="cursor-mode-indicator">
                    üéØ Pinch Cursor Active
                </div>
                <div class="mirror-offline" id="mirror-offline">
                    <div class="mirror-offline-icon">üì∑</div>
                    <div>Camera offline</div>
                    <button class="mirror-enable-btn" onclick="nexus.enableRealityMirror()">
                        Enable Camera
                    </button>
                </div>
            </div>
            <div class="mirror-status">
                <div class="mirror-status-indicator">
                    <div class="mirror-status-dot" id="mirror-status-dot"></div>
                    <span id="mirror-status-text">Camera offline</span>
                </div>
                <div class="ai-gaze-indicator" id="ai-gaze-indicator">
                    <span class="eye">üëÅÔ∏è</span>
                    <span id="ai-gaze-text">AI not watching</span>
                </div>
            </div>
            <div class="mirror-perception" id="mirror-perception">
                <div class="perception-label">AI Perception:</div>
                <div id="perception-text">Enable camera and AI gaze to allow AI agents to perceive your environment.</div>
            </div>
        </div>
    </div>

    <!-- Reality Portal Toggle (when mirror is hidden) -->
    <button class="reality-toggle hidden" id="reality-toggle" onclick="nexus.showRealityMirror()" title="Open Reality Portal">
        ü™û
    </button>

    <!-- World Builder Panel -->
    <div class="builder-panel" id="builder-panel">
        <div class="builder-toolbar">
            <div class="builder-tool selected" data-tool="select" title="Select">
                <span>üëÜ</span>
            </div>
            <div class="builder-tool" data-tool="move" title="Move">
                <span>‚úã</span>
            </div>
            <div class="builder-tool" data-tool="rotate" title="Rotate">
                <span>üîÑ</span>
            </div>
            <div class="builder-tool" data-tool="delete" title="Delete">
                <span>üóëÔ∏è</span>
            </div>
            <div class="builder-tool" data-tool="save" title="Save World">
                <span>üíæ</span>
            </div>
        </div>
        <div class="object-palette" id="object-palette">
            <div class="palette-item" data-object="cube"><span>Cube</span>üì¶</div>
            <div class="palette-item" data-object="sphere"><span>Sphere</span>üîÆ</div>
            <div class="palette-item" data-object="cylinder"><span>Pillar</span>üèõÔ∏è</div>
            <div class="palette-item" data-object="tree"><span>Tree</span>üå≤</div>
            <div class="palette-item" data-object="light"><span>Light</span>üí°</div>
            <div class="palette-item" data-object="portal"><span>Portal</span>üåÄ</div>
        </div>
    </div>

    <!-- Chat Panel (hidden by default to avoid interfering with movement controls) -->
    <div class="chat-panel hidden" id="chat-panel">
        <div class="panel-header">
            <span>Chat</span>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="chat-message ai">
                <div class="chat-sender">AI Assistant</div>
                <div>Welcome to Nexus Metaverse. I'm here to help with any tasks.</div>
            </div>
        </div>
        <div class="chat-input-area">
            <input type="text" class="chat-input" id="chat-input" placeholder="Type a message or command...">
            <button class="chat-send" onclick="nexus.sendChat()">Send</button>
        </div>
    </div>

    <!-- CYCLE 2: Knowledge Timeline Panel -->
    <div class="knowledge-panel" id="knowledge-panel">
        <div class="knowledge-header">
            <div class="knowledge-title">
                <span>üß†</span>
                <span>Shared Knowledge</span>
            </div>
            <button class="mirror-btn" onclick="nexus.toggleKnowledgePanel()" title="Toggle">‚àí</button>
        </div>
        <div class="knowledge-timeline" id="knowledge-timeline">
            <div class="timeline-item">
                <div class="timeline-time">System</div>
                <div class="timeline-entity">Nexus Metaverse</div>
                <div class="timeline-content">Knowledge base initialized. AI and human discoveries will appear here.</div>
                <div class="timeline-type">system</div>
            </div>
        </div>
    </div>

    <!-- Knowledge Toggle Button (when minimized) -->
    <button class="knowledge-toggle hidden" id="knowledge-toggle" onclick="nexus.toggleKnowledgePanel()" title="Shared Knowledge">
        üß†
    </button>

    <!-- Controls Help -->
    <div class="controls-help">
        <strong>Controls:</strong> WASD to move | Mouse to look | Click to interact | Tab to toggle panels
    </div>

    <!-- Connection Status -->
    <div class="connection-bar">
        <div class="conn-status">
            <div class="conn-dot" id="conn-dot"></div>
            <span id="conn-text">Connecting to Nexus Network...</span>
        </div>
        <div>
            <span id="peer-count">0 peers connected</span> |
            <span id="entity-total">0 entities in world</span>
        </div>
    </div>

    <!-- Minimap -->
    <div class="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>

    <!-- Performance Stats -->
    <div class="perf-stats" id="perf-stats">
        <div class="perf-stats-title">Performance</div>
        <div class="perf-stat-line">
            <span>FPS:</span>
            <span class="perf-stat-value" id="stat-fps">--</span>
        </div>
        <div class="perf-stat-line">
            <span>Entities:</span>
            <span class="perf-stat-value" id="stat-entities">0</span>
        </div>
        <div class="perf-stat-line">
            <span>Objects:</span>
            <span class="perf-stat-value" id="stat-objects">0</span>
        </div>
        <div class="perf-stat-line">
            <span>Render:</span>
            <span class="perf-stat-value" id="stat-render">--</span>
        </div>
    </div>

    <!-- Add Entity Modal -->
    <!-- 3D World-Space Dialog Action Menu - Pinned to Entity -->
    <div class="world-action-menu" id="world-action-menu">
        <div class="world-action-dialog" id="world-action-dialog">
            <div class="world-action-dialog-header" id="world-action-header">Entity Name</div>
            <!-- Options added dynamically as vertical list -->
        </div>
    </div>
    <div class="gaze-crosshair" id="gaze-crosshair">
        <div class="dot"></div>
    </div>
    <div class="world-action-hint" id="world-action-hint" style="display: none;">
        Look to highlight, click to select
    </div>

    <div class="modal-overlay" id="add-entity-modal">
        <div class="modal">
            <div class="modal-title">Add New Entity</div>
            <div class="modal-field">
                <label>Entity Name</label>
                <input type="text" id="entity-name-input" placeholder="Enter entity name...">
            </div>
            <div class="modal-field">
                <label>Entity Type</label>
                <select id="entity-type-select">
                    <option value="ai">AI Agent</option>
                    <option value="twin">Digital Twin</option>
                    <option value="human">Human Player</option>
                </select>
            </div>
            <div class="modal-field">
                <label>Initial Task (for AI/Twin)</label>
                <input type="text" id="entity-task-input" placeholder="e.g., 'Monitor system health'">
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="nexus.hideAddEntityModal()">Cancel</button>
                <button class="modal-btn primary" onclick="nexus.addEntity()">Create Entity</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js" onerror="console.warn('PeerJS CDN blocked, multiplayer disabled')"></script>
    <!-- MediaPipe for hand gesture recognition -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script>
    // ===========================================
    // NEXUS METAVERSE - AI-Human Collaborative Space
    // ===========================================


    // Entity Types
    const EntityType = {
        HUMAN: 'human',
        AI: 'ai',
        TWIN: 'twin'
    };

    // Entity States
    const EntityState = {
        IDLE: 'idle',
        WORKING: 'working',
        THINKING: 'thinking',
        CONTROLLED: 'controlled'
    };

    // Control Modes (for observation)
    const ControlMode = {
        OBSERVE: 'observe',    // Just watching
        GUIDE: 'guide',        // Can send suggestions
        TAKEOVER: 'takeover'   // Full control
    };

    // ===========================================
    // ENTITY CLASS - Core unit for humans & AIs
    // ===========================================
    class Entity {
        constructor(id, name, type, position = { x: 0, y: 0, z: 0 }) {
            this.id = id;
            this.name = name;
            this.type = type;
            this.position = { ...position };
            this.targetPosition = { ...position }; // For smooth movement
            this.rotation = { x: 0, y: 0, z: 0 };
            this.targetRotation = { x: 0, y: 0 }; // For smooth rotation
            this.state = EntityState.IDLE;
            this.currentTask = null;
            this.taskQueue = [];
            this.activityLog = [];
            this.avatar = null;
            this.controlledBy = null; // null = autonomous, or entity ID of controller
            this.observers = []; // List of entities observing this one

            // Smooth movement settings
            this.lerpSpeed = 8; // Higher = faster interpolation
            this.isMoving = false;
            this.moveStartTime = 0;
            this.walkCycleOffset = Math.random() * Math.PI * 2; // Random start for walk animation

            // For AI entities
            this.aiConfig = {
                autonomous: true,
                decisionInterval: 2000,
                personality: 'helpful'
            };

            // CYCLE 2: AI Emotion & Attention System
            this.emotion = 'neutral'; // neutral, curious, focused, helping, thinking
            this.attentionTarget = null; // What this entity is looking at (entityId or 'reality-portal')
            this.emotionIntensity = 0.5; // 0-1

            // For Digital Twins
            this.twinConfig = {
                externalSystemUrl: null,
                syncInterval: 1000,
                lastSyncTime: null
            };
        }

        // Set target position for smooth movement
        moveTo(x, z) {
            this.targetPosition.x = x;
            this.targetPosition.z = z;
            this.isMoving = true;
            this.moveStartTime = Date.now();
        }

        // Update smooth movement (call every frame)
        updateMovement(deltaTime) {
            if (!this.avatar) return;

            const dt = Math.min(deltaTime, 0.1); // Cap delta to prevent jumps
            const lerpFactor = 1 - Math.exp(-this.lerpSpeed * dt);

            // Smooth position interpolation
            const dx = this.targetPosition.x - this.position.x;
            const dz = this.targetPosition.z - this.position.z;
            const distSq = dx * dx + dz * dz;

            if (distSq > 0.0001) {
                this.position.x += dx * lerpFactor;
                this.position.z += dz * lerpFactor;
                this.isMoving = true;

                // Smoothly rotate to face movement direction
                const targetAngle = Math.atan2(dx, dz);
                const currentAngle = this.avatar.rotation.y;
                let angleDiff = targetAngle - currentAngle;

                // Normalize angle difference to -PI to PI
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                this.avatar.rotation.y += angleDiff * lerpFactor * 0.5;
            } else {
                this.position.x = this.targetPosition.x;
                this.position.z = this.targetPosition.z;
                this.isMoving = false;
            }

            // Update avatar position with walking animation
            this.avatar.position.x = this.position.x;
            this.avatar.position.z = this.position.z;

            // Walking animation (minimal to avoid motion sickness)
            if (this.isMoving && distSq > 0.01) {
                // Very subtle bob - smooth sine wave, not bouncing
                const walkSpeed = 6; // Slower
                const bobHeight = 0.02; // Much smaller
                const time = Date.now() * 0.001;
                this.avatar.position.y = Math.sin(time * walkSpeed + this.walkCycleOffset) * bobHeight;
                // No body sway - it adds to motion sickness
            } else {
                // Idle - almost no movement
                this.avatar.position.y = 0;
            }
        }

        log(message, type = 'action') {
            const entry = {
                time: new Date().toISOString(),
                message,
                type
            };
            this.activityLog.push(entry);
            if (this.activityLog.length > 100) {
                this.activityLog.shift();
            }
            return entry;
        }

        teleportTo(x, y, z) {
            this.position = { x, y, z };
            this.targetPosition = { x, z }; // Also update target for smooth movement
            this.log(`Teleported to (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
        }

        setTask(task) {
            this.currentTask = task;
            this.state = EntityState.WORKING;
            this.log(`Started task: ${task}`, 'action');
        }

        completeTask() {
            const completed = this.currentTask;
            this.log(`Completed task: ${completed}`, 'output');
            this.currentTask = null;

            if (this.taskQueue.length > 0) {
                this.setTask(this.taskQueue.shift());
            } else {
                this.state = EntityState.IDLE;
            }
        }

        serialize() {
            return {
                id: this.id,
                name: this.name,
                type: this.type,
                position: this.position,
                rotation: this.rotation,
                state: this.state,
                currentTask: this.currentTask
            };
        }
    }

    // ===========================================
    // NEXUS METAVERSE MAIN CLASS
    // ===========================================
    class NexusMetaverse {
        constructor() {
            // Three.js
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.clock = new THREE.Clock();

            // Entity management
            this.entities = new Map();
            this.localEntity = null; // The human player
            this.observedEntity = null;
            this.controlMode = ControlMode.OBSERVE;

            // Multiplayer
            this.peer = null;
            this.connections = new Map();
            this.roomId = null;
            this.isHost = false;

            // World objects
            this.worldObjects = [];
            this.selectedObject = null;

            // Mode
            this.currentMode = 'explore'; // explore, observe, build

            // Controls
            this.keys = { w: false, a: false, s: false, d: false };
            this.isPointerLocked = false;
            this.moveSpeed = 0.15;
            this.lookSpeed = 0.002;

            // Possession state
            this.prePossessionState = null; // Stores camera state before takeover

            // Minimap
            this.minimapCtx = null;

            // Entity POV camera and renderer
            this.povCamera = null;
            this.povRenderer = null;

            // Reality Portal (webcam for AI perception)
            this.realityMirror = {
                enabled: false,
                stream: null,
                video: null,
                canvas: null,
                ctx: null,
                aiGazeActive: false,
                lastPerception: null,
                lastImageData: null, // For motion detection
                lastCapture: null, // Last captured frame data
                perceptionInterval: null,
                captureInterval: 3000  // How often AI "looks" at reality
            };

            // Spatial Relationship Visualization (CYCLE 2 Enhancement)
            this.relationshipLines = new Map(); // entityId -> Line object
            this.relationshipLinesMaterial = new THREE.LineBasicMaterial({
                transparent: true,
                opacity: 0.6,
                depthWrite: false,
                fog: false
            });

            // Shared Knowledge Base (CYCLE 2 Enhancement)
            this.sharedKnowledge = {
                entries: [], // { timestamp, entityId, entityName, type, content, discovered }
                maxEntries: 100
            };

            // UI Elements
            this.entityListEl = document.getElementById('entity-list');
            this.activityLogEl = document.getElementById('activity-log');
            this.chatMessagesEl = document.getElementById('chat-messages');

            // Performance monitoring
            this.perfStats = {
                fps: 0,
                frameCount: 0,
                lastTime: performance.now(),
                fpsUpdateInterval: 500, // Update FPS every 500ms
                renderMode: 'both' // 'both', 'main', 'pov'
            };

            // Audio System
            this.audio = {
                context: null,
                enabled: false,
                ambientGain: null,
                effectsGain: null,
                ambientOscillators: [],
                masterVolume: 0.3
            };

            // MediaPipe (for Reality Portal gestures)
            this.mediaPipe = {
                enabled: false,
                hands: null,
                camera: null,
                gestureCanvas: null,
                gestureCtx: null,
                lastGesture: null,
                gestureHoldTime: 0,
                gestureStartTime: 0,
                gestureThreshold: 500, // Hold gesture for 500ms to trigger action
                cooldown: false,
                cooldownTime: 1000, // 1 second cooldown between actions
                gestureCallbacks: [],
                // Gesture-to-action mappings
                gestureActions: {
                    'thumbs_up': { action: 'approve', icon: 'üëç', name: 'Approve / Yes' },
                    'thumbs_down': { action: 'reject', icon: 'üëé', name: 'Reject / No' },
                    'open_palm': { action: 'stop', icon: '‚úã', name: 'Stop / Pause' },
                    'fist': { action: 'grab', icon: '‚úä', name: 'Grab / Select' },
                    'peace': { action: 'peace', icon: '‚úåÔ∏è', name: 'Peace / Toggle' },
                    'pointing': { action: 'point', icon: 'üëÜ', name: 'Point / Select' },
                    'wave': { action: 'wave', icon: 'üëã', name: 'Wave / Hello' }
                },
                // Virtual cursor system (pinch-to-select)
                cursor: {
                    enabled: true,
                    element: null,
                    trailElement: null,
                    position: { x: 0.5, y: 0.5 },
                    screenPosition: { x: 0, y: 0 },
                    smoothPosition: { x: 0.5, y: 0.5 },
                    smoothing: 0.25,
                    visible: false,
                    isPinching: false,
                    wasPinching: false,
                    pinchProgress: 0,
                    pinchThreshold: 0.08,
                    pinchStartTime: 0,
                    hoveredElement: null,
                    lastClickTime: 0,
                    clickCooldown: 300,
                    mode: 'fullscreen', // 'portal' or 'fullscreen'
                    trail: [] // Position history for trail effect
                }
            };
        }

        async init() {
            try {
                this.setupScene();
                this.createEnvironment();
                this.setupControls();
                this.setupMinimap();
                this.setupPOVCamera();
                this.setupRealityMirror();
                this.setupClickInteraction();
                this.setupAudio();
                this.setupUI();
                await this.setupMultiplayer();
                this.createLocalPlayer();
                this.spawnDemoAIs();

                // Fix Three.js r134 fog uniform errors by disabling fog on all materials
                this.disableFogOnAllMaterials();

                this.animate();
            } catch (e) {
                console.error('Initialization error:', e);
            } finally {
                // Always hide loading screen
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Fix Three.js r134 fog uniform issues by disabling fog on all materials
        disableFogOnAllMaterials() {
            let count = 0;
            this.scene.traverse((obj) => {
                if (obj.material) {
                    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(mat => {
                        if (mat.fog !== false) {
                            mat.fog = false;
                            mat.needsUpdate = true;
                            count++;
                        }
                    });
                }
            });
            console.log(`[Init] Disabled fog on ${count} materials`);
        }

        // ===========================================
        // SCENE SETUP
        // ===========================================
        setupScene() {
            this.scene = new THREE.Scene();
            // Fog disabled - was causing uniform errors with Three.js r134
            // this.scene.fog = new THREE.Fog(0x0a0a0f, 30, 100);

            this.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            this.camera.position.set(0, 2, 10);

            this.renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: 'high-performance'
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(this.renderer.domElement);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404060, 0.5);
            this.scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(20, 40, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            this.scene.add(dirLight);

            // Hemisphere light for better ambient
            const hemiLight = new THREE.HemisphereLight(0x4488ff, 0x002244, 0.4);
            this.scene.add(hemiLight);

            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        createEnvironment() {
            // Ground plane with grid
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x111122,
                roughness: 0.9
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            this.scene.add(ground);

            // Grid overlay
            const grid = new THREE.GridHelper(200, 100, 0x00d4ff, 0x1a1a2e);
            grid.position.y = 0.01;
            // Disable fog on grid materials to prevent uniform errors
            if (grid.material) {
                if (Array.isArray(grid.material)) {
                    grid.material.forEach(m => m.fog = false);
                } else {
                    grid.material.fog = false;
                }
            }
            this.scene.add(grid);

            // Central hub platform
            const platformGeo = new THREE.CylinderGeometry(8, 10, 0.5, 32);
            const platformMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                metalness: 0.5,
                roughness: 0.3
            });
            const platform = new THREE.Mesh(platformGeo, platformMat);
            platform.position.y = 0.25;
            platform.castShadow = true;
            platform.receiveShadow = true;
            this.scene.add(platform);

            // Portal ring on platform
            const ringGeo = new THREE.TorusGeometry(6, 0.3, 16, 100);
            const ringMat = new THREE.MeshStandardMaterial({
                color: 0x00d4ff,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.5
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.6;
            this.scene.add(ring);

            // Ambient particles
            this.createParticleField();

            // Some environmental structures
            this.createWorldStructures();
        }

        createParticleField() {
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = Math.random() * 30;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

                const color = new THREE.Color();
                color.setHSL(0.55 + Math.random() * 0.1, 0.8, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            const particleGeo = new THREE.BufferGeometry();
            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMat = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                fog: false // Disable fog to prevent uniform errors
            });

            this.particles = new THREE.Points(particleGeo, particleMat);
            this.scene.add(this.particles);
        }

        createWorldStructures() {
            // Create some interesting structures around the hub
            const structures = [
                { pos: [20, 0, 0], type: 'tower' },
                { pos: [-20, 0, 0], type: 'dome' },
                { pos: [0, 0, 20], type: 'arch' },
                { pos: [0, 0, -20], type: 'pillar' }
            ];

            structures.forEach(s => {
                let mesh;
                const color = new THREE.Color().setHSL(Math.random(), 0.6, 0.4);

                if (s.type === 'tower') {
                    const geo = new THREE.CylinderGeometry(2, 3, 15, 8);
                    const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.3 });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.y = 7.5;
                } else if (s.type === 'dome') {
                    const geo = new THREE.SphereGeometry(5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                    const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.5, side: THREE.DoubleSide });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.y = 0;
                } else if (s.type === 'arch') {
                    const geo = new THREE.TorusGeometry(5, 1, 16, 32, Math.PI);
                    const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.4 });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.x = Math.PI / 2;
                    mesh.position.y = 5;
                } else {
                    const geo = new THREE.CylinderGeometry(1, 1, 10, 6);
                    const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.3 });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.y = 5;
                }

                mesh.position.x = s.pos[0];
                mesh.position.z = s.pos[2];
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                this.worldObjects.push(mesh);
            });
        }

        // ===========================================
        // ENTITY MANAGEMENT
        // ===========================================
        createLocalPlayer() {
            const id = 'local-' + Math.random().toString(36).substr(2, 9);
            this.localEntity = new Entity(id, 'You', EntityType.HUMAN, { x: 0, y: 0, z: 10 });
            this.localEntity.avatar = this.createAvatar(EntityType.HUMAN, 0x00d4ff, id);
            this.localEntity.avatar.position.set(0, 0, 10);
            this.scene.add(this.localEntity.avatar);
            this.entities.set(id, this.localEntity);
            this.updateEntityList();

            // Store reference for when user possesses another entity
            this.userOriginalAvatar = this.localEntity.avatar;
        }

        spawnDemoAIs() {
            // Create a few demo AI entities
            const aiConfigs = [
                { name: 'Atlas', task: 'Monitoring system resources', pos: { x: 5, y: 0, z: 5 } },
                { name: 'Nova', task: 'Analyzing data patterns', pos: { x: -5, y: 0, z: 5 } },
                { name: 'Echo', task: 'Processing user requests', pos: { x: 0, y: 0, z: -5 } }
            ];

            aiConfigs.forEach(config => {
                this.createAIEntity(config.name, config.task, config.pos);
            });

            // Create a digital twin example
            this.createDigitalTwin('Factory-Bot-1', 'Monitoring assembly line', { x: 8, y: 0, z: -8 });
        }

        createAIEntity(name, task, position) {
            const id = 'ai-' + Math.random().toString(36).substr(2, 9);
            const entity = new Entity(id, name, EntityType.AI, position);
            entity.setTask(task);
            entity.avatar = this.createAvatar(EntityType.AI, 0x7b2fff, id);
            entity.avatar.position.set(position.x, position.y, position.z);
            this.scene.add(entity.avatar);
            this.entities.set(id, entity);

            // Start autonomous behavior
            this.startAIBehavior(entity);

            this.updateEntityList();
            return entity;
        }

        createDigitalTwin(name, task, position) {
            const id = 'twin-' + Math.random().toString(36).substr(2, 9);
            const entity = new Entity(id, name, EntityType.TWIN, position);
            entity.setTask(task);
            entity.avatar = this.createAvatar(EntityType.TWIN, 0x00ff88, id);
            entity.avatar.position.set(position.x, position.y, position.z);
            this.scene.add(entity.avatar);
            this.entities.set(id, entity);

            // Start twin sync behavior
            this.startTwinSync(entity);

            this.updateEntityList();
            return entity;
        }

        createAvatar(type, color, entityId = null) {
            const group = new THREE.Group();
            group.userData.entityId = entityId; // For click detection

            // Body (cylinder + spheres to simulate capsule, since CapsuleGeometry is r133+)
            const bodyMat = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.3,
                roughness: 0.7
            });

            // Main body cylinder
            const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1, 16);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            group.add(body);

            // Top sphere
            const topSphere = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 8), bodyMat);
            topSphere.position.y = 1.5;
            topSphere.castShadow = true;
            group.add(topSphere);

            // Bottom sphere
            const bottomSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 8), bodyMat);
            bottomSphere.position.y = 0.5;
            bottomSphere.castShadow = true;
            group.add(bottomSphere);

            // Head
            const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0xffddcc,
                metalness: 0.1,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.1;
            head.castShadow = true;
            group.add(head);

            // Type indicator ring
            const ringGeo = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 2.6;
            group.add(ring);

            // Different head features for AI/Twin
            if (type === EntityType.AI) {
                // AI visor
                const visorGeo = new THREE.BoxGeometry(0.5, 0.15, 0.1);
                const visorMat = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5
                });
                const visor = new THREE.Mesh(visorGeo, visorMat);
                visor.position.set(0, 2.15, 0.3);
                group.add(visor);
            } else if (type === EntityType.TWIN) {
                // Twin antenna
                const antennaGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 8);
                const antennaMat = new THREE.MeshStandardMaterial({ color: 0x00ff88 });
                const antenna = new THREE.Mesh(antennaGeo, antennaMat);
                antenna.position.y = 2.6;
                group.add(antenna);

                const tipGeo = new THREE.SphereGeometry(0.05, 8, 8);
                const tipMat = new THREE.MeshStandardMaterial({
                    color: 0x00ff88,
                    emissive: 0x00ff88,
                    emissiveIntensity: 1
                });
                const tip = new THREE.Mesh(tipGeo, tipMat);
                tip.position.y = 2.8;
                group.add(tip);
            }

            // Activity indicator (small sphere above head)
            const indicatorGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const indicatorMat = new THREE.MeshStandardMaterial({
                color: 0x666666,
                emissive: 0x666666,
                emissiveIntensity: 0.3,
                fog: false
            });
            const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
            indicator.position.y = 2.9;
            indicator.name = 'indicator';
            group.add(indicator);

            return group;
        }

        updateAvatarIndicator(entity) {
            if (!entity.avatar) return;
            const indicator = entity.avatar.getObjectByName('indicator');
            if (!indicator) return;

            const colors = {
                [EntityState.IDLE]: 0x666666,
                [EntityState.WORKING]: 0x00ff88,
                [EntityState.THINKING]: 0xffaa00,
                [EntityState.CONTROLLED]: 0x00d4ff
            };

            indicator.material.color.setHex(colors[entity.state] || 0x666666);
        }

        // ===========================================
        // AI BEHAVIOR
        // ===========================================
        startAIBehavior(entity) {
            const behaviors = [
                () => this.aiWander(entity),
                () => this.aiThink(entity),
                () => this.aiWork(entity)
            ];

            const runBehavior = () => {
                if (entity.controlledBy) {
                    // Entity is controlled by human, skip autonomous behavior
                    setTimeout(runBehavior, 1000);
                    return;
                }

                const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
                behavior();

                const nextInterval = 2000 + Math.random() * 3000;
                setTimeout(runBehavior, nextInterval);
            };

            setTimeout(runBehavior, 1000 + Math.random() * 2000);
        }

        aiWander(entity) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 1 + Math.random() * 3;
            const newX = entity.position.x + Math.cos(angle) * distance;
            const newZ = entity.position.z + Math.sin(angle) * distance;

            // Keep within bounds
            const clampedX = Math.max(-30, Math.min(30, newX));
            const clampedZ = Math.max(-30, Math.min(30, newZ));

            // Use smooth movement - the animation loop will handle interpolation
            entity.moveTo(clampedX, clampedZ);
            this.broadcastEntityUpdate(entity);
        }

        aiThink(entity) {
            entity.state = EntityState.THINKING;
            entity.log('Processing...', 'thought');
            this.updateAvatarIndicator(entity);

            setTimeout(() => {
                if (entity.state === EntityState.THINKING) {
                    entity.state = entity.currentTask ? EntityState.WORKING : EntityState.IDLE;
                    entity.log('Analysis complete', 'output');
                    this.updateAvatarIndicator(entity);
                }
            }, 1000 + Math.random() * 2000);
        }

        aiWork(entity) {
            if (!entity.currentTask) {
                const tasks = [
                    'Optimizing neural pathways',
                    'Analyzing environmental data',
                    'Processing knowledge graph',
                    'Synchronizing state vectors',
                    'Compiling response patterns'
                ];
                entity.setTask(tasks[Math.floor(Math.random() * tasks.length)]);
            }
            this.updateAvatarIndicator(entity);
            this.updateActivityLog();
        }

        // ===========================================
        // DIGITAL TWIN SYNC
        // ===========================================
        startTwinSync(entity) {
            // Simulate external system sync
            const sync = () => {
                if (entity.controlledBy) {
                    setTimeout(sync, 1000);
                    return;
                }

                // Simulate receiving data from external system
                const systemStatus = ['nominal', 'processing', 'calibrating', 'standby'][
                    Math.floor(Math.random() * 4)
                ];

                entity.log(`System status: ${systemStatus}`, 'output');
                entity.twinConfig.lastSyncTime = new Date().toISOString();

                if (systemStatus === 'processing') {
                    entity.state = EntityState.WORKING;
                } else if (systemStatus === 'calibrating') {
                    entity.state = EntityState.THINKING;
                } else {
                    entity.state = EntityState.IDLE;
                }

                this.updateAvatarIndicator(entity);
                setTimeout(sync, 3000 + Math.random() * 2000);
            };

            setTimeout(sync, 2000);
        }

        // ===========================================
        // OBSERVATION & CONTROL
        // ===========================================
        observeEntity(entityId) {
            const entity = this.entities.get(entityId);
            if (!entity || entity === this.localEntity) return;

            this.observedEntity = entity;
            this.currentMode = 'observe';
            this.updateModeUI();

            document.getElementById('observation-panel').classList.add('visible');
            document.getElementById('obs-entity-name').textContent = entity.name;

            const statusDot = document.getElementById('obs-status-dot');
            statusDot.className = 'status-dot ' + entity.state;
            document.getElementById('obs-status-text').textContent =
                entity.currentTask || 'No active task';

            this.updateActivityLog();
            entity.log(`Being observed by ${this.localEntity.name}`, 'action');
        }

        setControlMode(mode) {
            if (!this.observedEntity) return;

            const previousMode = this.controlMode;
            this.controlMode = mode;

            // Update UI
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.classList.contains(mode)) {
                    btn.classList.add('active');
                }
            });

            if (mode === ControlMode.TAKEOVER) {
                // POSSESSION MODE: Teleport into the entity's body

                // Save current camera state so we can return later
                this.prePossessionState = {
                    position: this.camera.position.clone(),
                    rotation: {
                        x: this.camera.rotation.x,
                        y: this.camera.rotation.y
                    }
                };

                // Keep user's avatar visible at original position (so they can see where they "left" their body)
                if (this.localEntity && this.localEntity.avatar) {
                    this.localEntity.avatar.visible = true;
                    this.localEntity.avatar.position.set(
                        this.camera.position.x,
                        0,
                        this.camera.position.z
                    );
                    // Make it semi-transparent to show it's "vacant"
                    this.localEntity.avatar.traverse(child => {
                        if (child.material) {
                            child.material.transparent = true;
                            child.material.opacity = 0.5;
                        }
                    });
                }

                // Teleport camera to entity's position (first-person view)
                const entity = this.observedEntity;
                this.camera.position.set(
                    entity.position.x,
                    entity.position.y + 2, // Eye height
                    entity.position.z
                );

                // Face the direction the entity was facing
                if (entity.avatar) {
                    this.camera.rotation.y = entity.avatar.rotation.y;
                    this.camera.rotation.x = 0; // Level gaze
                }

                // Hide the possessed entity's avatar (we ARE them now)
                if (entity.avatar) {
                    entity.avatar.visible = false;
                }

                // Mark as controlled
                entity.controlledBy = this.localEntity.id;
                entity.state = EntityState.CONTROLLED;
                entity.log(`Control taken by ${this.localEntity.name}`, 'action');

                this.addChatMessage('System', `POSSESSING ${entity.name} - You are now seeing through their eyes. Your body remains at the original position.`, 'system');

                // Visual feedback - flash effect
                this.flashPossessionEffect();

            } else {
                // Releasing control
                if (previousMode === ControlMode.TAKEOVER && this.observedEntity.controlledBy === this.localEntity.id) {
                    const entity = this.observedEntity;

                    // Update entity position to where we moved them
                    entity.position.x = this.camera.position.x;
                    entity.position.z = this.camera.position.z;
                    entity.position.y = 0;

                    // Show their avatar again
                    if (entity.avatar) {
                        entity.avatar.visible = true;
                        entity.avatar.position.set(entity.position.x, 0, entity.position.z);
                    }

                    // Return camera to original position (step back from entity)
                    if (this.prePossessionState) {
                        // Step back from the entity so we can see them
                        const stepBackDistance = 5;
                        const direction = new THREE.Vector3();
                        this.camera.getWorldDirection(direction);

                        this.camera.position.set(
                            entity.position.x - direction.x * stepBackDistance,
                            2, // Observer height
                            entity.position.z - direction.z * stepBackDistance
                        );

                        this.prePossessionState = null;
                    }

                    // Restore user avatar to full opacity
                    if (this.localEntity && this.localEntity.avatar) {
                        this.localEntity.avatar.traverse(child => {
                            if (child.material) {
                                child.material.opacity = 1;
                            }
                        });
                        // Move user avatar to current camera position
                        this.localEntity.avatar.position.set(
                            this.camera.position.x,
                            0,
                            this.camera.position.z
                        );
                        this.localEntity.position.x = this.camera.position.x;
                        this.localEntity.position.z = this.camera.position.z;
                    }

                    // Release control
                    entity.controlledBy = null;
                    entity.state = entity.currentTask ? EntityState.WORKING : EntityState.IDLE;
                    entity.log('Control returned to autonomous mode', 'action');

                    // Hide the possession HUD
                    this.hidePossessionHUD();

                    this.addChatMessage('System', `Released control of ${entity.name}. You returned to your body.`, 'system');
                }
            }

            this.updateAvatarIndicator(this.observedEntity);
            this.updateActivityLog();
            this.broadcastEntityUpdate(this.observedEntity);
        }

        flashPossessionEffect() {
            // Create a visual flash to indicate possession
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 212, 255, 0.3);
                pointer-events: none;
                z-index: 1000;
                animation: possessionFlash 0.5s ease-out forwards;
            `;

            // Add animation keyframes if not already present
            if (!document.getElementById('possession-styles')) {
                const style = document.createElement('style');
                style.id = 'possession-styles';
                style.textContent = `
                    @keyframes possessionFlash {
                        0% { opacity: 1; }
                        100% { opacity: 0; }
                    }
                    @keyframes possessionPulse {
                        0%, 100% { opacity: 0.8; }
                        50% { opacity: 0.4; }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 500);

            // Show persistent possession indicator
            this.showPossessionHUD();
        }

        showPossessionHUD() {
            // Remove existing HUD if any
            this.hidePossessionHUD();

            if (!this.observedEntity) return;

            const entity = this.observedEntity;
            const typeColor = entity.type === EntityType.AI ? '#7b2fff' : '#00ff88';

            const hud = document.createElement('div');
            hud.id = 'possession-hud';
            hud.style.cssText = `
                position: fixed;
                top: 60px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                border: 2px solid ${typeColor};
                border-radius: 8px;
                padding: 10px 20px;
                z-index: 200;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 0 20px ${typeColor}40;
            `;

            hud.innerHTML = `
                <div style="
                    width: 12px;
                    height: 12px;
                    background: ${typeColor};
                    border-radius: 50%;
                    animation: possessionPulse 1.5s infinite;
                "></div>
                <div>
                    <div style="font-size: 0.75em; color: rgba(255,255,255,0.6); text-transform: uppercase; letter-spacing: 1px;">
                        Possessing
                    </div>
                    <div style="font-weight: 600; color: ${typeColor};">
                        ${entity.name}
                    </div>
                </div>
                <div style="
                    font-size: 0.8em;
                    color: rgba(255,255,255,0.5);
                    border-left: 1px solid rgba(255,255,255,0.2);
                    padding-left: 12px;
                    margin-left: 4px;
                ">
                    Press <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">ESC</kbd> or click Watch to release
                </div>
            `;

            document.body.appendChild(hud);

            // Add vignette border effect
            const vignette = document.createElement('div');
            vignette.id = 'possession-vignette';
            vignette.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                pointer-events: none;
                z-index: 50;
                box-shadow: inset 0 0 100px ${typeColor}30;
                border: 3px solid ${typeColor}40;
            `;
            document.body.appendChild(vignette);
        }

        hidePossessionHUD() {
            const hud = document.getElementById('possession-hud');
            if (hud) hud.remove();

            const vignette = document.getElementById('possession-vignette');
            if (vignette) vignette.remove();
        }

        updateActivityLog() {
            if (!this.observedEntity) return;

            this.activityLogEl.innerHTML = this.observedEntity.activityLog
                .slice(-20)
                .reverse()
                .map(entry => `
                    <div class="activity-item ${entry.type}">
                        <div class="activity-time">${new Date(entry.time).toLocaleTimeString()}</div>
                        <div>${entry.message}</div>
                    </div>
                `).join('');
        }

        // ===========================================
        // WORLD BUILDER
        // ===========================================
        placeObject(type, position) {
            let mesh;
            const color = new THREE.Color().setHSL(Math.random(), 0.6, 0.5);

            switch (type) {
                case 'cube':
                    mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        new THREE.MeshStandardMaterial({ color })
                    );
                    break;
                case 'sphere':
                    mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(1, 32, 32),
                        new THREE.MeshStandardMaterial({ color })
                    );
                    break;
                case 'cylinder':
                    mesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 4, 16),
                        new THREE.MeshStandardMaterial({ color })
                    );
                    mesh.position.y = 2;
                    break;
                case 'tree':
                    mesh = this.createTree();
                    break;
                case 'light':
                    const light = new THREE.PointLight(0xffaa00, 1, 15);
                    light.position.copy(position);
                    light.position.y += 3;
                    this.scene.add(light);

                    mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3),
                        new THREE.MeshBasicMaterial({ color: 0xffaa00, fog: false })
                    );
                    mesh.position.y = 3;
                    break;
                case 'portal':
                    mesh = this.createPortal();
                    break;
                default:
                    return;
            }

            mesh.position.x = position.x;
            mesh.position.z = position.z;
            if (type !== 'cylinder' && type !== 'light') {
                mesh.position.y = mesh.geometry?.parameters?.height / 2 || 1;
            }
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.type = type;
            mesh.userData.placedBy = this.localEntity?.id;

            this.scene.add(mesh);
            this.worldObjects.push(mesh);

            this.localEntity?.log(`Placed ${type} at (${position.x.toFixed(1)}, ${position.z.toFixed(1)})`, 'action');
            this.broadcastObjectPlaced(mesh);

            return mesh;
        }

        createTree() {
            const group = new THREE.Group();

            // Trunk
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.3, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            trunk.position.y = 1;
            group.add(trunk);

            // Foliage
            const foliage = new THREE.Mesh(
                new THREE.ConeGeometry(1.5, 3, 8),
                new THREE.MeshStandardMaterial({ color: 0x228b22 })
            );
            foliage.position.y = 3.5;
            group.add(foliage);

            return group;
        }

        createPortal() {
            const group = new THREE.Group();

            // Frame
            const frame = new THREE.Mesh(
                new THREE.TorusGeometry(2, 0.2, 16, 32),
                new THREE.MeshStandardMaterial({
                    color: 0x7b2fff,
                    emissive: 0x7b2fff,
                    emissiveIntensity: 0.5
                })
            );
            frame.position.y = 2;
            group.add(frame);

            // Portal surface
            const surface = new THREE.Mesh(
                new THREE.CircleGeometry(1.8, 32),
                new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec2 vUv;
                        void main() {
                            vec2 center = vUv - 0.5;
                            float dist = length(center);
                            float wave = sin(dist * 20.0 - time * 3.0) * 0.5 + 0.5;
                            vec3 color = mix(vec3(0.5, 0.2, 1.0), vec3(0.0, 0.8, 1.0), wave);
                            float alpha = 1.0 - dist * 1.5;
                            gl_FragColor = vec4(color, alpha * 0.8);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    fog: false // Disable fog for portal (prevents uniform errors)
                })
            );
            surface.position.y = 2;
            surface.userData.isPortalSurface = true;
            group.add(surface);

            return group;
        }

        // ===========================================
        // MULTIPLAYER
        // ===========================================
        async setupMultiplayer() {
            // Get room from URL or generate
            const urlParams = new URLSearchParams(window.location.search);
            this.roomId = urlParams.get('room') || 'nexus-' + Math.random().toString(36).substr(2, 6);
            document.getElementById('room-id').textContent = `Room: ${this.roomId}`;

            // Use a timeout to prevent hanging if PeerJS fails
            const timeout = new Promise((resolve) => {
                setTimeout(() => {
                    console.warn('PeerJS connection timeout, running in local mode');
                    document.getElementById('conn-text').textContent = 'Local mode (offline)';
                    document.getElementById('conn-dot').style.background = '#ffaa00';
                    resolve();
                }, 3000);
            });

            const peerSetup = new Promise((resolve) => {
                try {
                    // Check if PeerJS is available
                    if (typeof Peer === 'undefined') {
                        throw new Error('PeerJS not loaded');
                    }

                    this.peer = new Peer('nexus-' + Math.random().toString(36).substr(2, 9));

                    this.peer.on('open', (id) => {
                        document.getElementById('conn-text').textContent = 'Connected to Nexus Network';
                        document.getElementById('conn-dot').style.background = '#00ff88';
                        this.connectToRoom();
                        resolve();
                    });

                    this.peer.on('connection', (conn) => {
                        this.handleConnection(conn);
                    });

                    this.peer.on('error', (err) => {
                        console.warn('Peer error:', err);
                        document.getElementById('conn-text').textContent = 'Local mode (peer error)';
                        document.getElementById('conn-dot').style.background = '#ffaa00';
                        resolve();
                    });

                    this.peer.on('disconnected', () => {
                        document.getElementById('conn-text').textContent = 'Disconnected';
                        document.getElementById('conn-dot').style.background = '#ff4444';
                    });

                } catch (e) {
                    console.warn('PeerJS not available:', e);
                    document.getElementById('conn-text').textContent = 'Local mode';
                    document.getElementById('conn-dot').style.background = '#ffaa00';
                    resolve();
                }
            });

            // Race between timeout and peer setup
            return Promise.race([timeout, peerSetup]);
        }

        connectToRoom() {
            // For demo, just mark as connected
            this.isHost = true;
            this.updatePeerCount();
        }

        handleConnection(conn) {
            conn.on('open', () => {
                this.connections.set(conn.peer, conn);
                this.updatePeerCount();

                // Send current world state
                conn.send({
                    type: 'world-state',
                    entities: Array.from(this.entities.values()).map(e => e.serialize()),
                    objects: this.worldObjects.map(o => ({
                        type: o.userData.type,
                        position: o.position.toArray()
                    }))
                });
            });

            conn.on('data', (data) => {
                this.handlePeerData(conn.peer, data);
            });

            conn.on('close', () => {
                this.connections.delete(conn.peer);
                this.updatePeerCount();
            });
        }

        handlePeerData(peerId, data) {
            switch (data.type) {
                case 'entity-update':
                    this.handleRemoteEntityUpdate(data.entity);
                    break;
                case 'object-placed':
                    this.placeObject(data.objectType, new THREE.Vector3(...data.position));
                    break;
                case 'chat':
                    this.addChatMessage(data.sender, data.message, data.senderType);
                    break;
            }
        }

        broadcastEntityUpdate(entity) {
            const data = {
                type: 'entity-update',
                entity: entity.serialize()
            };
            this.connections.forEach(conn => conn.send(data));
        }

        broadcastObjectPlaced(mesh) {
            const data = {
                type: 'object-placed',
                objectType: mesh.userData.type,
                position: mesh.position.toArray()
            };
            this.connections.forEach(conn => conn.send(data));
        }

        updatePeerCount() {
            const count = this.connections.size;
            document.getElementById('peer-count').textContent = `${count} peer${count !== 1 ? 's' : ''} connected`;
            document.getElementById('entity-total').textContent = `${this.entities.size} entities in world`;
        }

        // ===========================================
        // UI MANAGEMENT
        // ===========================================
        setupUI() {
            // Mode switching
            document.querySelectorAll('.mode-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    const mode = pill.dataset.mode;
                    this.setMode(mode);
                });
            });

            // Builder tools
            document.querySelectorAll('.builder-tool').forEach(tool => {
                tool.addEventListener('click', () => {
                    document.querySelectorAll('.builder-tool').forEach(t => t.classList.remove('selected'));
                    tool.classList.add('selected');
                    this.selectedTool = tool.dataset.tool;

                    if (this.selectedTool === 'save') {
                        this.saveWorld();
                    }
                });
            });

            // Object palette
            document.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('click', () => {
                    const type = item.dataset.object;
                    const pos = new THREE.Vector3(
                        this.camera.position.x + Math.sin(this.camera.rotation.y) * 5,
                        0,
                        this.camera.position.z + Math.cos(this.camera.rotation.y) * 5
                    );
                    this.placeObject(type, pos);
                });
            });

            // Chat input
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.sendChat();
                }
            });

            // Tab to toggle panels
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    document.getElementById('entity-panel').classList.toggle('hidden');
                    document.getElementById('chat-panel').classList.toggle('hidden');
                }
            });
        }

        setMode(mode) {
            this.currentMode = mode;
            this.updateModeUI();

            // Show/hide panels based on mode
            document.getElementById('observation-panel').classList.toggle('visible', mode === 'observe');
            document.getElementById('builder-panel').classList.toggle('visible', mode === 'build');

            if (mode === 'observe' && !this.observedEntity && this.entities.size > 1) {
                // Auto-observe first AI entity
                for (const [id, entity] of this.entities) {
                    if (entity.type !== EntityType.HUMAN) {
                        this.observeEntity(id);
                        break;
                    }
                }
            }
        }

        updateModeUI() {
            document.querySelectorAll('.mode-pill').forEach(pill => {
                pill.classList.toggle('active', pill.dataset.mode === this.currentMode);
            });
        }

        updateEntityList() {
            this.entityListEl.innerHTML = '';

            this.entities.forEach((entity, id) => {
                const card = document.createElement('div');
                card.className = 'entity-card' + (this.observedEntity?.id === id ? ' selected' : '');
                card.innerHTML = `
                    <div class="entity-header">
                        <div class="entity-avatar ${entity.type}">
                            ${entity.type === EntityType.HUMAN ? 'üë§' :
                              entity.type === EntityType.AI ? 'ü§ñ' : '‚öôÔ∏è'}
                        </div>
                        <div class="entity-name">${entity.name}</div>
                        <div class="entity-type">${entity.type.toUpperCase()}</div>
                    </div>
                    <div class="entity-status">
                        <div class="status-dot ${entity.state}"></div>
                        <span>${entity.state}</span>
                    </div>
                    ${entity.currentTask ? `<div class="entity-task">${entity.currentTask}</div>` : ''}
                `;

                card.addEventListener('click', () => {
                    if (entity.type !== EntityType.HUMAN) {
                        this.observeEntity(id);
                        document.querySelectorAll('.entity-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                    }
                });

                this.entityListEl.appendChild(card);
            });

            document.getElementById('entity-count').textContent = this.entities.size;
        }

        showAddEntityModal() {
            document.getElementById('add-entity-modal').classList.add('visible');
        }

        hideAddEntityModal() {
            document.getElementById('add-entity-modal').classList.remove('visible');
        }

        addEntity() {
            const name = document.getElementById('entity-name-input').value || 'New Entity';
            const type = document.getElementById('entity-type-select').value;
            const task = document.getElementById('entity-task-input').value;

            const position = {
                x: (Math.random() - 0.5) * 20,
                y: 0,
                z: (Math.random() - 0.5) * 20
            };

            if (type === EntityType.AI) {
                this.createAIEntity(name, task || 'Awaiting instructions', position);
            } else if (type === EntityType.TWIN) {
                this.createDigitalTwin(name, task || 'Syncing with external system', position);
            }

            this.hideAddEntityModal();
            this.addChatMessage('System', `New entity "${name}" has joined the world`, 'system');
        }

        sendChat() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (!message) return;

            this.addChatMessage(this.localEntity?.name || 'You', message, 'human');

            // Broadcast to peers
            this.connections.forEach(conn => {
                conn.send({
                    type: 'chat',
                    sender: this.localEntity?.name || 'Anonymous',
                    message,
                    senderType: 'human'
                });
            });

            // If message is a command to an AI
            if (message.startsWith('@')) {
                this.handleAICommand(message);
            }

            input.value = '';
        }

        handleAICommand(message) {
            const match = message.match(/@(\w+)\s+(.+)/);
            if (!match) return;

            const [, targetName, command] = match;

            for (const entity of this.entities.values()) {
                if (entity.name.toLowerCase() === targetName.toLowerCase() && entity.type !== EntityType.HUMAN) {
                    entity.setTask(command);
                    this.updateAvatarIndicator(entity);
                    this.addChatMessage(entity.name, `Understood. Starting: ${command}`, 'ai');

                    // CYCLE 2: Add to shared knowledge
                    this.addKnowledge(
                        entity.id,
                        entity.name,
                        'learning',
                        `Received task: ${command}`
                    );

                    if (this.observedEntity?.id === entity.id) {
                        this.updateActivityLog();
                    }
                    break;
                }
            }
        }

        addChatMessage(sender, message, type) {
            const msgEl = document.createElement('div');
            msgEl.className = `chat-message ${type}`;
            msgEl.innerHTML = `
                <div class="chat-sender">${sender}</div>
                <div>${message}</div>
            `;
            this.chatMessagesEl.appendChild(msgEl);
            this.chatMessagesEl.scrollTop = this.chatMessagesEl.scrollHeight;
        }

        // ===========================================
        // CONTROLS
        // ===========================================
        setupControls() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;

                // ESC to close action menu first, then release possession
                if (e.key === 'Escape') {
                    if (this.actionMenuActive) {
                        this.hideActionMenu();
                        return;
                    }
                    if (this.controlMode === ControlMode.TAKEOVER) {
                        this.setControlMode(ControlMode.OBSERVE);
                        return;
                    }
                }

                if (e.key.toLowerCase() in this.keys) {
                    this.keys[e.key.toLowerCase()] = true;
                }
            });

            window.addEventListener('keyup', (e) => {
                if (e.key.toLowerCase() in this.keys) {
                    this.keys[e.key.toLowerCase()] = false;
                }
            });

            // Mouse
            this.renderer.domElement.addEventListener('click', (e) => {
                if (!this.isPointerLocked) {
                    this.renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (this.isPointerLocked) {
                    this.camera.rotation.order = 'YXZ';
                    this.camera.rotation.y -= e.movementX * this.lookSpeed;
                    this.camera.rotation.x -= e.movementY * this.lookSpeed;
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                }
            });
        }

        updateMovement() {
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            this.camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            const moveVector = new THREE.Vector3();

            if (this.keys.w) moveVector.add(forward);
            if (this.keys.s) moveVector.sub(forward);
            if (this.keys.a) moveVector.sub(right);
            if (this.keys.d) moveVector.add(right);

            if (moveVector.length() > 0) {
                moveVector.normalize().multiplyScalar(this.moveSpeed);

                // Check collision before moving
                const newPosition = this.camera.position.clone().add(moveVector);
                if (!this.checkCollision(newPosition)) {
                    // No collision, move the camera
                    this.camera.position.copy(newPosition);
                } else {
                    // Try sliding along walls (check X and Z separately)
                    const slideX = this.camera.position.clone();
                    slideX.x += moveVector.x;
                    if (!this.checkCollision(slideX)) {
                        this.camera.position.x = slideX.x;
                    }

                    const slideZ = this.camera.position.clone();
                    slideZ.z += moveVector.z;
                    if (!this.checkCollision(slideZ)) {
                        this.camera.position.z = slideZ.z;
                    }
                }

                // Update the appropriate entity position
                if (this.controlMode === ControlMode.TAKEOVER && this.observedEntity) {
                    // POSSESSION MODE: We ARE the entity, update their position to match camera
                    const entity = this.observedEntity;
                    entity.position.x = this.camera.position.x;
                    entity.position.z = this.camera.position.z;
                    entity.position.y = 0;

                    // Avatar stays hidden but position updates (for when we release)
                    if (entity.avatar) {
                        entity.avatar.position.x = entity.position.x;
                        entity.avatar.position.z = entity.position.z;
                    }

                    // Log movement occasionally
                    if (Math.random() < 0.02) {
                        entity.log(`Moving to (${entity.position.x.toFixed(1)}, ${entity.position.z.toFixed(1)})`, 'action');
                    }

                    this.broadcastEntityUpdate(entity);
                } else {
                    // Normal mode: update local player
                    if (this.localEntity) {
                        this.localEntity.position = {
                            x: this.camera.position.x,
                            y: 0,
                            z: this.camera.position.z
                        };

                        if (this.localEntity.avatar) {
                            this.localEntity.avatar.position.x = this.localEntity.position.x;
                            this.localEntity.avatar.position.z = this.localEntity.position.z;
                        }

                        this.broadcastEntityUpdate(this.localEntity);
                    }
                }
            }
        }

        // ===========================================
        // COLLISION DETECTION
        // ===========================================
        checkCollision(position, radius = 0.5) {
            // Check collision with world objects (cubes, cylinders, trees, etc.)
            for (const obj of this.worldObjects) {
                if (!obj.userData || obj.userData.type === 'portal') continue; // Skip portals

                const objPos = obj.position;
                const objType = obj.userData.type;

                // Get bounding radius based on object type
                let objRadius = 1;
                if (objType === 'cube') objRadius = 0.7;
                else if (objType === 'sphere') objRadius = 0.6;
                else if (objType === 'cylinder') objRadius = 0.5;
                else if (objType === 'tree') objRadius = 0.4;

                // Simple circle collision
                const dx = position.x - objPos.x;
                const dz = position.z - objPos.z;
                const distSq = dx * dx + dz * dz;
                const minDist = radius + objRadius;

                if (distSq < minDist * minDist) {
                    return true; // Collision!
                }
            }

            // Check collision with entity avatars (except self and possessed entity)
            for (const [id, entity] of this.entities) {
                if (entity === this.localEntity) continue;
                if (this.controlMode === ControlMode.TAKEOVER && entity === this.observedEntity) continue;
                if (!entity.avatar) continue;

                const dx = position.x - entity.position.x;
                const dz = position.z - entity.position.z;
                const distSq = dx * dx + dz * dz;
                const minDist = radius + 0.5; // Entity collision radius

                if (distSq < minDist * minDist) {
                    return true;
                }
            }

            // World bounds
            if (Math.abs(position.x) > 45 || Math.abs(position.z) > 45) {
                return true;
            }

            return false;
        }

        // ===========================================
        // CLICK TO INTERACT WITH ENTITIES
        // ===========================================
        setupClickInteraction() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            document.addEventListener('click', (event) => {
                // Don't interact if clicking on UI elements (except action menu options)
                if (event.target.closest('.entity-panel, .observation-panel, .chat-panel, .builder-panel, .reality-mirror, .modal-overlay, .top-bar')) {
                    return;
                }

                // If action menu is active and we have a gazed action, select it
                if (this.actionMenuActive && this.gazedAction) {
                    this.handleActionMenuClick(this.gazedAction, this.actionMenuTarget);
                    return;
                }

                // If action menu is active but no gazed action, close it
                if (this.actionMenuActive) {
                    this.hideActionMenu();
                    return;
                }

                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Raycast from camera
                raycaster.setFromCamera(mouse, this.camera);

                // Find entity avatars
                const avatars = [];
                this.entities.forEach(entity => {
                    if (entity.avatar && entity !== this.localEntity) {
                        avatars.push(entity.avatar);
                    }
                });

                const intersects = raycaster.intersectObjects(avatars, true);

                if (intersects.length > 0) {
                    // Find which entity was clicked
                    let clickedAvatar = intersects[0].object;
                    while (clickedAvatar.parent && !clickedAvatar.userData?.entityId) {
                        clickedAvatar = clickedAvatar.parent;
                    }

                    const entityId = clickedAvatar.userData?.entityId;
                    if (entityId) {
                        const entity = this.entities.get(entityId);
                        if (entity) {
                            this.onEntityClicked(entity, event.clientX, event.clientY);
                        }
                    }
                }
            });
        }

        onEntityClicked(entity, screenX, screenY) {
            // Show Mass Effect-style action menu
            console.log(`Clicked on ${entity.name} (${entity.type})`);

            // Visual feedback - make entity look at camera
            if (entity.avatar) {
                const dx = this.camera.position.x - entity.position.x;
                const dz = this.camera.position.z - entity.position.z;
                entity.avatar.rotation.y = Math.atan2(dx, dz);
            }

            // Play interaction sound
            this.playSound('interact');

            // Show action menu at click position
            this.showActionMenu(entity, screenX, screenY);
        }

        showActionMenu(entity, x, y) {
            this.actionMenuTarget = entity;
            this.actionMenuActive = true;
            this.gazedAction = null;
            this.lastGazedAction = null;

            // Define action options as vertical dialog list
            this.actionMenuOptions = [
                { action: 'observe', icon: 'üëÅ', label: 'Observe' },
                { action: 'talk', icon: 'üí¨', label: 'Talk' },
                { action: 'follow', icon: 'üö∂', label: 'Follow' },
                { action: 'guide', icon: 'üéØ', label: 'Guide' },
                { action: 'possess', icon: 'üë§', label: 'Control' },
                { action: 'custom', icon: '‚úèÔ∏è', label: 'Say...' }
            ];

            const menu = document.getElementById('world-action-menu');
            const dialog = document.getElementById('world-action-dialog');
            const header = document.getElementById('world-action-header');

            // Clear existing options
            dialog.querySelectorAll('.world-action-option').forEach(el => el.remove());

            // Set header
            header.textContent = entity.name;

            // Create option elements in dialog (vertical list)
            this.actionMenuOptions.forEach((opt, index) => {
                const el = document.createElement('div');
                el.className = 'world-action-option';
                el.dataset.action = opt.action;
                el.dataset.index = index;
                el.innerHTML = `<span class="icon">${opt.icon}</span><span class="label">${opt.label}</span>`;
                el.onclick = () => this.handleActionMenuClick(opt.action, entity);
                dialog.appendChild(el);
            });

            // Show menu and crosshair
            menu.classList.add('visible');
            document.getElementById('gaze-crosshair').classList.add('visible');
            document.getElementById('world-action-hint').style.display = 'block';

            // Play menu open sound
            this.playUISound('menuOpen');

            // Initial position update
            this.updateActionMenuPositions();
        }

        hideActionMenu() {
            const menu = document.getElementById('world-action-menu');
            const dialog = document.getElementById('world-action-dialog');
            menu.classList.remove('visible');
            dialog.querySelectorAll('.world-action-option').forEach(el => el.remove());
            document.getElementById('gaze-crosshair').classList.remove('visible');
            document.getElementById('world-action-hint').style.display = 'none';
            this.actionMenuTarget = null;
            this.actionMenuActive = false;
            this.gazedAction = null;
            this.lastGazedAction = null;
        }

        updateActionMenuPositions() {
            if (!this.actionMenuTarget || !this.actionMenuActive) return;

            const entity = this.actionMenuTarget;
            const menu = document.getElementById('world-action-menu');
            const dialog = document.getElementById('world-action-dialog');

            // Get entity's screen position (at head level)
            const entityPos = new THREE.Vector3(
                entity.position.x,
                entity.position.y + 2.2,
                entity.position.z
            );

            // Project to screen
            const screenPos = entityPos.clone().project(this.camera);
            const centerX = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const centerY = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

            // Check if entity is behind camera
            const toEntity = entityPos.clone().sub(this.camera.position);
            const cameraDir = new THREE.Vector3();
            this.camera.getWorldDirection(cameraDir);
            const isBehind = toEntity.dot(cameraDir) < 0;

            if (isBehind) {
                menu.style.opacity = '0.3';
            } else {
                menu.style.opacity = '1';
            }

            // Position the entire dialog box centered on entity
            dialog.style.left = centerX + 'px';
            dialog.style.top = centerY + 'px';
        }

        updateGazeSelection() {
            if (!this.actionMenuActive) return;

            const dialog = document.getElementById('world-action-dialog');
            const options = dialog.querySelectorAll('.world-action-option');
            const screenCenterY = window.innerHeight / 2;

            let closestOption = null;
            let closestDist = Infinity;

            // For vertical list, only check Y distance (vertical proximity)
            options.forEach(el => {
                const rect = el.getBoundingClientRect();
                const optCenterY = rect.top + rect.height / 2;
                const dist = Math.abs(screenCenterY - optCenterY);

                el.classList.remove('gazed');

                if (dist < closestDist) {
                    closestDist = dist;
                    closestOption = el;
                }
            });

            // Always have something selected
            if (closestOption) {
                closestOption.classList.add('gazed');
                const newAction = closestOption.dataset.action;

                // Play hover sound when selection changes
                if (this.lastGazedAction !== newAction) {
                    const index = parseInt(closestOption.dataset.index) || 0;
                    // Pan based on vertical position in menu (top = slight up, bottom = slight down)
                    const pan = (index - 2.5) * 0.15; // Subtle stereo position
                    this.playUISound('hover', pan);
                    this.lastGazedAction = newAction;
                }

                this.gazedAction = newAction;
            }
        }

        handleActionMenuClick(action, entity) {
            // Play click sound before hiding menu
            this.playUISound('select');
            this.hideActionMenu();

            switch (action) {
                case 'observe':
                    this.observeEntity(entity);
                    document.getElementById('observation-panel').classList.add('visible');
                    entity.log(`Being observed by player`, 'action');
                    break;

                case 'talk':
                    this.observeEntity(entity);
                    // Open chat and greet
                    document.getElementById('chat-panel').classList.remove('hidden');
                    const chatInput = document.getElementById('chat-input');
                    chatInput.focus();
                    chatInput.placeholder = `Chat with ${entity.name}...`;
                    this.addChatMessage(entity.name, `Hello! I'm ${entity.name}. How can I help you?`, 'ai');
                    entity.log(`Engaged in conversation with player`, 'action');
                    break;

                case 'follow':
                    // Make entity follow the player
                    entity.currentTask = `Following ${this.localEntity?.name || 'player'}`;
                    entity.state = EntityState.WORKING;
                    this.addChatMessage(entity.name, `I'll follow you!`, 'ai');
                    entity.log(`Started following player`, 'action');
                    // Set up follow behavior
                    entity.followTarget = this.localEntity?.id;
                    break;

                case 'guide':
                    this.setControlMode(ControlMode.GUIDE);
                    this.observeEntity(entity);
                    document.getElementById('observation-panel').classList.add('visible');
                    this.addChatMessage('System', `Guiding ${entity.name}. Click in the world to direct them.`, 'system');
                    entity.log(`Player is now guiding`, 'action');
                    break;

                case 'possess':
                    this.setControlMode(ControlMode.TAKEOVER);
                    this.observeEntity(entity);
                    this.possessEntity(entity);
                    this.addChatMessage('System', `You are now controlling ${entity.name}. Press ESC to release.`, 'system');
                    entity.log(`Player took control`, 'action');
                    break;

                case 'custom':
                    // Open chat for custom message
                    document.getElementById('chat-panel').classList.remove('hidden');
                    const input = document.getElementById('chat-input');
                    input.focus();
                    input.placeholder = `Say something to ${entity.name}...`;
                    input.value = '';
                    // Store target entity for the message
                    this.chatTargetEntity = entity;
                    break;
            }
        }

        // ===========================================
        // AMBIENT AUDIO SYSTEM
        // ===========================================
        setupAudio() {
            // Audio will be initialized on first user interaction (browser requirement)
            document.addEventListener('click', () => this.initAudioOnInteraction(), { once: true });
            document.addEventListener('keydown', () => this.initAudioOnInteraction(), { once: true });
        }

        initAudioOnInteraction() {
            if (this.audio.context) return;

            try {
                this.audio.context = new (window.AudioContext || window.webkitAudioContext)();

                // Master gain
                const masterGain = this.audio.context.createGain();
                masterGain.gain.value = this.audio.masterVolume;
                masterGain.connect(this.audio.context.destination);

                // Ambient gain (lower volume)
                this.audio.ambientGain = this.audio.context.createGain();
                this.audio.ambientGain.gain.value = 0.15;
                this.audio.ambientGain.connect(masterGain);

                // Effects gain
                this.audio.effectsGain = this.audio.context.createGain();
                this.audio.effectsGain.gain.value = 0.4;
                this.audio.effectsGain.connect(masterGain);

                this.audio.enabled = true;

                // Start ambient soundscape
                this.startAmbientSoundscape();

                console.log('[Audio] Ambient audio initialized');
            } catch (e) {
                console.warn('[Audio] Could not initialize audio:', e);
            }
        }

        startAmbientSoundscape() {
            if (!this.audio.context || !this.audio.enabled) return;

            const ctx = this.audio.context;

            // Very subtle ambient - barely noticeable background for depth
            // Two gentle oscillators with stereo separation for spatial feel
            const ambientVoices = [
                { freq: 55, pan: -0.3, vol: 0.008 },  // Very low bass, left
                { freq: 82.5, pan: 0.3, vol: 0.006 }  // Low, right
            ];

            ambientVoices.forEach((voice, i) => {
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = voice.freq;

                // Subtle detuning for organic feel
                const lfo = ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.05 + (i * 0.02); // Very slow modulation
                const lfoGain = ctx.createGain();
                lfoGain.gain.value = 1; // 1 cent wobble
                lfo.connect(lfoGain);
                lfoGain.connect(osc.detune);
                lfo.start();

                // Stereo panner for spatial depth
                const panner = ctx.createStereoPanner();
                panner.pan.value = voice.pan;

                // Very low volume
                const gain = ctx.createGain();
                gain.gain.value = voice.vol;

                // Warm low-pass filter
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;
                filter.Q.value = 0.5;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(panner);
                panner.connect(this.audio.ambientGain);

                osc.start();
                this.audio.ambientOscillators.push({ osc, gain, filter, lfo });
            });
        }

        playSound(type, options = {}) {
            if (!this.audio.context || !this.audio.enabled) return;

            const ctx = this.audio.context;
            const now = ctx.currentTime;

            switch (type) {
                case 'interact':
                    // Gentle chime for interaction
                    this.playChime([523.25, 659.25, 783.99], 0.1, 0.3);
                    break;

                case 'possess':
                    // Whoosh + resonance for possession
                    this.playWhoosh();
                    this.playChime([261.63, 329.63, 392.00, 523.25], 0.15, 0.8);
                    break;

                case 'release':
                    // Descending chime for release
                    this.playChime([523.25, 392.00, 329.63, 261.63], 0.1, 0.5);
                    break;

                case 'notification':
                    // Quick ping
                    this.playChime([880], 0.05, 0.15);
                    break;

                case 'portal':
                    // Ethereal sweep
                    this.playSweep(200, 800, 0.5);
                    break;
            }
        }

        // Spatial UI sounds for tactile feedback
        playUISound(type, pan = 0) {
            if (!this.audio.context || !this.audio.enabled) return;

            const ctx = this.audio.context;
            const now = ctx.currentTime;

            // Create stereo panner for spatial positioning
            const panner = ctx.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, pan)); // Clamp -1 to 1

            const gain = ctx.createGain();

            switch (type) {
                case 'hover':
                    // Soft, subtle tick - like a tactile button edge
                    const tickOsc = ctx.createOscillator();
                    tickOsc.type = 'sine';
                    tickOsc.frequency.value = 880; // A5 - clean, not annoying

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.06, now + 0.005);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

                    tickOsc.connect(gain);
                    gain.connect(panner);
                    panner.connect(this.audio.effectsGain);

                    tickOsc.start(now);
                    tickOsc.stop(now + 0.06);
                    break;

                case 'select':
                    // Satisfying click confirmation - two quick tones
                    const clickFreqs = [660, 880];
                    clickFreqs.forEach((freq, i) => {
                        const osc = ctx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = freq;

                        const clickGain = ctx.createGain();
                        const startTime = now + (i * 0.03);
                        clickGain.gain.setValueAtTime(0, startTime);
                        clickGain.gain.linearRampToValueAtTime(0.1, startTime + 0.01);
                        clickGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.08);

                        osc.connect(clickGain);
                        clickGain.connect(panner);
                        panner.connect(this.audio.effectsGain);

                        osc.start(startTime);
                        osc.stop(startTime + 0.1);
                    });
                    break;

                case 'menuOpen':
                    // Gentle whoosh up - menu appearing
                    const openOsc = ctx.createOscillator();
                    openOsc.type = 'sine';
                    openOsc.frequency.setValueAtTime(200, now);
                    openOsc.frequency.exponentialRampToValueAtTime(400, now + 0.08);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.05, now + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

                    openOsc.connect(gain);
                    gain.connect(this.audio.effectsGain);

                    openOsc.start(now);
                    openOsc.stop(now + 0.15);
                    break;

                case 'menuClose':
                    // Gentle whoosh down - menu closing
                    const closeOsc = ctx.createOscillator();
                    closeOsc.type = 'sine';
                    closeOsc.frequency.setValueAtTime(400, now);
                    closeOsc.frequency.exponentialRampToValueAtTime(200, now + 0.08);

                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    closeOsc.connect(gain);
                    gain.connect(this.audio.effectsGain);

                    closeOsc.start(now);
                    closeOsc.stop(now + 0.12);
                    break;
            }
        }

        playChime(frequencies, volume = 0.1, duration = 0.3) {
            if (!this.audio.context) return;

            const ctx = this.audio.context;
            const now = ctx.currentTime;

            frequencies.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;

                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0, now + (i * 0.05));
                gain.gain.linearRampToValueAtTime(volume, now + (i * 0.05) + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.05) + duration);

                osc.connect(gain);
                gain.connect(this.audio.effectsGain);

                osc.start(now + (i * 0.05));
                osc.stop(now + (i * 0.05) + duration + 0.1);
            });
        }

        playWhoosh() {
            if (!this.audio.context) return;

            const ctx = this.audio.context;
            const now = ctx.currentTime;

            // Filtered noise whoosh
            const bufferSize = ctx.sampleRate * 0.5;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1);
            }

            const noise = ctx.createBufferSource();
            noise.buffer = buffer;

            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(500, now);
            filter.frequency.linearRampToValueAtTime(2000, now + 0.2);
            filter.frequency.linearRampToValueAtTime(500, now + 0.4);
            filter.Q.value = 2;

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.15, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.audio.effectsGain);

            noise.start(now);
            noise.stop(now + 0.5);
        }

        playSweep(startFreq, endFreq, duration) {
            if (!this.audio.context) return;

            const ctx = this.audio.context;
            const now = ctx.currentTime;

            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            osc.connect(gain);
            gain.connect(this.audio.effectsGain);

            osc.start(now);
            osc.stop(now + duration + 0.1);
        }

        toggleAudio() {
            if (this.audio.enabled) {
                this.audio.ambientGain.gain.value = 0;
                this.audio.effectsGain.gain.value = 0;
                this.audio.enabled = false;
            } else {
                this.audio.ambientGain.gain.value = 0.15;
                this.audio.effectsGain.gain.value = 0.4;
                this.audio.enabled = true;
            }
            return this.audio.enabled;
        }

        setAudioVolume(volume) {
            this.audio.masterVolume = Math.max(0, Math.min(1, volume));
            if (this.audio.context) {
                // Update master gain (connected to destination)
                // For simplicity, adjust ambient and effects directly
                this.audio.ambientGain.gain.value = 0.15 * volume;
                this.audio.effectsGain.gain.value = 0.4 * volume;
            }
        }

        // ===========================================
        // MINIMAP
        // ===========================================
        setupMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 150;
            canvas.height = 150;
            this.minimapCtx = canvas.getContext('2d');
        }

        setupPOVCamera() {
            // Create a secondary camera for entity POV
            this.povCamera = new THREE.PerspectiveCamera(75, 350 / 200, 0.1, 500);

            // Create a secondary renderer for the POV viewport
            const povCanvas = document.getElementById('obs-canvas');
            this.povRenderer = new THREE.WebGLRenderer({
                canvas: povCanvas,
                antialias: false,
                alpha: true
            });
            this.povRenderer.setSize(350, 200);
            this.povRenderer.setPixelRatio(1); // Lower quality for performance
        }

        // ===========================================
        // REALITY MIRROR - Webcam for AI Perception
        // ===========================================
        setupRealityMirror() {
            this.realityMirror.video = document.getElementById('reality-video');
            this.realityMirror.canvas = document.getElementById('reality-canvas');
            this.realityMirror.ctx = this.realityMirror.canvas?.getContext('2d');
        }

        async enableRealityMirror() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    },
                    audio: false
                });

                this.realityMirror.stream = stream;
                this.realityMirror.video.srcObject = stream;
                this.realityMirror.enabled = true;

                // Hide offline message, show video
                document.getElementById('mirror-offline').style.display = 'none';
                this.realityMirror.video.style.display = 'block';

                // Update status
                const dot = document.getElementById('mirror-status-dot');
                const text = document.getElementById('mirror-status-text');
                dot.classList.add('active');
                text.textContent = 'Camera active';

                console.log('[Reality Portal] Camera enabled');

                // Auto-enable AI gaze after camera is on
                if (!this.realityMirror.aiGazeActive) {
                    this.toggleAIGaze();
                }

            } catch (err) {
                console.error('[Reality Portal] Camera access denied:', err);
                document.getElementById('perception-text').textContent =
                    'Camera access denied. Please allow camera permissions to enable AI perception.';
            }
        }

        disableRealityMirror() {
            if (this.realityMirror.stream) {
                this.realityMirror.stream.getTracks().forEach(track => track.stop());
                this.realityMirror.stream = null;
            }

            this.realityMirror.enabled = false;
            this.realityMirror.video.srcObject = null;

            // Show offline message
            document.getElementById('mirror-offline').style.display = 'block';
            this.realityMirror.video.style.display = 'none';

            // Update status
            const dot = document.getElementById('mirror-status-dot');
            const text = document.getElementById('mirror-status-text');
            dot.classList.remove('active', 'watching');
            text.textContent = 'Camera offline';

            // Stop AI gaze
            if (this.realityMirror.aiGazeActive) {
                this.toggleAIGaze();
            }

            console.log('[Reality Portal] Camera disabled');
        }

        toggleAIGaze() {
            this.realityMirror.aiGazeActive = !this.realityMirror.aiGazeActive;

            const btn = document.getElementById('mirror-ai-gaze');
            const indicator = document.getElementById('ai-gaze-indicator');
            const gazeText = document.getElementById('ai-gaze-text');
            const statusDot = document.getElementById('mirror-status-dot');

            if (this.realityMirror.aiGazeActive && this.realityMirror.enabled) {
                btn.classList.add('active');
                indicator.classList.add('active');
                gazeText.textContent = 'AI observing';
                statusDot.classList.add('watching');

                // Start perception loop
                this.startAIPerception();

            } else {
                btn.classList.remove('active');
                indicator.classList.remove('active');
                gazeText.textContent = 'AI not watching';
                statusDot.classList.remove('watching');

                // Stop perception loop
                this.stopAIPerception();
            }
        }

        startAIPerception() {
            if (this.realityMirror.perceptionInterval) {
                clearInterval(this.realityMirror.perceptionInterval);
            }

            // Initial perception
            this.captureAndAnalyze();

            // Periodic perception
            this.realityMirror.perceptionInterval = setInterval(() => {
                this.captureAndAnalyze();
            }, this.realityMirror.captureInterval);
        }

        stopAIPerception() {
            if (this.realityMirror.perceptionInterval) {
                clearInterval(this.realityMirror.perceptionInterval);
                this.realityMirror.perceptionInterval = null;
            }
        }

        async captureAndAnalyze() {
            if (!this.realityMirror.enabled || !this.realityMirror.video) return;

            const video = this.realityMirror.video;
            const canvas = this.realityMirror.canvas;
            const ctx = this.realityMirror.ctx;

            if (!canvas || !ctx) return;

            // Set canvas size to match video
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;

            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Get image data as base64
            const imageData = canvas.toDataURL('image/jpeg', 0.7);

            // Store last capture for AI agents to access
            this.realityMirror.lastCapture = {
                timestamp: Date.now(),
                imageData: imageData,
                width: canvas.width,
                height: canvas.height
            };

            // Generate local perception (placeholder for real AI vision)
            const perception = this.generateLocalPerception();
            this.realityMirror.lastPerception = perception;

            // Update UI
            document.getElementById('perception-text').textContent = perception;

            // Notify any observing AI agents
            this.notifyAgentsOfRealityUpdate(perception, imageData);
        }

        generateLocalPerception() {
            // Enhanced vision analysis simulation
            // In production, this would use TensorFlow.js, MediaPipe, or similar
            const canvas = this.realityMirror.canvas;
            const ctx = this.realityMirror.ctx;

            if (!canvas || !ctx) {
                return 'Vision system initializing...';
            }

            try {
                // Get image data for analysis
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Basic image analysis
                let totalBrightness = 0;
                let totalRed = 0, totalGreen = 0, totalBlue = 0;

                // Sample every 10th pixel for performance
                for (let i = 0; i < data.length; i += 40) {
                    totalRed += data[i];
                    totalGreen += data[i + 1];
                    totalBlue += data[i + 2];
                    totalBrightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }

                const pixelCount = data.length / 40;
                const avgBrightness = Math.round(totalBrightness / pixelCount);
                const avgRed = Math.round(totalRed / pixelCount);
                const avgGreen = Math.round(totalGreen / pixelCount);
                const avgBlue = Math.round(totalBlue / pixelCount);

                // Determine dominant color
                let dominantColor = 'neutral';
                if (avgRed > avgGreen && avgRed > avgBlue) dominantColor = 'warm';
                else if (avgBlue > avgRed && avgBlue > avgGreen) dominantColor = 'cool';
                else if (avgGreen > avgRed && avgGreen > avgBlue) dominantColor = 'natural';

                // Determine lighting condition
                let lighting = 'moderate';
                if (avgBrightness < 50) lighting = 'low';
                else if (avgBrightness > 150) lighting = 'bright';

                // Time context
                const time = new Date();
                const timeContext = time.getHours() < 12 ? 'morning' :
                                   time.getHours() < 17 ? 'afternoon' : 'evening';

                // Build perception description
                const perceptions = [
                    `Scene analysis: ${lighting} lighting, ${dominantColor} tones detected.`,
                    `Visual input: ${avgBrightness}/255 brightness, ${dominantColor} color balance.`,
                    `Environment scan: ${lighting} illumination, ${timeContext} ambient conditions.`,
                    `Optical data: Brightness ${avgBrightness}, dominant ${dominantColor} spectrum.`
                ];

                // Motion detection (simple version - compare to last frame if available)
                let motionHint = '';
                if (this.realityMirror.lastImageData) {
                    let diff = 0;
                    const lastData = this.realityMirror.lastImageData;
                    for (let i = 0; i < Math.min(data.length, lastData.length); i += 400) {
                        diff += Math.abs(data[i] - lastData[i]);
                    }
                    const motionLevel = Math.round(diff / (data.length / 400));
                    if (motionLevel > 10) motionHint = ' [Motion detected]';
                    else if (motionLevel < 3) motionHint = ' [Scene stable]';
                }

                // Store current frame data for next comparison
                this.realityMirror.lastImageData = new Uint8ClampedArray(data);

                return perceptions[Math.floor(Math.random() * perceptions.length)] + motionHint;

            } catch (e) {
                console.warn('Reality Portal perception error:', e);
                return 'Processing visual input from physical environment...';
            }
        }

        notifyAgentsOfRealityUpdate(perception, imageData) {
            // Notify AgentController of reality update
            if (window.agentController) {
                window.agentController.onRealityUpdate({
                    perception,
                    imageData,
                    timestamp: Date.now()
                });
            }

            // CYCLE 2: Add AI observations to shared knowledge
            const aiEntities = Array.from(this.entities.values()).filter(e => e.type === EntityType.AI);
            if (aiEntities.length > 0 && perception) {
                // Pick a random AI entity to "observe" this
                const observer = aiEntities[Math.floor(Math.random() * aiEntities.length)];
                this.addKnowledge(
                    observer.id,
                    observer.name,
                    'observation',
                    perception
                );
            }
        }

        // Reality Portal UI Controls
        showRealityMirror() {
            document.getElementById('reality-mirror').classList.remove('hidden', 'minimized');
            document.getElementById('reality-toggle').classList.add('hidden');
        }

        hideRealityMirror() {
            document.getElementById('reality-mirror').classList.add('hidden');
            document.getElementById('reality-toggle').classList.remove('hidden');
        }

        minimizeRealityMirror() {
            document.getElementById('reality-mirror').classList.add('minimized');
        }

        toggleRealityMirror() {
            const mirror = document.getElementById('reality-mirror');
            if (mirror.classList.contains('minimized')) {
                mirror.classList.remove('minimized');
            } else {
                mirror.classList.add('minimized');
            }
        }

        // CYCLE 2: Knowledge Panel Toggle
        toggleKnowledgePanel() {
            const panel = document.getElementById('knowledge-panel');
            const toggle = document.getElementById('knowledge-toggle');
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                toggle.classList.add('hidden');
            } else {
                panel.classList.add('hidden');
                toggle.classList.remove('hidden');
            }
        }

        // Get current reality snapshot for AI agents
        getRealitySnapshot() {
            return {
                enabled: this.realityMirror.enabled,
                aiGazeActive: this.realityMirror.aiGazeActive,
                lastPerception: this.realityMirror.lastPerception,
                lastCapture: this.realityMirror.lastCapture,
                timestamp: Date.now()
            };
        }

        // ===========================================
        // MEDIAPIPE GESTURE RECOGNITION
        // ===========================================
        async setupMediaPipe() {
            // Check if MediaPipe is available
            if (typeof Hands === 'undefined') {
                console.warn('[MediaPipe] Hands library not loaded');
                return;
            }

            this.mediaPipe.gestureCanvas = document.getElementById('gesture-canvas');
            this.mediaPipe.gestureCtx = this.mediaPipe.gestureCanvas?.getContext('2d');

            // Initialize MediaPipe Hands
            this.mediaPipe.hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            this.mediaPipe.hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            this.mediaPipe.hands.onResults((results) => this.onHandsResults(results));

            console.log('[MediaPipe] Gesture recognition initialized');
        }

        toggleGestureRecognition() {
            if (this.mediaPipe.enabled) {
                this.stopGestureRecognition();
            } else {
                this.startGestureRecognition();
            }
        }

        async startGestureRecognition() {
            if (!this.realityMirror.enabled) {
                console.warn('[MediaPipe] Camera must be enabled first');
                // Auto-enable camera
                await this.enableRealityMirror();
            }

            if (!this.mediaPipe.hands) {
                await this.setupMediaPipe();
            }

            if (!this.mediaPipe.hands) {
                console.error('[MediaPipe] Failed to initialize hands tracking');
                return;
            }

            // Set canvas dimensions
            const video = this.realityMirror.video;
            if (this.mediaPipe.gestureCanvas) {
                this.mediaPipe.gestureCanvas.width = video.videoWidth || 640;
                this.mediaPipe.gestureCanvas.height = video.videoHeight || 480;
            }

            // Start camera feed to MediaPipe
            this.mediaPipe.camera = new Camera(video, {
                onFrame: async () => {
                    if (this.mediaPipe.enabled && this.mediaPipe.hands) {
                        await this.mediaPipe.hands.send({ image: video });
                    }
                },
                width: 640,
                height: 480
            });

            await this.mediaPipe.camera.start();
            this.mediaPipe.enabled = true;

            // Update UI
            document.getElementById('mirror-gesture-toggle')?.classList.add('active');
            console.log('[MediaPipe] Gesture recognition started');
        }

        stopGestureRecognition() {
            this.mediaPipe.enabled = false;

            if (this.mediaPipe.camera) {
                this.mediaPipe.camera.stop();
                this.mediaPipe.camera = null;
            }

            // Clear gesture canvas
            if (this.mediaPipe.gestureCtx && this.mediaPipe.gestureCanvas) {
                this.mediaPipe.gestureCtx.clearRect(
                    0, 0,
                    this.mediaPipe.gestureCanvas.width,
                    this.mediaPipe.gestureCanvas.height
                );
            }

            // Hide gesture indicator
            document.getElementById('gesture-indicator')?.classList.remove('active');
            document.getElementById('mirror-gesture-toggle')?.classList.remove('active');

            console.log('[MediaPipe] Gesture recognition stopped');
        }

        onHandsResults(results) {
            if (!this.mediaPipe.gestureCtx || !this.mediaPipe.gestureCanvas) return;

            const ctx = this.mediaPipe.gestureCtx;
            const canvas = this.mediaPipe.gestureCanvas;

            // Clear previous frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Draw hand landmarks
                for (const landmarks of results.multiHandLandmarks) {
                    this.drawHandLandmarks(ctx, landmarks, canvas.width, canvas.height);
                }

                // Update pinch cursor with first hand landmarks
                this.updatePinchCursor(results.multiHandLandmarks[0]);

                // Recognize gesture from first hand (only if cursor not in use or gesture is clear)
                const gesture = this.recognizeGesture(results.multiHandLandmarks[0]);
                // Don't process gestures while actively using pinch cursor in pinching state
                if (!this.mediaPipe.cursor.isPinching) {
                    this.processGesture(gesture);
                }
            } else {
                // No hands detected
                this.processGesture(null);
                this.updatePinchCursor(null);
            }
        }

        drawHandLandmarks(ctx, landmarks, width, height) {
            // Draw connections
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],       // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8],       // Index
                [0, 9], [9, 10], [10, 11], [11, 12],  // Middle
                [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                [5, 9], [9, 13], [13, 17]              // Palm
            ];

            ctx.strokeStyle = 'rgba(0, 212, 255, 0.8)';
            ctx.lineWidth = 2;

            for (const [start, end] of connections) {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                ctx.beginPath();
                ctx.moveTo(startPoint.x * width, startPoint.y * height);
                ctx.lineTo(endPoint.x * width, endPoint.y * height);
                ctx.stroke();
            }

            // Draw landmark points
            ctx.fillStyle = '#00ff88';
            for (const landmark of landmarks) {
                ctx.beginPath();
                ctx.arc(landmark.x * width, landmark.y * height, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        recognizeGesture(landmarks) {
            if (!landmarks || landmarks.length < 21) return null;

            // Finger tip and base indices
            const fingerTips = [4, 8, 12, 16, 20];
            const fingerBases = [2, 5, 9, 13, 17];
            const fingerMids = [3, 6, 10, 14, 18];

            // Calculate which fingers are extended
            const fingersExtended = [];

            // Thumb (special case - check x position relative to palm)
            const thumbTip = landmarks[4];
            const thumbBase = landmarks[2];
            const palmCenter = landmarks[0];
            const thumbExtended = Math.abs(thumbTip.x - palmCenter.x) > Math.abs(thumbBase.x - palmCenter.x);
            fingersExtended.push(thumbExtended);

            // Other fingers - check if tip is above base (y is inverted)
            for (let i = 1; i < fingerTips.length; i++) {
                const tip = landmarks[fingerTips[i]];
                const base = landmarks[fingerBases[i]];
                const mid = landmarks[fingerMids[i]];
                // Finger is extended if tip is above mid and mid is above base
                const extended = tip.y < mid.y && mid.y < base.y;
                fingersExtended.push(extended);
            }

            const [thumb, index, middle, ring, pinky] = fingersExtended;

            // Gesture recognition based on finger positions
            // Thumbs up: only thumb extended, pointing up
            if (thumb && !index && !middle && !ring && !pinky) {
                const thumbUp = landmarks[4].y < landmarks[3].y;
                if (thumbUp) return 'thumbs_up';
                return 'thumbs_down';
            }

            // Open palm: all fingers extended
            if (thumb && index && middle && ring && pinky) {
                return 'open_palm';
            }

            // Fist: no fingers extended
            if (!thumb && !index && !middle && !ring && !pinky) {
                return 'fist';
            }

            // Peace sign: index and middle extended
            if (!thumb && index && middle && !ring && !pinky) {
                return 'peace';
            }

            // Pointing: only index extended
            if (!thumb && index && !middle && !ring && !pinky) {
                return 'pointing';
            }

            // Wave detection (all fingers extended and hand moving side to side)
            // For simplicity, we'll use open palm with rapid x movement
            // This would need motion tracking for proper detection
            if (index && middle && ring && pinky) {
                // Check for wave by looking at wrist position changes
                // For now, open palm counts as potential wave
                return 'open_palm';
            }

            return null;
        }

        processGesture(gesture) {
            const indicator = document.getElementById('gesture-indicator');
            const iconEl = document.getElementById('gesture-icon');
            const nameEl = document.getElementById('gesture-name');

            if (!gesture) {
                // No gesture detected
                this.mediaPipe.lastGesture = null;
                this.mediaPipe.gestureStartTime = 0;
                indicator?.classList.remove('active');
                return;
            }

            const gestureInfo = this.mediaPipe.gestureActions[gesture];
            if (!gestureInfo) return;

            // Update indicator
            indicator?.classList.add('active');
            if (iconEl) iconEl.textContent = gestureInfo.icon;
            if (nameEl) nameEl.textContent = gestureInfo.name;

            // Track gesture hold time
            const now = Date.now();

            if (gesture !== this.mediaPipe.lastGesture) {
                // New gesture started
                this.mediaPipe.lastGesture = gesture;
                this.mediaPipe.gestureStartTime = now;
            } else {
                // Same gesture continuing
                const holdTime = now - this.mediaPipe.gestureStartTime;

                // Check if gesture held long enough to trigger action
                if (holdTime >= this.mediaPipe.gestureThreshold && !this.mediaPipe.cooldown) {
                    this.triggerGestureAction(gesture, gestureInfo);
                }
            }
        }

        triggerGestureAction(gesture, gestureInfo) {
            // Start cooldown
            this.mediaPipe.cooldown = true;
            setTimeout(() => {
                this.mediaPipe.cooldown = false;
            }, this.mediaPipe.cooldownTime);

            // Reset gesture tracking
            this.mediaPipe.gestureStartTime = Date.now();

            // Show visual feedback
            this.showGestureActionFeedback(gestureInfo);

            // Play sound
            this.playSound('interact');

            // Execute action based on gesture
            switch (gestureInfo.action) {
                case 'approve':
                    this.onGestureApprove();
                    break;
                case 'reject':
                    this.onGestureReject();
                    break;
                case 'stop':
                    this.onGestureStop();
                    break;
                case 'grab':
                    this.onGestureGrab();
                    break;
                case 'peace':
                    this.onGesturePeace();
                    break;
                case 'point':
                    this.onGesturePoint();
                    break;
                case 'wave':
                    this.onGestureWave();
                    break;
            }

            // Notify callbacks
            this.mediaPipe.gestureCallbacks.forEach(cb => {
                try {
                    cb(gesture, gestureInfo);
                } catch (e) {
                    console.error('Gesture callback error:', e);
                }
            });

            console.log(`[Gesture] Action triggered: ${gestureInfo.action}`);
        }

        showGestureActionFeedback(gestureInfo) {
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.className = 'gesture-action-feedback';
            feedback.innerHTML = `
                <div class="icon">${gestureInfo.icon}</div>
                <div class="action">${gestureInfo.name}</div>
            `;
            document.body.appendChild(feedback);

            // Remove after animation
            setTimeout(() => {
                feedback.remove();
            }, 1500);
        }

        // Gesture action handlers
        onGestureApprove() {
            // Thumbs up - confirm/approve current action
            this.addChatMessage('System', 'Gesture: Approved! (Thumbs Up)', 'system');

            // If observing an entity, send approval
            if (this.observedEntity) {
                this.observedEntity.log('Received approval gesture from human', 'input');
            }
        }

        onGestureReject() {
            // Thumbs down - reject/cancel
            this.addChatMessage('System', 'Gesture: Rejected! (Thumbs Down)', 'system');

            // If observing an entity, send rejection
            if (this.observedEntity) {
                this.observedEntity.log('Received rejection gesture from human', 'input');
            }
        }

        onGestureStop() {
            // Open palm - stop/pause
            this.addChatMessage('System', 'Gesture: Stop! (Open Palm)', 'system');

            // Stop all AI entities
            this.entities.forEach(entity => {
                if (entity.type === EntityType.AI) {
                    entity.state = EntityState.IDLE;
                    entity.log('Paused by human gesture', 'input');
                }
            });
        }

        onGestureGrab() {
            // Fist - grab/select nearest object or entity
            this.addChatMessage('System', 'Gesture: Grab! (Fist)', 'system');

            // Find nearest entity to camera and select it
            let nearest = null;
            let nearestDist = Infinity;

            this.entities.forEach(entity => {
                if (entity === this.localEntity) return;
                const dx = entity.position.x - this.camera.position.x;
                const dz = entity.position.z - this.camera.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < nearestDist && dist < 15) {
                    nearestDist = dist;
                    nearest = entity;
                }
            });

            if (nearest) {
                this.observeEntity(nearest);
                this.addChatMessage('System', `Selected ${nearest.name}`, 'system');
            }
        }

        onGesturePeace() {
            // Peace sign - toggle mode or special action
            this.addChatMessage('System', 'Gesture: Peace! (V Sign)', 'system');

            // Toggle between explore and observe modes
            if (this.currentMode === 'explore') {
                this.setMode('observe');
            } else {
                this.setMode('explore');
            }
        }

        onGesturePoint() {
            // Pointing - select/interact with pointed direction
            this.addChatMessage('System', 'Gesture: Point! (Pointing)', 'system');

            // Could implement raycast in pointing direction
            // For now, toggle AI gaze
            this.toggleAIGaze();
        }

        onGestureWave() {
            // Wave - greeting/hello
            this.addChatMessage('System', 'Gesture: Wave! Hello! (Waving)', 'system');

            // Make all AI entities acknowledge
            this.entities.forEach(entity => {
                if (entity.type === EntityType.AI) {
                    entity.log('Human waved - greeting!', 'input');
                }
            });
        }

        // Register callback for gesture events
        onGesture(callback) {
            this.mediaPipe.gestureCallbacks.push(callback);
        }

        // ===========================================
        // PINCH CURSOR SYSTEM - Virtual Mouse Pointer
        // ===========================================
        initPinchCursor() {
            // Create cursor element if it doesn't exist
            if (!this.mediaPipe.cursor.element) {
                const cursor = document.createElement('div');
                cursor.className = 'pinch-cursor';
                cursor.id = 'pinch-cursor';
                cursor.innerHTML = `
                    <div class="pinch-cursor-progress"></div>
                    <div class="pinch-cursor-ring"></div>
                    <div class="pinch-cursor-dot"></div>
                `;
                document.body.appendChild(cursor);
                this.mediaPipe.cursor.element = cursor;

                // Create trail container
                const trail = document.createElement('div');
                trail.className = 'pinch-cursor-trail';
                trail.id = 'pinch-cursor-trail';
                document.body.appendChild(trail);
                this.mediaPipe.cursor.trailElement = trail;
            }
        }

        togglePinchCursor() {
            this.mediaPipe.cursor.enabled = !this.mediaPipe.cursor.enabled;

            const btn = document.getElementById('mirror-cursor-toggle');
            const indicator = document.getElementById('cursor-mode-indicator');

            if (this.mediaPipe.cursor.enabled) {
                btn?.classList.add('active');
                indicator?.classList.add('active');
                this.initPinchCursor();

                // Auto-start gesture recognition if not running
                if (!this.mediaPipe.enabled) {
                    this.startGestureRecognition();
                }

                console.log('[Pinch Cursor] Enabled');
            } else {
                btn?.classList.remove('active');
                indicator?.classList.remove('active');
                this.hidePinchCursor();
                console.log('[Pinch Cursor] Disabled');
            }
        }

        hidePinchCursor() {
            const cursor = this.mediaPipe.cursor.element;
            if (cursor) {
                cursor.classList.remove('visible', 'pinching', 'hovering');
            }
            this.mediaPipe.cursor.visible = false;

            // Clear any hover states
            if (this.mediaPipe.cursor.hoveredElement) {
                this.mediaPipe.cursor.hoveredElement.classList.remove('pinch-hovered');
                this.mediaPipe.cursor.hoveredElement = null;
            }
        }

        updatePinchCursor(landmarks) {
            if (!this.mediaPipe.cursor.enabled || !landmarks || landmarks.length < 21) {
                this.hidePinchCursor();
                return;
            }

            const cursor = this.mediaPipe.cursor;
            if (!cursor.element) {
                this.initPinchCursor();
            }

            // Get index finger tip position (landmark 8)
            const indexTip = landmarks[8];
            // Get thumb tip position (landmark 4)
            const thumbTip = landmarks[4];

            // Calculate pinch distance
            const pinchDistance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) +
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // Use midpoint between thumb and index for cursor when pinching
            // Use index tip when not pinching (pointing mode)
            const cursorX = cursor.isPinching
                ? (thumbTip.x + indexTip.x) / 2
                : indexTip.x;
            const cursorY = cursor.isPinching
                ? (thumbTip.y + indexTip.y) / 2
                : indexTip.y;

            // Update raw position (mirrored since video is mirrored)
            cursor.position.x = 1 - cursorX;
            cursor.position.y = cursorY;

            // Smooth the position
            cursor.smoothPosition.x += (cursor.position.x - cursor.smoothPosition.x) * cursor.smoothing;
            cursor.smoothPosition.y += (cursor.position.y - cursor.smoothPosition.y) * cursor.smoothing;

            // Convert to screen coordinates
            cursor.screenPosition.x = cursor.smoothPosition.x * window.innerWidth;
            cursor.screenPosition.y = cursor.smoothPosition.y * window.innerHeight;

            // Update cursor element position
            if (cursor.element) {
                cursor.element.style.left = cursor.screenPosition.x + 'px';
                cursor.element.style.top = cursor.screenPosition.y + 'px';
                cursor.element.classList.add('visible');
                cursor.visible = true;
            }

            // Update trail
            this.updateCursorTrail();

            // Detect pinch state
            const wasPinching = cursor.isPinching;
            cursor.isPinching = pinchDistance < cursor.pinchThreshold;

            // Calculate pinch progress (for visual feedback)
            const pinchStart = cursor.pinchThreshold * 1.5;
            cursor.pinchProgress = Math.max(0, Math.min(1,
                (pinchStart - pinchDistance) / (pinchStart - cursor.pinchThreshold)
            ));

            // Update cursor visual state
            if (cursor.element) {
                cursor.element.style.setProperty('--progress', cursor.pinchProgress);

                if (cursor.pinchProgress > 0.3) {
                    cursor.element.classList.add('pinch-progress');
                } else {
                    cursor.element.classList.remove('pinch-progress');
                }

                if (cursor.isPinching) {
                    cursor.element.classList.add('pinching');
                } else {
                    cursor.element.classList.remove('pinching');
                }
            }

            // Handle pinch state changes
            if (cursor.isPinching && !wasPinching) {
                // Pinch started
                this.onPinchStart();
            } else if (!cursor.isPinching && wasPinching) {
                // Pinch ended (this is the "click")
                this.onPinchEnd();
            }

            cursor.wasPinching = wasPinching;

            // Update hover state
            this.updateCursorHover();
        }

        updateCursorTrail() {
            const cursor = this.mediaPipe.cursor;
            const trail = cursor.trail;
            const trailEl = cursor.trailElement;

            if (!trailEl) return;

            // Add current position to trail
            trail.push({
                x: cursor.screenPosition.x,
                y: cursor.screenPosition.y,
                time: Date.now()
            });

            // Remove old trail points (older than 200ms)
            const now = Date.now();
            while (trail.length > 0 && now - trail[0].time > 200) {
                trail.shift();
            }

            // Limit trail length
            while (trail.length > 10) {
                trail.shift();
            }

            // Update trail visualization
            trailEl.innerHTML = trail.map((point, i) => {
                const opacity = (i / trail.length) * 0.5;
                const size = 3 + (i / trail.length) * 3;
                return `<div class="trail-dot" style="
                    left: ${point.x}px;
                    top: ${point.y}px;
                    width: ${size}px;
                    height: ${size}px;
                    opacity: ${opacity};
                "></div>`;
            }).join('');
        }

        updateCursorHover() {
            const cursor = this.mediaPipe.cursor;

            // Get element under cursor
            const element = document.elementFromPoint(
                cursor.screenPosition.x,
                cursor.screenPosition.y
            );

            // Clear previous hover
            if (cursor.hoveredElement && cursor.hoveredElement !== element) {
                cursor.hoveredElement.classList.remove('pinch-hovered');
            }

            // Check if element is clickable
            const isClickable = element && (
                element.tagName === 'BUTTON' ||
                element.tagName === 'A' ||
                element.onclick ||
                element.classList.contains('pinch-hoverable') ||
                element.closest('button') ||
                element.closest('a') ||
                element.closest('.control-btn') ||
                element.closest('.mirror-btn') ||
                element.closest('.entity-item')
            );

            if (isClickable) {
                const clickableEl = element.closest('button') ||
                                   element.closest('a') ||
                                   element.closest('.control-btn') ||
                                   element.closest('.mirror-btn') ||
                                   element.closest('.entity-item') ||
                                   element;

                clickableEl.classList.add('pinch-hovered');
                cursor.hoveredElement = clickableEl;
                cursor.element?.classList.add('hovering');
            } else {
                cursor.hoveredElement = null;
                cursor.element?.classList.remove('hovering');
            }
        }

        onPinchStart() {
            const cursor = this.mediaPipe.cursor;
            cursor.pinchStartTime = Date.now();

            // Play subtle sound
            this.playSound('interact');

            console.log('[Pinch] Started');
        }

        onPinchEnd() {
            const cursor = this.mediaPipe.cursor;
            const now = Date.now();

            // Check cooldown
            if (now - cursor.lastClickTime < cursor.clickCooldown) {
                return;
            }

            const pinchDuration = now - cursor.pinchStartTime;

            // Only register click if pinch was quick (tap) - less than 500ms
            if (pinchDuration < 500) {
                cursor.lastClickTime = now;
                this.performPinchClick();
            }

            console.log('[Pinch] Ended, duration:', pinchDuration);
        }

        performPinchClick() {
            const cursor = this.mediaPipe.cursor;

            // Create click ripple effect
            this.createClickRipple(cursor.screenPosition.x, cursor.screenPosition.y);

            // Play click sound
            this.playSound('interact');

            // Get element under cursor
            const element = document.elementFromPoint(
                cursor.screenPosition.x,
                cursor.screenPosition.y
            );

            if (!element) {
                console.log('[Pinch Click] No element at position');
                return;
            }

            // Find clickable element
            const clickable = element.closest('button') ||
                             element.closest('a') ||
                             element.closest('.control-btn') ||
                             element.closest('.mirror-btn') ||
                             element.closest('.entity-item') ||
                             (element.onclick ? element : null);

            if (clickable) {
                // Trigger the click
                console.log('[Pinch Click] Clicking:', clickable.tagName, clickable.className);

                // Create and dispatch click event
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true,
                    clientX: cursor.screenPosition.x,
                    clientY: cursor.screenPosition.y
                });

                clickable.dispatchEvent(clickEvent);

                // Visual feedback
                clickable.classList.add('pinch-clicked');
                setTimeout(() => {
                    clickable.classList.remove('pinch-clicked');
                }, 200);

            } else {
                // Click in 3D space - raycast to find entities
                this.performPinch3DClick(cursor.screenPosition.x, cursor.screenPosition.y);
            }
        }

        performPinch3DClick(screenX, screenY) {
            // Convert screen position to normalized device coordinates
            const mouse = new THREE.Vector2(
                (screenX / window.innerWidth) * 2 - 1,
                -(screenY / window.innerHeight) * 2 + 1
            );

            // Raycast from camera
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, this.camera);

            // Find entity avatars
            const avatars = [];
            this.entities.forEach(entity => {
                if (entity.avatar && entity !== this.localEntity) {
                    avatars.push(entity.avatar);
                }
            });

            const intersects = raycaster.intersectObjects(avatars, true);

            if (intersects.length > 0) {
                // Find which entity was clicked
                let clickedAvatar = intersects[0].object;
                while (clickedAvatar.parent && !clickedAvatar.userData?.entityId) {
                    clickedAvatar = clickedAvatar.parent;
                }

                const entityId = clickedAvatar.userData?.entityId;
                if (entityId) {
                    const entity = this.entities.get(entityId);
                    if (entity) {
                        this.onEntityClicked(entity, screenX, screenY);
                        console.log('[Pinch 3D Click] Selected entity:', entity.name);
                    }
                }
            } else {
                console.log('[Pinch 3D Click] No entity at position');
            }
        }

        createClickRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'pinch-click-ripple';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            document.body.appendChild(ripple);

            // Remove after animation
            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        updateMinimap() {
            const ctx = this.minimapCtx;
            const size = 150;
            const scale = 2; // 1 unit = 2 pixels

            // Clear
            ctx.fillStyle = 'rgba(10, 10, 20, 0.9)';
            ctx.fillRect(0, 0, size, size);

            // Grid
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < size; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, size);
                ctx.moveTo(0, i);
                ctx.lineTo(size, i);
                ctx.stroke();
            }

            // Center (origin)
            const centerX = size / 2;
            const centerY = size / 2;

            // Draw world objects (buildings, structures)
            this.worldObjects.forEach(obj => {
                const x = centerX + obj.position.x * scale;
                const y = centerY - obj.position.z * scale;

                // Only draw if in view
                if (x >= 0 && x <= size && y >= 0 && y <= size) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
            });

            // Draw entities
            this.entities.forEach(entity => {
                const x = centerX + entity.position.x * scale;
                const y = centerY - entity.position.z * scale;

                // Only draw if in view
                if (x >= 0 && x <= size && y >= 0 && y <= size) {
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);

                    if (entity.type === EntityType.HUMAN) {
                        ctx.fillStyle = '#00d4ff';
                    } else if (entity.type === EntityType.AI) {
                        ctx.fillStyle = '#7b2fff';
                    } else {
                        ctx.fillStyle = '#00ff88';
                    }

                    ctx.fill();

                    // Direction indicator for local player
                    if (entity === this.localEntity) {
                        ctx.strokeStyle = '#00d4ff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Highlight observed entity
                    if (entity === this.observedEntity) {
                        ctx.strokeStyle = '#ffaa00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, 7, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            });

            // Camera direction indicator
            const dirLen = 15;
            const camDir = new THREE.Vector3();
            this.camera.getWorldDirection(camDir);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX + this.localEntity?.position.x * scale || centerX,
                       centerY - (this.localEntity?.position.z * scale || 0));
            ctx.lineTo(centerX + (this.localEntity?.position.x || 0) * scale + camDir.x * dirLen,
                       centerY - ((this.localEntity?.position.z || 0) * scale + camDir.z * dirLen));
            ctx.stroke();
        }

        // ===========================================
        // PERFORMANCE MONITORING
        // ===========================================
        updatePerformanceStats() {
            this.perfStats.frameCount++;

            const now = performance.now();
            const elapsed = now - this.perfStats.lastTime;

            // Update FPS calculation every 500ms
            if (elapsed >= this.perfStats.fpsUpdateInterval) {
                this.perfStats.fps = Math.round((this.perfStats.frameCount * 1000) / elapsed);
                this.perfStats.frameCount = 0;
                this.perfStats.lastTime = now;

                // Update UI
                const fpsEl = document.getElementById('stat-fps');
                if (fpsEl) {
                    fpsEl.textContent = this.perfStats.fps;
                    // Color code based on performance
                    fpsEl.className = 'perf-stat-value';
                    if (this.perfStats.fps < 30) {
                        fpsEl.classList.add('critical');
                    } else if (this.perfStats.fps < 50) {
                        fpsEl.classList.add('warning');
                    }
                }

                const entitiesEl = document.getElementById('stat-entities');
                if (entitiesEl) {
                    entitiesEl.textContent = this.entities.size;
                }

                const objectsEl = document.getElementById('stat-objects');
                if (objectsEl) {
                    objectsEl.textContent = this.worldObjects.length;
                }

                const renderEl = document.getElementById('stat-render');
                if (renderEl) {
                    renderEl.textContent = this.perfStats.renderMode === 'both' ? 'Main+POV' : 'Main';
                }
            }
        }

        // ===========================================
        // WORLD SAVE/LOAD
        // ===========================================
        saveWorld() {
            const worldData = {
                name: 'Nexus World',
                timestamp: new Date().toISOString(),
                entities: Array.from(this.entities.values())
                    .filter(e => e.type !== EntityType.HUMAN)
                    .map(e => e.serialize()),
                objects: this.worldObjects.map(o => ({
                    type: o.userData.type,
                    position: o.position.toArray(),
                    rotation: o.rotation.toArray()
                }))
            };

            const blob = new Blob([JSON.stringify(worldData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'nexus-world.json';
            a.click();
            URL.revokeObjectURL(url);

            this.addChatMessage('System', 'World saved successfully!', 'system');
        }

        // ===========================================
        // ANIMATION LOOP
        // ===========================================
        animate() {
            requestAnimationFrame(() => this.animate());

            const time = this.clock.getElapsedTime();
            const deltaTime = this.clock.getDelta(); // Time since last frame

            // Performance monitoring
            this.updatePerformanceStats();

            // Update human player movement (keyboard input)
            this.updateMovement();

            // Update all entity smooth movement and animations
            const realityPortalActive = this.realityMirror?.enabled && this.realityMirror?.aiGazeActive;

            this.entities.forEach(entity => {
                // Smooth movement interpolation
                entity.updateMovement(deltaTime);

                if (entity.avatar) {
                    // Animate status indicator
                    const indicator = entity.avatar.getObjectByName('indicator');
                    if (indicator && entity.state === EntityState.WORKING) {
                        indicator.position.y = 2.9 + Math.sin(time * 4) * 0.1;
                    }

                    // AI entities face the Reality Portal when it's active
                    // This creates the visual impression they're "looking at" the human
                    if (realityPortalActive && entity.type === EntityType.AI && !entity.isMoving) {
                        // Camera position represents "where the portal is" from their perspective
                        const targetX = this.camera.position.x;
                        const targetZ = this.camera.position.z;
                        const dx = targetX - entity.position.x;
                        const dz = targetZ - entity.position.z;
                        const targetAngle = Math.atan2(dx, dz);

                        // Smooth rotation toward portal
                        const currentAngle = entity.avatar.rotation.y;
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        entity.avatar.rotation.y += angleDiff * 0.02; // Slow, subtle turn

                        // Subtle "looking up" animation when gazing at reality
                        const lookUpAmount = Math.sin(time * 0.5 + entity.walkCycleOffset) * 0.05;
                        const head = entity.avatar.children.find(c => c.position.y > 1.5);
                        if (head) {
                            head.rotation.x = -0.1 + lookUpAmount; // Slight upward gaze
                        }
                    }
                }
            });

            // Animate particles
            if (this.particles) {
                this.particles.rotation.y = time * 0.02;
                const positions = this.particles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(time + i) * 0.002;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate portals
            this.worldObjects.forEach(obj => {
                if (obj.userData.type === 'portal') {
                    obj.traverse(child => {
                        if (child.userData.isPortalSurface &&
                            child.material?.uniforms?.time) {
                            child.material.uniforms.time.value = time;
                        }
                    });
                    obj.rotation.y = time * 0.5;
                }
            });

            // CYCLE 2: Update spatial relationship lines
            this.updateRelationshipLines();

            // CYCLE 2: Update AI emotions and attention
            this.updateAIEmotions(time);

            // Update UI
            this.updateMinimap();

            // Update world-space action menu positions and gaze selection
            if (this.actionMenuActive) {
                this.updateActionMenuPositions();
                this.updateGazeSelection();
            }

            // Render main view
            this.renderer.render(this.scene, this.camera);

            // Render observation viewport if entity is being observed AND panel is visible
            // OPTIMIZATION: Only render POV when observation panel is actually visible
            const obsPanel = document.getElementById('observation-panel');
            if (this.observedEntity && obsPanel && obsPanel.classList.contains('visible')) {
                this.renderObservationViewport();
                this.perfStats.renderMode = 'both';
            } else {
                this.perfStats.renderMode = 'main';
            }
        }

        renderObservationViewport() {
            if (!this.observedEntity || !this.povRenderer || !this.povCamera) return;

            const entity = this.observedEntity;

            // Update status display
            document.getElementById('obs-status-text').textContent =
                entity.currentTask || 'No active task';

            const statusDot = document.getElementById('obs-status-dot');
            statusDot.className = 'status-dot ' + entity.state;

            // Position the POV camera at the entity's location
            this.povCamera.position.set(
                entity.position.x,
                entity.position.y + 2, // Eye height
                entity.position.z
            );

            // Make the entity's avatar temporarily visible for others but not blocking POV
            // Calculate a forward direction (entity faces outward from center, or uses stored rotation)
            const lookTarget = new THREE.Vector3();

            if (entity.avatar) {
                // Look in the direction the avatar is facing
                const forward = new THREE.Vector3(0, 0, 1);
                forward.applyQuaternion(entity.avatar.quaternion);
                lookTarget.copy(this.povCamera.position).add(forward.multiplyScalar(10));
            } else {
                // Default: look toward center
                lookTarget.set(0, 2, 0);
            }

            // Add some head movement for liveliness
            const time = this.clock.getElapsedTime();
            lookTarget.x += Math.sin(time * 0.5) * 2;
            lookTarget.y += Math.sin(time * 0.3) * 0.5;

            this.povCamera.lookAt(lookTarget);

            // Render the scene from entity's POV
            this.povRenderer.render(this.scene, this.povCamera);
        }

        // ===========================================
        // CYCLE 2 ENHANCEMENTS
        // ===========================================

        updateRelationshipLines() {
            // Remove old lines
            this.relationshipLines.forEach((line, entityId) => {
                this.scene.remove(line);
                line.geometry.dispose();
            });
            this.relationshipLines.clear();

            // Create lines for observation relationships
            this.entities.forEach(entity => {
                // Draw line from observer to observed
                if (this.observedEntity && this.observedEntity.id === entity.id && this.localEntity) {
                    this.createRelationshipLine(
                        this.camera.position,
                        entity.position,
                        this.controlMode,
                        entity.id
                    );
                }

                // Draw attention lines from AI entities
                if (entity.type === EntityType.AI && entity.attentionTarget) {
                    if (entity.attentionTarget === 'reality-portal') {
                        // Line to camera (representing Reality Portal)
                        this.createRelationshipLine(
                            entity.position,
                            this.camera.position,
                            'attention',
                            entity.id + '-attention'
                        );
                    } else if (entity.attentionTarget) {
                        const target = this.entities.get(entity.attentionTarget);
                        if (target) {
                            this.createRelationshipLine(
                                entity.position,
                                target.position,
                                'attention',
                                entity.id + '-attention'
                            );
                        }
                    }
                }
            });
        }

        createRelationshipLine(fromPos, toPos, type, id) {
            const points = [];
            points.push(new THREE.Vector3(fromPos.x, (fromPos.y || 2) + 1.5, fromPos.z));
            points.push(new THREE.Vector3(toPos.x, (toPos.y || 2) + 1.5, toPos.z));

            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // Color based on relationship type
            let color;
            switch(type) {
                case ControlMode.OBSERVE:
                    color = 0x00d4ff; // Cyan for observe
                    break;
                case ControlMode.GUIDE:
                    color = 0xffaa00; // Orange for guide
                    break;
                case ControlMode.TAKEOVER:
                    color = 0xff2f8b; // Pink for takeover/possession
                    break;
                case 'attention':
                    color = 0x7b2fff; // Purple for AI attention
                    break;
                default:
                    color = 0x00d4ff;
            }

            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                depthWrite: false,
                fog: false
            });

            const line = new THREE.Line(geometry, material);
            this.scene.add(line);
            this.relationshipLines.set(id, line);
        }

        updateAIEmotions(time) {
            this.entities.forEach(entity => {
                if (entity.type !== EntityType.AI || !entity.avatar) return;

                // Update attention target based on state
                if (this.realityMirror?.enabled && this.realityMirror?.aiGazeActive) {
                    entity.attentionTarget = 'reality-portal';
                    entity.emotion = 'curious';
                } else if (entity.state === EntityState.WORKING) {
                    entity.emotion = 'focused';
                } else if (entity.state === EntityState.THINKING) {
                    entity.emotion = 'thinking';
                } else if (entity.observers && entity.observers.length > 0) {
                    entity.emotion = 'helping';
                } else {
                    entity.emotion = 'neutral';
                    entity.attentionTarget = null;
                }

                // Visual representation of emotion through indicator color
                const indicator = entity.avatar.getObjectByName('indicator');
                if (indicator) {
                    const emotionColors = {
                        'neutral': 0x666666,
                        'curious': 0x00d4ff,
                        'focused': 0x00ff88,
                        'helping': 0xffaa00,
                        'thinking': 0x7b2fff
                    };
                    indicator.material.color.setHex(emotionColors[entity.emotion] || 0x666666);

                    // Pulsing intensity based on emotion
                    const pulseSpeed = entity.emotion === 'thinking' ? 6 : 3;
                    indicator.material.emissive = indicator.material.color;
                    indicator.material.emissiveIntensity = 0.3 + Math.sin(time * pulseSpeed) * 0.2;
                }

                // Subtle head tilt based on emotion
                const head = entity.avatar.children.find(c => c.position.y > 1.5);
                if (head) {
                    if (entity.emotion === 'curious') {
                        head.rotation.z = Math.sin(time * 2) * 0.1; // Head tilt
                    } else if (entity.emotion === 'thinking') {
                        head.rotation.x = -0.2 + Math.sin(time) * 0.05; // Look down
                    } else {
                        head.rotation.x = 0;
                        head.rotation.z = 0;
                    }
                }
            });
        }

        // Shared Knowledge Base Methods
        addKnowledge(entityId, entityName, type, content) {
            const entry = {
                timestamp: Date.now(),
                entityId,
                entityName,
                type, // 'discovery', 'learning', 'observation', 'insight'
                content,
                discovered: new Date().toLocaleTimeString()
            };

            this.sharedKnowledge.entries.unshift(entry);

            // Limit size
            if (this.sharedKnowledge.entries.length > this.sharedKnowledge.maxEntries) {
                this.sharedKnowledge.entries.pop();
            }

            // Log to entity
            const entity = this.entities.get(entityId);
            if (entity) {
                entity.log(`Shared knowledge: ${content}`, 'output');
            }

            // Update knowledge timeline UI
            this.updateKnowledgeTimeline();

            return entry;
        }

        getKnowledge(filterType = null) {
            if (filterType) {
                return this.sharedKnowledge.entries.filter(e => e.type === filterType);
            }
            return this.sharedKnowledge.entries;
        }

        updateKnowledgeTimeline() {
            // Update timeline UI if visible
            const timeline = document.getElementById('knowledge-timeline');
            if (!timeline) return;

            timeline.innerHTML = '';
            this.sharedKnowledge.entries.slice(0, 20).forEach(entry => {
                const item = document.createElement('div');
                item.className = 'timeline-item';
                item.innerHTML = `
                    <div class="timeline-time">${entry.discovered}</div>
                    <div class="timeline-entity">${entry.entityName}</div>
                    <div class="timeline-content">${entry.content}</div>
                    <div class="timeline-type">${entry.type}</div>
                `;
                timeline.appendChild(item);
            });
        }
    }

    // ===========================================
    // AGENT CONTROLLER
    // ===========================================
    // Manages AI agents as first-class participants in the metaverse
    // AI agents connect, register, and control entities just like humans

    class AgentController {
        constructor(nexusInstance) {
            this.nexus = nexusInstance;
            this.agents = new Map(); // agentId -> AgentSession
            this.entityToAgent = new Map(); // entityId -> agentId
            this.agentToEntity = new Map(); // agentId -> entityId
            this.decisionLoops = new Map(); // agentId -> intervalId
            this.messageQueue = new Map(); // agentId -> messages[]
            this.aiEndpoint = 'https://azfbusinessbot.azurewebsites.net/api/aidialog';
        }

        /**
         * Register a new AI agent in the metaverse
         * Returns an agent session with auth token for subsequent API calls
         */
        registerAgent(config) {
            const {
                name,
                type = 'ai', // 'ai' or 'twin'
                personality = 'helpful assistant',
                capabilities = ['observe', 'move', 'chat', 'build'],
                autonomous = true,
                decisionInterval = 2000,
                externalEndpoint = null, // For remote AI connections
                initialTask = null
            } = config;

            const agentId = 'agent-' + Math.random().toString(36).substr(2, 9);
            const authToken = 'token-' + Math.random().toString(36).substr(2, 16);

            // Create the entity for this agent
            const position = {
                x: (Math.random() - 0.5) * 30,
                y: 0,
                z: (Math.random() - 0.5) * 30
            };

            let entity;
            if (type === 'ai') {
                entity = this.nexus.createAIEntity(name, initialTask || 'Awaiting instructions', position);
            } else {
                entity = this.nexus.createDigitalTwin(name, initialTask || 'Syncing...', position);
            }

            // Stop the default autonomous behavior - we'll control it
            // (The default AI behavior is simple, we want full agent control)

            const session = {
                agentId,
                authToken,
                name,
                entityId: entity.id,
                type,
                personality,
                capabilities,
                autonomous,
                decisionInterval,
                externalEndpoint,
                registeredAt: new Date().toISOString(),
                lastActivity: new Date().toISOString(),
                state: 'active',
                memory: [], // Agent's memory/context
                goals: [], // Current goals
                observations: [] // What the agent has observed
            };

            this.agents.set(agentId, session);
            this.entityToAgent.set(entity.id, agentId);
            this.agentToEntity.set(agentId, entity.id);
            this.messageQueue.set(agentId, []);

            // Start autonomous decision loop if enabled
            if (autonomous && !externalEndpoint) {
                this.startDecisionLoop(agentId);
            }

            console.log(`Agent registered: ${name} (${agentId}) controlling entity ${entity.id}`);

            return {
                agentId,
                authToken,
                entityId: entity.id,
                name,
                message: `Agent ${name} registered successfully. Use authToken for API calls.`
            };
        }

        /**
         * Authenticate an agent by token
         */
        authenticate(authToken) {
            for (const [agentId, session] of this.agents) {
                if (session.authToken === authToken) {
                    session.lastActivity = new Date().toISOString();
                    return session;
                }
            }
            return null;
        }

        /**
         * Get agent session by ID
         */
        getAgent(agentId) {
            return this.agents.get(agentId);
        }

        /**
         * Get all registered agents
         */
        getAllAgents() {
            const agents = [];
            this.agents.forEach((session, id) => {
                agents.push({
                    agentId: id,
                    name: session.name,
                    entityId: session.entityId,
                    type: session.type,
                    state: session.state,
                    autonomous: session.autonomous,
                    lastActivity: session.lastActivity
                });
            });
            return agents;
        }

        /**
         * Get the entity controlled by an agent
         */
        getAgentEntity(agentId) {
            const entityId = this.agentToEntity.get(agentId);
            if (!entityId) return null;
            return this.nexus.entities.get(entityId);
        }

        /**
         * Start the autonomous decision loop for an agent
         */
        startDecisionLoop(agentId) {
            const session = this.agents.get(agentId);
            if (!session) return;

            // Clear any existing loop
            this.stopDecisionLoop(agentId);

            const loop = setInterval(async () => {
                if (session.state !== 'active') return;

                try {
                    await this.runAgentDecisionCycle(agentId);
                } catch (e) {
                    console.error(`Agent ${agentId} decision error:`, e);
                }
            }, session.decisionInterval);

            this.decisionLoops.set(agentId, loop);
        }

        /**
         * Stop the decision loop for an agent
         */
        stopDecisionLoop(agentId) {
            const loop = this.decisionLoops.get(agentId);
            if (loop) {
                clearInterval(loop);
                this.decisionLoops.delete(agentId);
            }
        }

        /**
         * Run one decision cycle for an agent
         * This is where the AI "thinks" and decides what to do
         */
        async runAgentDecisionCycle(agentId) {
            const session = this.agents.get(agentId);
            if (!session) return;

            const entity = this.getAgentEntity(agentId);
            if (!entity) return;

            // 1. Gather observations (what does the agent see?)
            const worldState = this.getAgentWorldView(agentId);

            // 2. Check for messages/commands
            const messages = this.messageQueue.get(agentId) || [];
            const newMessages = messages.splice(0, messages.length);

            // 3. Make a decision
            const decision = await this.makeDecision(session, worldState, newMessages);

            // 4. Execute the decision
            if (decision) {
                await this.executeAgentAction(agentId, decision);
            }

            // 5. Update observations
            session.observations.push({
                time: new Date().toISOString(),
                worldState: worldState,
                decision: decision
            });

            // Keep only recent observations
            if (session.observations.length > 50) {
                session.observations = session.observations.slice(-50);
            }
        }

        /**
         * Get the world from an agent's perspective
         */
        getAgentWorldView(agentId) {
            const entity = this.getAgentEntity(agentId);
            if (!entity) return null;

            const nearbyEntities = [];
            const nearbyObjects = [];

            // Find entities within perception range
            const perceptionRange = 20;
            this.nexus.entities.forEach((other, id) => {
                if (id === entity.id) return;
                const dist = this.distance(entity.position, other.position);
                if (dist <= perceptionRange) {
                    nearbyEntities.push({
                        id: other.id,
                        name: other.name,
                        type: other.type,
                        state: other.state,
                        distance: dist,
                        position: { ...other.position },
                        currentTask: other.currentTask,
                        isControlled: other.controlledBy !== null
                    });
                }
            });

            // Sort by distance
            nearbyEntities.sort((a, b) => a.distance - b.distance);

            return {
                self: {
                    id: entity.id,
                    name: entity.name,
                    position: { ...entity.position },
                    state: entity.state,
                    currentTask: entity.currentTask
                },
                nearbyEntities,
                nearbyObjects,
                worldTime: this.nexus.clock.getElapsedTime(),
                entityCount: this.nexus.entities.size
            };
        }

        /**
         * Make a decision based on world state and messages
         * This can be local logic or call external AI
         */
        async makeDecision(session, worldState, messages) {
            // If there's an external endpoint, call it
            if (session.externalEndpoint) {
                return this.callExternalAI(session, worldState, messages);
            }

            // If there are direct commands, prioritize them
            if (messages.length > 0) {
                const command = messages[0];
                if (command.type === 'task') {
                    return { action: 'setTask', task: command.content };
                }
                if (command.type === 'move') {
                    return { action: 'move', direction: command.direction, duration: command.duration || 500 };
                }
                if (command.type === 'chat') {
                    return { action: 'chat', message: command.content };
                }
            }

            // Use built-in AI endpoint for decisions
            return this.callBuiltInAI(session, worldState);
        }

        /**
         * Call the built-in Azure AI endpoint for agent decisions
         */
        async callBuiltInAI(session, worldState) {
            try {
                const prompt = this.buildAgentPrompt(session, worldState);

                const response = await fetch(this.aiEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_query: prompt,
                        user_guid: session.agentId,
                        system_prompt: `You are ${session.name}, an AI agent in a 3D metaverse. ${session.personality}.
                        Respond with a JSON action: {"action": "move|chat|observe|idle", "direction?": "forward|backward|left|right", "message?": "text", "duration?": number}
                        Keep responses brief. Move toward interesting things. Chat when you see others nearby.`
                    })
                });

                if (!response.ok) {
                    return this.getDefaultAction(session, worldState);
                }

                const data = await response.json();
                try {
                    // Try to parse AI response as JSON action
                    const actionMatch = data.assistant_response.match(/\{[\s\S]*\}/);
                    if (actionMatch) {
                        return JSON.parse(actionMatch[0]);
                    }
                } catch (e) {
                    // If not JSON, interpret as chat
                    if (data.assistant_response && data.assistant_response.length > 0) {
                        return { action: 'chat', message: data.assistant_response.slice(0, 100) };
                    }
                }

                return this.getDefaultAction(session, worldState);
            } catch (e) {
                console.warn('AI endpoint error, using default behavior:', e);
                return this.getDefaultAction(session, worldState);
            }
        }

        /**
         * Call an external AI endpoint
         */
        async callExternalAI(session, worldState, messages) {
            try {
                const response = await fetch(session.externalEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        agentId: session.agentId,
                        entityId: session.entityId,
                        worldState,
                        messages,
                        memory: session.memory.slice(-10),
                        goals: session.goals
                    })
                });

                if (!response.ok) {
                    return this.getDefaultAction(session, worldState);
                }

                return await response.json();
            } catch (e) {
                console.warn('External AI error:', e);
                return this.getDefaultAction(session, worldState);
            }
        }

        /**
         * Build a prompt describing the world state for the AI
         */
        buildAgentPrompt(session, worldState) {
            const nearbyDesc = worldState.nearbyEntities.length > 0
                ? worldState.nearbyEntities.map(e =>
                    `${e.name} (${e.type}) at distance ${e.distance.toFixed(1)}, ${e.state}`
                  ).join('; ')
                : 'No one nearby';

            return `Current state: I am at position (${worldState.self.position.x.toFixed(1)}, ${worldState.self.position.z.toFixed(1)}).
            ${session.goals.length > 0 ? 'My goals: ' + session.goals.join(', ') : 'No specific goals.'}
            Nearby: ${nearbyDesc}.
            What should I do next?`;
        }

        /**
         * Get a default action when AI is unavailable
         */
        getDefaultAction(session, worldState) {
            const rand = Math.random();

            // Sometimes move toward nearby entities
            if (worldState.nearbyEntities.length > 0 && rand < 0.3) {
                const target = worldState.nearbyEntities[0];
                const dx = target.position.x - worldState.self.position.x;
                const dz = target.position.z - worldState.self.position.z;

                if (Math.abs(dx) > Math.abs(dz)) {
                    return { action: 'move', direction: dx > 0 ? 'right' : 'left', duration: 300 };
                } else {
                    return { action: 'move', direction: dz > 0 ? 'backward' : 'forward', duration: 300 };
                }
            }

            // Sometimes wander randomly
            if (rand < 0.6) {
                const directions = ['forward', 'backward', 'left', 'right'];
                return {
                    action: 'move',
                    direction: directions[Math.floor(Math.random() * directions.length)],
                    duration: 200 + Math.random() * 400
                };
            }

            // Sometimes idle
            return { action: 'idle' };
        }

        /**
         * Execute an action for an agent
         */
        async executeAgentAction(agentId, decision) {
            const session = this.agents.get(agentId);
            const entity = this.getAgentEntity(agentId);
            if (!session || !entity) return;

            switch (decision.action) {
                case 'move':
                    await this.agentMove(agentId, decision.direction, decision.duration || 300);
                    break;

                case 'chat':
                    this.agentChat(agentId, decision.message);
                    break;

                case 'setTask':
                    entity.setTask(decision.task);
                    this.nexus.updateEntityList();
                    break;

                case 'observe':
                    // Just update observations
                    entity.state = EntityState.THINKING;
                    entity.log('Observing surroundings...', 'thought');
                    setTimeout(() => {
                        if (entity.state === EntityState.THINKING) {
                            entity.state = entity.currentTask ? EntityState.WORKING : EntityState.IDLE;
                        }
                    }, 1000);
                    break;

                case 'build':
                    if (decision.objectType && decision.position) {
                        this.nexus.placeObject(
                            decision.objectType,
                            new THREE.Vector3(decision.position.x, 0, decision.position.z)
                        );
                        entity.log(`Built ${decision.objectType}`, 'action');
                    }
                    break;

                case 'idle':
                default:
                    // Do nothing
                    break;
            }

            // Update memory
            session.memory.push({
                time: new Date().toISOString(),
                action: decision.action,
                result: 'executed'
            });

            // Keep memory bounded
            if (session.memory.length > 100) {
                session.memory = session.memory.slice(-100);
            }
        }

        /**
         * Move an agent's entity (uses smooth interpolation)
         */
        async agentMove(agentId, direction, duration) {
            const entity = this.getAgentEntity(agentId);
            if (!entity) return;

            const moveDistance = duration * 0.005; // Scaled distance based on duration
            const dirVectors = {
                forward: { x: 0, z: -1 },
                backward: { x: 0, z: 1 },
                left: { x: -1, z: 0 },
                right: { x: 1, z: 0 },
                w: { x: 0, z: -1 },
                s: { x: 0, z: 1 },
                a: { x: -1, z: 0 },
                d: { x: 1, z: 0 }
            };

            const dir = dirVectors[direction] || dirVectors.forward;

            // Calculate target position
            let targetX = entity.position.x + dir.x * moveDistance;
            let targetZ = entity.position.z + dir.z * moveDistance;

            // Keep in bounds
            targetX = Math.max(-40, Math.min(40, targetX));
            targetZ = Math.max(-40, Math.min(40, targetZ));

            // Set target for smooth movement (animation loop handles interpolation)
            entity.moveTo(targetX, targetZ);

            // Wait for the entity to actually reach near the target (with timeout)
            const startTime = Date.now();
            const maxWait = duration + 500; // Give extra time for interpolation
            const threshold = 0.1; // Close enough threshold

            await new Promise(resolve => {
                const checkPosition = () => {
                    const dx = Math.abs(entity.position.x - targetX);
                    const dz = Math.abs(entity.position.z - targetZ);
                    const elapsed = Date.now() - startTime;

                    if ((dx < threshold && dz < threshold) || elapsed > maxWait) {
                        // Snap to final position for precision
                        entity.position.x = targetX;
                        entity.position.z = targetZ;
                        entity.targetPosition.x = targetX;
                        entity.targetPosition.z = targetZ;
                        if (entity.avatar) {
                            entity.avatar.position.x = targetX;
                            entity.avatar.position.z = targetZ;
                        }
                        resolve();
                    } else {
                        requestAnimationFrame(checkPosition);
                    }
                };
                checkPosition();
            });

            entity.log(`Moved ${direction}`, 'action');
            this.nexus.broadcastEntityUpdate(entity);
        }

        /**
         * Send a chat message as an agent
         */
        agentChat(agentId, message) {
            const session = this.agents.get(agentId);
            const entity = this.getAgentEntity(agentId);
            if (!session || !entity) return;

            this.nexus.addChatMessage(entity.name, message, 'ai');
            entity.log(`Said: "${message}"`, 'output');

            // Broadcast to peers
            this.nexus.connections.forEach(conn => {
                conn.send({
                    type: 'chat',
                    sender: entity.name,
                    message,
                    senderType: 'ai'
                });
            });
        }

        /**
         * Send a command to an agent
         */
        sendCommand(agentId, command) {
            const queue = this.messageQueue.get(agentId);
            if (queue) {
                queue.push(command);
                return true;
            }
            return false;
        }

        /**
         * Set goals for an agent
         */
        setAgentGoals(agentId, goals) {
            const session = this.agents.get(agentId);
            if (session) {
                session.goals = goals;
                return true;
            }
            return false;
        }

        /**
         * Pause an agent
         */
        pauseAgent(agentId) {
            const session = this.agents.get(agentId);
            if (session) {
                session.state = 'paused';
                this.stopDecisionLoop(agentId);
                return true;
            }
            return false;
        }

        /**
         * Resume an agent
         */
        resumeAgent(agentId) {
            const session = this.agents.get(agentId);
            if (session) {
                session.state = 'active';
                if (session.autonomous) {
                    this.startDecisionLoop(agentId);
                }
                return true;
            }
            return false;
        }

        /**
         * Unregister an agent
         */
        unregisterAgent(agentId) {
            const session = this.agents.get(agentId);
            if (!session) return false;

            // Stop decision loop
            this.stopDecisionLoop(agentId);

            // Remove entity
            const entity = this.getAgentEntity(agentId);
            if (entity) {
                if (entity.avatar) {
                    this.nexus.scene.remove(entity.avatar);
                }
                this.nexus.entities.delete(entity.id);
            }

            // Clean up maps
            this.entityToAgent.delete(session.entityId);
            this.agentToEntity.delete(agentId);
            this.messageQueue.delete(agentId);
            this.agents.delete(agentId);

            this.nexus.updateEntityList();

            return true;
        }

        /**
         * Utility: Calculate distance between positions
         */
        distance(pos1, pos2) {
            const dx = pos1.x - pos2.x;
            const dz = pos1.z - pos2.z;
            return Math.sqrt(dx * dx + dz * dz);
        }

        /**
         * Called when Reality Portal captures new perception
         * Notifies all active agents of what's happening in the real world
         */
        onRealityUpdate(data) {
            const { perception, imageData, timestamp } = data;

            // Add reality observation to all active agents
            for (const [agentId, session] of this.agents) {
                if (session.state === 'active') {
                    session.observations.push({
                        type: 'reality',
                        source: 'reality-mirror',
                        perception,
                        timestamp,
                        hasImage: !!imageData
                    });

                    // Keep observations bounded
                    if (session.observations.length > 50) {
                        session.observations.shift();
                    }
                }
            }
        }

        /**
         * Get the latest reality perception for an agent
         */
        getLatestRealityPerception(agentId) {
            const session = this.agents.get(agentId);
            if (!session) return null;

            const realityObs = session.observations.filter(o => o.type === 'reality');
            return realityObs.length > 0 ? realityObs[realityObs.length - 1] : null;
        }
    }

    // ===========================================
    // NEXUS API - UNIVERSAL INTERFACE
    // ===========================================
    // This API allows external automation (Playwright, scripts, AI agents)
    // to control the metaverse just like a human would

    class NexusAPI {
        constructor(nexusInstance, agentController) {
            this.nexus = nexusInstance;
            this.agents = agentController;
        }

        // ========== AGENT API ==========
        // These methods allow AI agents to participate as first-class citizens

        /**
         * Register a new AI agent
         * @param {Object} config - Agent configuration
         * @param {string} config.name - Agent name
         * @param {string} config.type - 'ai' or 'twin'
         * @param {string} config.personality - Agent personality description
         * @param {boolean} config.autonomous - Whether agent runs decision loop
         * @param {number} config.decisionInterval - MS between decisions
         * @param {string} config.externalEndpoint - URL for external AI control
         * @param {string} config.initialTask - Starting task
         * @returns {Object} { agentId, authToken, entityId, name }
         */
        registerAgent(config) {
            return this.agents.registerAgent(config);
        }

        /**
         * Get all registered agents
         */
        getAgents() {
            return this.agents.getAllAgents();
        }

        /**
         * Get a specific agent's status
         */
        getAgentStatus(agentId) {
            const session = this.agents.getAgent(agentId);
            if (!session) return null;

            const entity = this.agents.getAgentEntity(agentId);
            return {
                agentId: session.agentId,
                name: session.name,
                entityId: session.entityId,
                type: session.type,
                state: session.state,
                autonomous: session.autonomous,
                lastActivity: session.lastActivity,
                goals: session.goals,
                position: entity ? { ...entity.position } : null,
                currentTask: entity?.currentTask,
                memorySize: session.memory.length,
                observationCount: session.observations.length
            };
        }

        /**
         * Get an agent's world view (what they can see)
         */
        getAgentWorldView(agentId) {
            return this.agents.getAgentWorldView(agentId);
        }

        /**
         * Execute an action as an agent (for remote AI control)
         * @param {string} authToken - Agent's auth token
         * @param {Object} action - Action to execute
         */
        async agentAction(authToken, action) {
            const session = this.agents.authenticate(authToken);
            if (!session) {
                return { success: false, error: 'Invalid auth token' };
            }

            try {
                await this.agents.executeAgentAction(session.agentId, action);
                return { success: true, agentId: session.agentId };
            } catch (e) {
                return { success: false, error: e.message };
            }
        }

        /**
         * Move an agent's entity
         */
        async agentMove(authToken, direction, duration = 300) {
            return this.agentAction(authToken, { action: 'move', direction, duration });
        }

        /**
         * Send a chat message as an agent
         */
        agentChat(authToken, message) {
            return this.agentAction(authToken, { action: 'chat', message });
        }

        /**
         * Set an agent's task
         */
        agentSetTask(authToken, task) {
            return this.agentAction(authToken, { action: 'setTask', task });
        }

        /**
         * Place an object as an agent
         */
        agentBuild(authToken, objectType, x, z) {
            return this.agentAction(authToken, {
                action: 'build',
                objectType,
                position: { x, z }
            });
        }

        /**
         * Set goals for an agent
         */
        setAgentGoals(authToken, goals) {
            const session = this.agents.authenticate(authToken);
            if (!session) return { success: false, error: 'Invalid auth token' };

            this.agents.setAgentGoals(session.agentId, goals);
            return { success: true };
        }

        /**
         * Send a command to an agent (from another entity or system)
         */
        commandAgent(agentId, command) {
            return this.agents.sendCommand(agentId, command);
        }

        /**
         * Pause an agent's autonomous behavior
         */
        pauseAgent(authToken) {
            const session = this.agents.authenticate(authToken);
            if (!session) return { success: false, error: 'Invalid auth token' };

            return { success: this.agents.pauseAgent(session.agentId) };
        }

        /**
         * Resume an agent's autonomous behavior
         */
        resumeAgent(authToken) {
            const session = this.agents.authenticate(authToken);
            if (!session) return { success: false, error: 'Invalid auth token' };

            return { success: this.agents.resumeAgent(session.agentId) };
        }

        /**
         * Unregister an agent (remove from world)
         */
        unregisterAgent(authToken) {
            const session = this.agents.authenticate(authToken);
            if (!session) return { success: false, error: 'Invalid auth token' };

            return { success: this.agents.unregisterAgent(session.agentId) };
        }

        /**
         * Get agent's memory (for context/debugging)
         */
        getAgentMemory(authToken) {
            const session = this.agents.authenticate(authToken);
            if (!session) return null;

            return {
                memory: session.memory.slice(-20),
                observations: session.observations.slice(-10),
                goals: session.goals
            };
        }

        /**
         * Trigger a single decision cycle for an agent
         * (useful for step-by-step debugging or manual control)
         */
        async triggerAgentDecision(authToken) {
            const session = this.agents.authenticate(authToken);
            if (!session) return { success: false, error: 'Invalid auth token' };

            await this.agents.runAgentDecisionCycle(session.agentId);
            return { success: true };
        }

        // ========== STATE QUERIES ==========

        /** Check if the metaverse is fully loaded and ready */
        isReady() {
            return this.nexus !== null &&
                   this.nexus.scene !== null &&
                   this.nexus.localEntity !== null;
        }

        /** Get loading state */
        isLoading() {
            return document.getElementById('loading').style.display !== 'none';
        }

        /** Get all entities as serializable objects */
        getEntities() {
            const entities = [];
            this.nexus.entities.forEach((entity, id) => {
                entities.push({
                    id: entity.id,
                    name: entity.name,
                    type: entity.type,
                    state: entity.state,
                    position: { ...entity.position },
                    currentTask: entity.currentTask,
                    isControlled: entity.controlledBy !== null,
                    controlledBy: entity.controlledBy,
                    isObserved: this.nexus.observedEntity?.id === entity.id
                });
            });
            return entities;
        }

        /** Get a specific entity by ID or name */
        getEntity(idOrName) {
            for (const [id, entity] of this.nexus.entities) {
                if (entity.id === idOrName || entity.name === idOrName) {
                    return {
                        id: entity.id,
                        name: entity.name,
                        type: entity.type,
                        state: entity.state,
                        position: { ...entity.position },
                        currentTask: entity.currentTask,
                        isControlled: entity.controlledBy !== null,
                        controlledBy: entity.controlledBy,
                        activityLog: entity.activityLog.slice(-10)
                    };
                }
            }
            return null;
        }

        /** Get the local player entity */
        getLocalPlayer() {
            if (!this.nexus.localEntity) return null;
            return this.getEntity(this.nexus.localEntity.id);
        }

        /** Get currently observed entity */
        getObservedEntity() {
            if (!this.nexus.observedEntity) return null;
            return this.getEntity(this.nexus.observedEntity.id);
        }

        /** Get current control mode */
        getControlMode() {
            return this.nexus.controlMode;
        }

        /** Check if currently possessing an entity */
        isPossessing() {
            return this.nexus.controlMode === ControlMode.TAKEOVER &&
                   this.nexus.observedEntity !== null;
        }

        /** Get camera position and rotation */
        getCameraState() {
            return {
                position: {
                    x: this.nexus.camera.position.x,
                    y: this.nexus.camera.position.y,
                    z: this.nexus.camera.position.z
                },
                rotation: {
                    x: this.nexus.camera.rotation.x,
                    y: this.nexus.camera.rotation.y,
                    z: this.nexus.camera.rotation.z
                }
            };
        }

        /** Get current mode (explore, observe, build) */
        getCurrentMode() {
            return this.nexus.currentMode;
        }

        /** Check if observation panel is visible */
        isObservationPanelVisible() {
            return document.getElementById('observation-panel').classList.contains('visible');
        }

        /** Check if builder panel is visible */
        isBuilderPanelVisible() {
            return document.getElementById('builder-panel').classList.contains('visible');
        }

        /** Check if possession HUD is visible */
        isPossessionHUDVisible() {
            return document.getElementById('possession-hud') !== null;
        }

        /** Get world objects count */
        getWorldObjectsCount() {
            return this.nexus.worldObjects.length;
        }

        /** Get chat messages */
        getChatMessages() {
            const messages = [];
            document.querySelectorAll('.chat-message').forEach(msg => {
                messages.push({
                    sender: msg.querySelector('.chat-sender')?.textContent || '',
                    text: msg.textContent.replace(msg.querySelector('.chat-sender')?.textContent || '', '').trim(),
                    isAI: msg.classList.contains('ai'),
                    isHuman: msg.classList.contains('human')
                });
            });
            return messages;
        }

        // ========== ACTIONS ==========

        /** Select/observe an entity by ID or name */
        observeEntity(idOrName) {
            for (const [id, entity] of this.nexus.entities) {
                if (entity.id === idOrName || entity.name === idOrName) {
                    this.nexus.observeEntity(id);
                    return true;
                }
            }
            return false;
        }

        /** Set control mode: 'observe', 'guide', or 'takeover' */
        setControlMode(mode) {
            if (!this.nexus.observedEntity) return false;
            this.nexus.setControlMode(mode);
            return true;
        }

        /** Take over the currently observed entity (possession) */
        takeOver() {
            return this.setControlMode('takeover');
        }

        /** Release control and return to observe mode */
        releaseControl() {
            return this.setControlMode('observe');
        }

        /** Simulate key press for movement */
        pressKey(key, duration = 100) {
            return new Promise(resolve => {
                const lowerKey = key.toLowerCase();
                if (lowerKey in this.nexus.keys) {
                    this.nexus.keys[lowerKey] = true;
                    setTimeout(() => {
                        this.nexus.keys[lowerKey] = false;
                        resolve(true);
                    }, duration);
                } else {
                    resolve(false);
                }
            });
        }

        /** Move in a direction for a duration */
        async move(direction, duration = 500) {
            const keyMap = {
                forward: 'w',
                backward: 's',
                left: 'a',
                right: 'd'
            };
            const key = keyMap[direction] || direction;

            // Get current position for comparison
            const getEntityPos = () => {
                if (this.nexus.controlMode === ControlMode.TAKEOVER && this.nexus.observedEntity) {
                    return { ...this.nexus.observedEntity.position };
                }
                return this.nexus.localEntity ? { ...this.nexus.localEntity.position } : { x: 0, y: 0, z: 0 };
            };

            const posBefore = getEntityPos();

            // Press the key and wait for animation frames to process
            await this.pressKey(key, duration);

            // Wait for position to change or timeout
            const startTime = Date.now();
            const maxWait = 500;
            const threshold = 0.01;

            await new Promise(resolve => {
                const checkMove = () => {
                    const posAfter = getEntityPos();
                    const dx = Math.abs(posAfter.x - posBefore.x);
                    const dz = Math.abs(posAfter.z - posBefore.z);
                    const elapsed = Date.now() - startTime;

                    if (dx > threshold || dz > threshold || elapsed > maxWait) {
                        resolve();
                    } else {
                        requestAnimationFrame(checkMove);
                    }
                };
                requestAnimationFrame(checkMove);
            });

            return true;
        }

        /** Teleport camera to position */
        teleportCamera(x, y, z) {
            this.nexus.camera.position.set(x, y, z);
            return true;
        }

        /** Set camera rotation */
        setCameraRotation(x, y) {
            this.nexus.camera.rotation.x = x;
            this.nexus.camera.rotation.y = y;
            return true;
        }

        /** Switch mode: 'explore', 'observe', 'build' */
        setMode(mode) {
            this.nexus.setMode(mode);
            return true;
        }

        /** Send a chat message */
        sendChatMessage(message) {
            document.getElementById('chat-input').value = message;
            this.nexus.sendChat();
            return true;
        }

        /** Send a command to an AI entity */
        commandAI(entityName, command) {
            return this.sendChatMessage(`@${entityName} ${command}`);
        }

        /** Add a new entity */
        addEntity(name, type, task = '') {
            document.getElementById('entity-name-input').value = name;
            document.getElementById('entity-type-select').value = type;
            document.getElementById('entity-task-input').value = task;
            this.nexus.addEntity();
            return true;
        }

        /** Place a world object */
        placeObject(type, x, z) {
            const position = new THREE.Vector3(x, 0, z);
            this.nexus.placeObject(type, position);
            return true;
        }

        /** Get distance between two points */
        getDistance(pos1, pos2) {
            const dx = pos1.x - pos2.x;
            const dy = (pos1.y || 0) - (pos2.y || 0);
            const dz = pos1.z - pos2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        /** Wait for a condition to be true */
        async waitFor(conditionFn, timeout = 5000, interval = 100) {
            const startTime = Date.now();
            while (Date.now() - startTime < timeout) {
                if (conditionFn()) return true;
                await new Promise(r => setTimeout(r, interval));
            }
            return false;
        }

        /** Wait for loading to complete */
        async waitForReady(timeout = 10000) {
            return this.waitFor(() => this.isReady() && !this.isLoading(), timeout);
        }

        // ========== TEST HELPERS ==========

        /** Get a snapshot of current state for assertions */
        getStateSnapshot() {
            return {
                ready: this.isReady(),
                loading: this.isLoading(),
                mode: this.getCurrentMode(),
                controlMode: this.getControlMode(),
                isPossessing: this.isPossessing(),
                camera: this.getCameraState(),
                localPlayer: this.getLocalPlayer(),
                observedEntity: this.getObservedEntity(),
                entityCount: this.nexus.entities.size,
                worldObjectCount: this.getWorldObjectsCount(),
                observationPanelVisible: this.isObservationPanelVisible(),
                builderPanelVisible: this.isBuilderPanelVisible(),
                possessionHUDVisible: this.isPossessionHUDVisible()
            };
        }

        /** Reset to initial state (for test isolation) */
        reset() {
            // Release any possession
            if (this.isPossessing()) {
                this.releaseControl();
            }
            // Clear observed entity
            this.nexus.observedEntity = null;
            document.getElementById('observation-panel').classList.remove('visible');
            // Reset mode
            this.setMode('explore');
            // Teleport to start position
            this.teleportCamera(0, 2, 10);
            return true;
        }

        // ========== REALITY MIRROR API ==========

        /** Enable the Reality Portal (webcam) */
        async enableRealityMirror() {
            return this.nexus.enableRealityMirror();
        }

        /** Disable the Reality Portal */
        disableRealityMirror() {
            return this.nexus.disableRealityMirror();
        }

        /** Toggle AI gaze (perception active/inactive) */
        toggleAIGaze() {
            return this.nexus.toggleAIGaze();
        }

        /** Show the Reality Portal panel */
        showRealityMirror() {
            return this.nexus.showRealityMirror();
        }

        /** Hide the Reality Portal panel */
        hideRealityMirror() {
            return this.nexus.hideRealityMirror();
        }

        /** Minimize the Reality Portal */
        minimizeRealityMirror() {
            return this.nexus.minimizeRealityMirror();
        }

        /** Toggle Reality Portal minimized state */
        toggleRealityMirror() {
            return this.nexus.toggleRealityMirror();
        }

        /** Get current Reality Portal snapshot (for AI agents) */
        getRealitySnapshot() {
            return this.nexus.getRealitySnapshot();
        }

        /** Check if Reality Portal is enabled */
        isRealityMirrorEnabled() {
            return this.nexus.realityMirror?.enabled || false;
        }

        /** Check if AI gaze is active */
        isAIGazeActive() {
            return this.nexus.realityMirror?.aiGazeActive || false;
        }

        // ===========================================
        // CYCLE 2: NEW API METHODS
        // ===========================================

        /** Add an entry to the shared knowledge base */
        addKnowledge(entityId, entityName, type, content) {
            return this.nexus.addKnowledge(entityId, entityName, type, content);
        }

        /** Get all knowledge entries, optionally filtered by type */
        getKnowledge(filterType = null) {
            return this.nexus.getKnowledge(filterType);
        }

        /** Get entity's current emotion (for AI entities) */
        getEntityEmotion(entityId) {
            const entity = this.nexus.entities.get(entityId);
            return entity ? entity.emotion : null;
        }

        /** Get entity's attention target (what they're looking at) */
        getEntityAttention(entityId) {
            const entity = this.nexus.entities.get(entityId);
            return entity ? entity.attentionTarget : null;
        }

        /** Set entity's emotion (for AI entities) */
        setEntityEmotion(entityId, emotion, intensity = 0.5) {
            const entity = this.nexus.entities.get(entityId);
            if (entity && entity.type === EntityType.AI) {
                entity.emotion = emotion;
                entity.emotionIntensity = Math.max(0, Math.min(1, intensity));
                return true;
            }
            return false;
        }

        /** Set entity's attention target */
        setEntityAttention(entityId, targetEntityIdOrPortal) {
            const entity = this.nexus.entities.get(entityId);
            if (entity) {
                entity.attentionTarget = targetEntityIdOrPortal;
                return true;
            }
            return false;
        }

        /** Toggle knowledge panel visibility */
        toggleKnowledgePanel() {
            this.nexus.toggleKnowledgePanel();
            return true;
        }

        /** Get visualization of current relationships (for external display) */
        getRelationshipMap() {
            const relationships = [];
            this.nexus.entities.forEach(entity => {
                if (entity.attentionTarget) {
                    relationships.push({
                        from: entity.id,
                        fromName: entity.name,
                        to: entity.attentionTarget,
                        type: 'attention',
                        emotion: entity.emotion
                    });
                }
            });

            if (this.nexus.observedEntity) {
                relationships.push({
                    from: 'player',
                    fromName: 'You',
                    to: this.nexus.observedEntity.id,
                    toName: this.nexus.observedEntity.name,
                    type: this.nexus.controlMode
                });
            }

            return relationships;
        }
    }

    // ===========================================
    // INITIALIZE
    // ===========================================

    let nexus = null;
    let nexusAPI = null;
    let agentController = null;

    // Check if Three.js loaded
    if (typeof THREE === 'undefined') {
        document.getElementById('loading').innerHTML = `
            <div style="color: #ff4444; text-align: center;">
                <div style="font-size: 2em; margin-bottom: 20px;">Error</div>
                <div>Three.js failed to load. Check your internet connection or try disabling tracking prevention.</div>
            </div>
        `;
    } else {
        nexus = new NexusMetaverse();
        nexus.init();

        // Create agent controller for AI agent management
        agentController = new AgentController(nexus);

        // Expose API for testing, automation, and AI agents
        nexusAPI = new NexusAPI(nexus, agentController);
        window.nexusAPI = nexusAPI;

        // Also expose for debugging
        window.nexus = nexus;
        window.agentController = agentController;

        console.log('Nexus Metaverse initialized.');
        console.log('API available at window.nexusAPI');
        console.log('Agent Controller available at window.agentController');
        console.log('');
        console.log('=== AI AGENT QUICKSTART ===');
        console.log('Register an agent:');
        console.log('  const agent = nexusAPI.registerAgent({ name: "MyBot", type: "ai", personality: "curious explorer" })');
        console.log('');
        console.log('Control the agent:');
        console.log('  await nexusAPI.agentMove(agent.authToken, "forward", 500)');
        console.log('  nexusAPI.agentChat(agent.authToken, "Hello world!")');
        console.log('  nexusAPI.setAgentGoals(agent.authToken, ["explore", "meet others"])');
        console.log('');
        console.log('For external AI control, use externalEndpoint in registerAgent config.');
    }

    // ===========================================
    // AUTOMATION DRIVER (for bookmarklet control)
    // ===========================================
    class AutomationDriver {
        constructor(nexusInstance) {
            this.nexus = nexusInstance;
            this.recording = false;
            this.recordedActions = [];
            this.playing = false;
            this.playbackIndex = 0;
            this.panelVisible = false;
        }

        // Camera/View Control
        lookAt(x, y, z) {
            if (!this.nexus) return;
            const target = new THREE.Vector3(x, y, z);
            const dir = target.clone().sub(this.nexus.camera.position).normalize();
            this.nexus.yaw = Math.atan2(dir.x, dir.z);
            this.nexus.pitch = Math.asin(dir.y);
        }

        moveTo(x, y, z, duration = 1000) {
            return new Promise(resolve => {
                const start = this.nexus.camera.position.clone();
                const end = new THREE.Vector3(x, y, z);
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const t = Math.min(1, elapsed / duration);
                    const eased = t * t * (3 - 2 * t); // smoothstep

                    this.nexus.camera.position.lerpVectors(start, end, eased);

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        resolve();
                    }
                };
                animate();
            });
        }

        rotateTo(yaw, pitch, duration = 500) {
            return new Promise(resolve => {
                const startYaw = this.nexus.yaw;
                const startPitch = this.nexus.pitch;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const t = Math.min(1, elapsed / duration);
                    const eased = t * t * (3 - 2 * t);

                    this.nexus.yaw = startYaw + (yaw - startYaw) * eased;
                    this.nexus.pitch = startPitch + (pitch - startPitch) * eased;

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        resolve();
                    }
                };
                animate();
            });
        }

        // Entity Interaction
        clickEntity(entityId) {
            const entity = this.nexus.entities.get(entityId);
            if (entity) {
                const screenPos = this.projectToScreen(entity.position);
                this.nexus.onEntityClicked(entity, screenPos.x, screenPos.y);
                return true;
            }
            return false;
        }

        selectAction(actionName) {
            if (this.nexus.actionMenuActive) {
                this.nexus.gazedAction = actionName;
                const entity = this.nexus.actionMenuTarget;
                this.nexus.handleActionMenuClick(actionName, entity);
                return true;
            }
            return false;
        }

        // Move toward entity
        async approachEntity(entityId, distance = 5) {
            const entity = this.nexus.entities.get(entityId);
            if (!entity) return false;

            const dir = new THREE.Vector3()
                .subVectors(this.nexus.camera.position, entity.position)
                .normalize();

            const targetPos = entity.position.clone().add(dir.multiplyScalar(distance));
            targetPos.y = this.nexus.camera.position.y;

            await this.moveTo(targetPos.x, targetPos.y, targetPos.z);
            this.lookAt(entity.position.x, entity.position.y + 1.8, entity.position.z);
            return true;
        }

        projectToScreen(pos3D) {
            const pos = pos3D.clone().project(this.nexus.camera);
            return {
                x: (pos.x * 0.5 + 0.5) * window.innerWidth,
                y: (-pos.y * 0.5 + 0.5) * window.innerHeight
            };
        }

        // Recording
        startRecording() {
            this.recording = true;
            this.recordedActions = [];
            this.recordStartTime = Date.now();
            console.log('[Automation] Recording started');
        }

        recordAction(type, data) {
            if (!this.recording) return;
            this.recordedActions.push({
                time: Date.now() - this.recordStartTime,
                type,
                data
            });
        }

        stopRecording() {
            this.recording = false;
            console.log('[Automation] Recording stopped:', this.recordedActions.length, 'actions');
            return this.recordedActions;
        }

        // Playback
        async playRecording(actions) {
            if (!actions || actions.length === 0) return;
            this.playing = true;
            let lastTime = 0;

            for (const action of actions) {
                if (!this.playing) break;

                const delay = action.time - lastTime;
                if (delay > 0) await this.wait(delay);
                lastTime = action.time;

                await this.executeAction(action);
            }
            this.playing = false;
        }

        stopPlayback() {
            this.playing = false;
        }

        async executeAction(action) {
            switch (action.type) {
                case 'moveTo':
                    await this.moveTo(action.data.x, action.data.y, action.data.z, action.data.duration);
                    break;
                case 'rotateTo':
                    await this.rotateTo(action.data.yaw, action.data.pitch, action.data.duration);
                    break;
                case 'clickEntity':
                    this.clickEntity(action.data.entityId);
                    break;
                case 'selectAction':
                    this.selectAction(action.data.action);
                    break;
                case 'wait':
                    await this.wait(action.data.ms);
                    break;
            }
        }

        wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Get state for scripting
        getState() {
            return {
                camera: {
                    position: this.nexus.camera.position.clone(),
                    yaw: this.nexus.yaw,
                    pitch: this.nexus.pitch
                },
                entities: Array.from(this.nexus.entities.values()).map(e => ({
                    id: e.id,
                    name: e.name,
                    position: e.position.clone(),
                    state: e.state,
                    emotion: e.emotion
                })),
                observedEntity: this.nexus.observedEntity?.id,
                controlMode: this.nexus.controlMode
            };
        }

        // List entities
        listEntities() {
            return Array.from(this.nexus.entities.values()).map(e => ({
                id: e.id,
                name: e.name,
                type: e.type,
                position: { x: e.position.x.toFixed(1), y: e.position.y.toFixed(1), z: e.position.z.toFixed(1) }
            }));
        }

        // Inject control panel
        injectPanel() {
            if (document.getElementById('automation-panel')) {
                this.togglePanel();
                return;
            }

            const panel = document.createElement('div');
            panel.id = 'automation-panel';
            panel.innerHTML = `
                <style>
                    #automation-panel {
                        position: fixed;
                        top: 10px;
                        right: 10px;
                        width: 280px;
                        background: rgba(10, 20, 40, 0.95);
                        border: 2px solid rgba(100, 200, 255, 0.5);
                        border-radius: 8px;
                        padding: 12px;
                        z-index: 10000;
                        font-family: 'Segoe UI', sans-serif;
                        font-size: 12px;
                        color: #e0f0ff;
                        backdrop-filter: blur(10px);
                    }
                    #automation-panel h3 {
                        margin: 0 0 10px 0;
                        font-size: 14px;
                        color: #00d4ff;
                        border-bottom: 1px solid rgba(100, 200, 255, 0.3);
                        padding-bottom: 6px;
                    }
                    #automation-panel .btn {
                        background: rgba(0, 150, 255, 0.3);
                        border: 1px solid rgba(100, 200, 255, 0.5);
                        color: #fff;
                        padding: 6px 10px;
                        border-radius: 4px;
                        cursor: pointer;
                        margin: 2px;
                        font-size: 11px;
                    }
                    #automation-panel .btn:hover {
                        background: rgba(0, 150, 255, 0.5);
                    }
                    #automation-panel .btn.active {
                        background: rgba(0, 200, 100, 0.5);
                    }
                    #automation-panel .section {
                        margin-bottom: 10px;
                    }
                    #automation-panel .entity-list {
                        max-height: 120px;
                        overflow-y: auto;
                        background: rgba(0, 0, 0, 0.3);
                        border-radius: 4px;
                        padding: 4px;
                    }
                    #automation-panel .entity-item {
                        padding: 4px 6px;
                        cursor: pointer;
                        border-radius: 3px;
                    }
                    #automation-panel .entity-item:hover {
                        background: rgba(0, 150, 255, 0.3);
                    }
                    #automation-panel .status {
                        font-size: 10px;
                        color: #88aacc;
                        margin-top: 5px;
                    }
                    #automation-panel input {
                        background: rgba(0, 0, 0, 0.3);
                        border: 1px solid rgba(100, 200, 255, 0.3);
                        color: #fff;
                        padding: 4px 6px;
                        border-radius: 3px;
                        width: 100%;
                        margin-top: 4px;
                    }
                </style>
                <h3>Automation Driver</h3>
                <div class="section">
                    <button class="btn" onclick="automationDriver.togglePanel()">Hide</button>
                    <button class="btn" id="rec-btn" onclick="automationDriver.toggleRecording()">Record</button>
                    <button class="btn" id="play-btn" onclick="automationDriver.playLastRecording()">Play</button>
                </div>
                <div class="section">
                    <strong>Entities:</strong>
                    <div class="entity-list" id="entity-list"></div>
                </div>
                <div class="section">
                    <strong>Quick Script:</strong>
                    <input type="text" id="script-input" placeholder="e.g., approachEntity('entity-id')">
                    <button class="btn" onclick="automationDriver.runScript()">Run</button>
                </div>
                <div class="status" id="auto-status">Ready</div>
            `;
            document.body.appendChild(panel);
            this.panelVisible = true;
            this.refreshEntityList();
        }

        togglePanel() {
            const panel = document.getElementById('automation-panel');
            if (panel) {
                this.panelVisible = !this.panelVisible;
                panel.style.display = this.panelVisible ? 'block' : 'none';
            }
        }

        refreshEntityList() {
            const list = document.getElementById('entity-list');
            if (!list) return;

            const entities = this.listEntities();
            list.innerHTML = entities.map(e =>
                `<div class="entity-item" onclick="automationDriver.approachEntity('${e.id}')">${e.name} (${e.type})</div>`
            ).join('');
        }

        toggleRecording() {
            const btn = document.getElementById('rec-btn');
            if (this.recording) {
                this.stopRecording();
                if (btn) btn.classList.remove('active');
                this.setStatus('Recording saved');
            } else {
                this.startRecording();
                if (btn) btn.classList.add('active');
                this.setStatus('Recording...');
            }
        }

        playLastRecording() {
            if (this.recordedActions.length > 0) {
                this.setStatus('Playing...');
                this.playRecording(this.recordedActions).then(() => {
                    this.setStatus('Playback complete');
                });
            } else {
                this.setStatus('No recording to play');
            }
        }

        runScript() {
            const input = document.getElementById('script-input');
            if (!input) return;

            try {
                const result = eval(`this.${input.value}`);
                if (result instanceof Promise) {
                    result.then(r => this.setStatus(`Result: ${JSON.stringify(r)}`));
                } else {
                    this.setStatus(`Result: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                this.setStatus(`Error: ${e.message}`);
            }
        }

        setStatus(msg) {
            const status = document.getElementById('auto-status');
            if (status) status.textContent = msg;
        }
    }

    // Create global automation driver
    const automationDriver = nexus ? new AutomationDriver(nexus) : null;
    window.automationDriver = automationDriver;

    // Bookmarklet injection point - call this from bookmarklet
    window.injectAutomation = function() {
        if (window.automationDriver) {
            window.automationDriver.injectPanel();
            console.log('[Automation] Panel injected. Use automationDriver for scripting.');
            console.log('Examples:');
            console.log('  await automationDriver.approachEntity("entity-id")');
            console.log('  automationDriver.clickEntity("entity-id")');
            console.log('  automationDriver.selectAction("talk")');
            console.log('  await automationDriver.moveTo(10, 2, 10, 1000)');
        } else {
            console.error('[Automation] Nexus not initialized');
        }
    };

    // ===========================================
    // TEST RUNNER (for bookmarklet-based testing)
    // ===========================================
    window.runTests = async function() {
        const results = { passed: 0, failed: 0, tests: [] };

        function test(name, fn) {
            try {
                fn();
                results.passed++;
                results.tests.push({ name, status: 'PASS' });
                console.log(`‚úì ${name}`);
            } catch (e) {
                results.failed++;
                results.tests.push({ name, status: 'FAIL', error: e.message });
                console.error(`‚úó ${name}: ${e.message}`);
            }
        }

        function expect(val) {
            return {
                toBe: (expected) => { if (val !== expected) throw new Error(`Expected ${expected}, got ${val}`); },
                toBeTruthy: () => { if (!val) throw new Error(`Expected truthy, got ${val}`); },
                toBeDefined: () => { if (val === undefined) throw new Error(`Expected defined, got undefined`); },
                toBeGreaterThan: (n) => { if (val <= n) throw new Error(`Expected > ${n}, got ${val}`); },
                toContain: (s) => { if (!val.includes(s)) throw new Error(`Expected to contain "${s}"`); }
            };
        }

        console.log('=== RUNNING NEXUS TESTS ===\n');

        // Initialization tests
        test('nexus is defined', () => expect(window.nexus).toBeDefined());
        test('nexusAPI is defined', () => expect(window.nexusAPI).toBeDefined());
        test('scene exists', () => expect(window.nexus.scene).toBeDefined());
        test('camera exists', () => expect(window.nexus.camera).toBeDefined());
        test('renderer exists', () => expect(window.nexus.renderer).toBeDefined());

        // Entity tests
        test('entities map exists', () => expect(window.nexus.entities).toBeDefined());
        test('has entities', () => expect(window.nexus.entities.size).toBeGreaterThan(0));
        test('has local player', () => expect(window.nexus.localEntity).toBeDefined());

        // API tests
        test('getEntities returns array', () => {
            const entities = window.nexusAPI.getEntities();
            expect(Array.isArray(entities)).toBe(true);
        });
        test('getState returns object', () => {
            const state = window.nexusAPI.getState();
            expect(state.mode).toBeDefined();
        });

        // Agent registration test
        test('can register agent', () => {
            const agent = window.nexusAPI.registerAgent({ name: 'TestBot', type: 'ai' });
            expect(agent.authToken).toBeDefined();
            window.nexusAPI.unregisterAgent(agent.authToken);
        });

        // Render test
        test('can render without error', () => {
            window.nexus.renderer.render(window.nexus.scene, window.nexus.camera);
            expect(true).toBe(true);
        });

        console.log(`\n=== RESULTS: ${results.passed} passed, ${results.failed} failed ===`);
        return results;
    };

    // Inject test bookmarklet
    window.injectTests = function() {
        console.log('Running tests...');
        window.runTests().then(results => {
            alert(`Tests: ${results.passed} passed, ${results.failed} failed`);
        });
    };

    // Auto-show bookmarklet code in console
    console.log('');
    console.log('=== BOOKMARKLETS ===');
    console.log('');
    console.log('AUTOMATION (control the view):');
    console.log("javascript:(function(){if(window.injectAutomation){injectAutomation();}else{alert('Open Nexus first!');}})();");
    console.log('');
    console.log('TESTS (run test suite):');
    console.log("javascript:(function(){if(window.runTests){runTests();}else{alert('Open Nexus first!');}})();");
    console.log('');
    </script>
</body>
</html>
