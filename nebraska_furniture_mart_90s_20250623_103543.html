<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <title>Nebraska Furniture Mart 90s</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
        -webkit-overflow-scrolling: touch;
      }

      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      .world-ui {
        position: absolute;
        top: env(safe-area-inset-top, 20px);
        left: env(safe-area-inset-left, 20px);
        z-index: 1001;
        pointer-events: none;
      }

      .world-title {
        font-size: 3em;
        font-weight: 100;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        background: linear-gradient(45deg, #2e5a74, #d0b783, #879195, #ffd700);
        background-size: 400% 100%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: shimmer 8s ease-in-out infinite;
        margin-bottom: 10px;
        text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      }

      @keyframes shimmer {
        0%,
        100% {
          background-position: 0% 50%;
          filter: hue-rotate(0deg);
        }
        50% {
          background-position: 100% 50%;
          filter: hue-rotate(30deg);
        }
      }

      .world-description {
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.6);
        max-width: 400px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }

      .world-origin {
        position: absolute;
        top: env(safe-area-inset-top, 20px);
        right: env(safe-area-inset-right, 20px);
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: none;
      }

      .world-origin.visible {
        display: block;
      }

      .origin-label {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.8em;
      }

      .origin-world {
        color: #2e5a74;
        font-weight: 500;
      }

      .controls-hint {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 30px);
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        padding: 15px 30px;
        border-radius: 25px;
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        text-align: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        pointer-events: none;
      }

      .portal-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid transparent;
        border-image: linear-gradient(45deg, #2e5a74, #d0b783, #879195) 1;
        border-radius: 15px;
        padding: 20px;
        max-width: 300px;
        display: none;
        z-index: 1002;
        pointer-events: none;
        backdrop-filter: blur(10px);
      }

      .portal-tooltip.visible {
        display: block;
      }

      .tooltip-title {
        font-size: 1.4em;
        font-weight: 300;
        margin-bottom: 10px;
        background: linear-gradient(45deg, #2e5a74, #d0b783);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .tooltip-description {
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.5;
      }

      .tooltip-instruction {
        font-size: 0.85em;
        color: #879195;
        text-align: center;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .mobile-controls {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
        left: 0;
        right: 0;
        display: none;
        z-index: 1001;
        padding: 0 20px;
        pointer-events: none;
      }

      .mobile-controls.show {
        display: block;
      }

      .controls-container {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
      }

      .joystick-container {
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(46, 90, 116, 0.5);
        border-radius: 50%;
        position: relative;
        pointer-events: auto;
        touch-action: none;
        box-shadow: 0 0 20px rgba(46, 90, 116, 0.5);
      }

      .joystick-handle {
        width: 50px;
        height: 50px;
        background: radial-gradient(circle, #2e5a74, #d0b783);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      }

      .look-area {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 200px;
        z-index: 999;
        touch-action: none;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.4);
        font-weight: 200;
        letter-spacing: 0.1em;
        z-index: 2000;
      }

      .loading::after {
        content: "";
        display: block;
        width: 100px;
        height: 100px;
        margin: 30px auto;
        border: 2px solid transparent;
        border-top-color: #2e5a74;
        border-radius: 50%;
        animation: quantum-spin 1s ease-in-out infinite;
      }

      @keyframes quantum-spin {
        0% {
          transform: rotate(0deg) scale(1);
          border-top-color: #2e5a74;
        }
        50% {
          transform: rotate(180deg) scale(1.2);
          border-top-color: #d0b783;
        }
        100% {
          transform: rotate(360deg) scale(1);
          border-top-color: #2e5a74;
        }
      }

      @media (max-width: 768px) {
        .world-title {
          font-size: 2em;
        }

        .world-description {
          font-size: 1em;
          max-width: 300px;
        }
      }

      @supports (-webkit-touch-callout: none) {
        body {
          position: fixed;
          height: 100vh;
          height: -webkit-fill-available;
        }

        #three-container {
          height: 100vh;
          height: -webkit-fill-available;
        }
      }
    </style>
  </head>
  <body>
    <div id="three-container"></div>

    <div class="look-area" id="look-area"></div>

    <div class="world-ui">
      <h1 class="world-title" id="world-title">NEBRASKA FURNITURE MART 90S</h1>
      <p class="world-description" id="world-description">
        Step into a faithfully recreated Nebraska Furniture Mart as it was in
        the 1990s, with sprawling showrooms, dazzling displays of furniture,
        vintage electronics, and bustling retail energy.
      </p>
    </div>

    <div class="world-origin" id="world-origin">
      <span class="origin-label">Arrived from:</span>
      <span class="origin-world" id="origin-world-name">Origin</span>
    </div>

    <div class="controls-hint" id="controls-hint">
      WASD: Move | Mouse: Look | Click: Travel | Space: Jump
    </div>

    <div class="mobile-controls" id="mobile-controls">
      <div class="controls-container">
        <div class="joystick-container" id="movement-joystick">
          <div class="joystick-handle" id="movement-handle"></div>
        </div>
      </div>
    </div>

    <div class="portal-tooltip" id="portal-tooltip">
      <h3 class="tooltip-title"></h3>
      <p class="tooltip-description"></p>
      <p class="tooltip-instruction">Click to enter</p>
    </div>

    <div class="loading" id="loading">
      Materializing nebraska furniture mart 90s...
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Configuration
      const REPO_OWNER = "kody-w";
      const REPO_NAME = "nexus-worlds";
      const BRANCH = "main";

      // World configuration
      const DEFAULT_WORLD_ATTRIBUTES = {
        name: "Nebraska Furniture Mart 90s",
        description:
          "Step into a faithfully recreated Nebraska Furniture Mart as it was in the 1990s, with sprawling showrooms, dazzling displays of furniture, vintage electronics, and bustling retail energy.",
        ambientColor: 0xfff8e6,
        fogColor: 0xf5f2ed,
        groundColor: 0xd4c9b8,
        skyTopColor: 0xffffff,
        skyBottomColor: 0xe8e4dd,
        primaryColor: 0x1a4d2e,
        secondaryColor: 0xc41e3a,
        tertiaryColor: 0x4169e1,
        emissiveColor: 0xffeb3b,
        moveSpeed: 0.15,
        lookSpeed: 0.002,
        portalColor1: 0x1a4d2e,
        portalColor2: 0xc41e3a,
        particleCount: 50,
        cameraHeight: 1.7,
        fogNear: 20,
        fogFar: 180,
        enablePhysics: true,
        enableFlying: false,
        gravity: 0.5,
        jumpForce: 0.3,
      };

      // Shader definitions
      const skyVertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      const skyFragmentShader = `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `;

      const portalVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      const portalFragmentShader = `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform float distortion;
            varying vec2 vUv;
            
            float noise(vec2 p) {
                return sin(p.x * 10.0) * sin(p.y * 10.0);
            }
            
            void main() {
                vec2 center = vUv - 0.5;
                float dist = length(center);
                float angle = atan(center.y, center.x);
                
                // Spiral pattern
                float spiral = sin(dist * 20.0 - time * 3.0 + angle * 5.0);
                
                // Distortion
                vec2 distortedUV = vUv;
                if (distortion > 0.0) {
                    distortedUV += sin(time + vUv * 10.0) * 0.02 * distortion;
                }
                
                // Noise
                float n = noise(distortedUV * 10.0 + time);
                
                // Mix colors
                vec3 color = mix(color1, color2, spiral * 0.5 + 0.5);
                color += n * 0.1;
                
                // Alpha falloff
                float alpha = 1.0 - smoothstep(0.35, 0.5, dist);
                alpha *= 0.8 + sin(time * 2.0 + dist * 10.0) * 0.2;
                
                gl_FragColor = vec4(color, alpha);
            }
        `;

      // Parse inherited attributes
      function parseInheritedAttributes() {
        let paramString = window.INJECTED_PARAMS || window.location.search;

        if (window.location.protocol === "blob:") {
          const storedParams = sessionStorage.getItem("worldInheritanceParams");
          if (storedParams) {
            paramString = storedParams;
          }
        }

        if (!paramString || paramString === "?") {
          const transitionData = localStorage.getItem("worldTransition");
          if (transitionData) {
            try {
              const data = JSON.parse(transitionData);
              if (Date.now() - data.timestamp < 5000) {
                paramString = "?" + data.params;
              }
            } catch (e) {
              console.error("Error parsing transition data:", e);
            }
            localStorage.removeItem("worldTransition");
          }
        }

        const params = new URLSearchParams(paramString);
        const inherited = {};

        inherited.sourceWorld = params.get("from") || null;
        inherited.sourceWorldName = params.get("fromName") || null;

        if (params.has("moveSpeed"))
          inherited.moveSpeed = parseFloat(params.get("moveSpeed"));
        if (params.has("lookSpeed"))
          inherited.lookSpeed = parseFloat(params.get("lookSpeed"));
        if (params.has("ambientColor"))
          inherited.ambientColor = parseInt(params.get("ambientColor"), 16);
        if (params.has("fogColor"))
          inherited.fogColor = parseInt(params.get("fogColor"), 16);
        if (params.has("portalColor1"))
          inherited.portalColor1 = parseInt(params.get("portalColor1"), 16);
        if (params.has("portalColor2"))
          inherited.portalColor2 = parseInt(params.get("portalColor2"), 16);
        if (params.has("particleCount"))
          inherited.particleCount = parseInt(params.get("particleCount"));
        if (params.has("cameraHeight"))
          inherited.cameraHeight = parseFloat(params.get("cameraHeight"));
        if (params.has("fogNear"))
          inherited.fogNear = parseFloat(params.get("fogNear"));
        if (params.has("fogFar"))
          inherited.fogFar = parseFloat(params.get("fogFar"));

        console.log("Parsed inherited attributes:", inherited);
        return inherited;
      }

      const inheritedAttributes = parseInheritedAttributes();
      const CURRENT_WORLD = {
        ...DEFAULT_WORLD_ATTRIBUTES,
        ...inheritedAttributes,
      };

      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
        (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);

      const isIOS =
        /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

      class WorldNavigator {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.composer = null;
          this.portals = [];
          this.worlds = [];
          this.structures = [];
          this.effects = [];
          this.raycaster = new THREE.Raycaster();
          this.clock = new THREE.Clock();

          this.moveSpeed = CURRENT_WORLD.moveSpeed;
          this.lookSpeed = CURRENT_WORLD.lookSpeed;
          this.keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            q: false,
            e: false,
            " ": false,
          };
          this.rotation = { x: 0, y: 0 };
          this.velocity = new THREE.Vector3();
          this.canJump = true;

          this.isMobile = isMobile;
          this.isIOS = isIOS;
          this.joystickActive = false;
          this.joystickVector = new THREE.Vector2();
          this.lookTouch = null;
          this.joystickTouch = null;

          this.hoveredPortal = null;
          this.tooltip = document.getElementById("portal-tooltip");
          this.tooltipTitle = this.tooltip.querySelector(".tooltip-title");
          this.tooltipDescription = this.tooltip.querySelector(
            ".tooltip-description"
          );
          this.isPointerLocked = false;

          this.inheritedAttributes = inheritedAttributes;

          if (this.isIOS) {
            document.body.addEventListener(
              "touchmove",
              (e) => {
                if (e.target === document.body) {
                  e.preventDefault();
                }
              },
              { passive: false }
            );
          }
        }

        async init() {
          if (this.inheritedAttributes.sourceWorldName) {
            const originDiv = document.getElementById("world-origin");
            const originName = document.getElementById("origin-world-name");
            originName.textContent = this.inheritedAttributes.sourceWorldName;
            originDiv.classList.add("visible");
          }

          setTimeout(() => {
            document.getElementById("loading").style.display = "none";
          }, 2000);

          document.getElementById("world-title").textContent =
            CURRENT_WORLD.name.toUpperCase();
          document.getElementById("world-description").textContent =
            CURRENT_WORLD.description;

          this.setupScene();
          this.setupLighting();
          await this.loadWorlds();
          this.createEnvironment();
          this.createStructures();
          this.createEffects();
          this.createPortals();
          this.setupEventListeners();

          // Physics system initialization
          this.physicsEnabled = true;
          this.gravity = 0.5;
          this.jumpForce = 0.3;

          // Ground collision check
          this.checkGroundCollision = function () {
            // Simple height-based collision
            const groundHeight = this.getGroundHeightAt(
              this.camera.position.x,
              this.camera.position.z
            );
            return (
              this.camera.position.y <=
              groundHeight + CURRENT_WORLD.cameraHeight
            );
          };

          this.getGroundHeightAt = function (x, z) {
            // Sample terrain height at position
            // This is simplified - in reality you'd raycast or sample the terrain geometry
            return 0;
          };

          if (this.isMobile) {
            document.getElementById("controls-hint").textContent =
              "Touch & drag to look around, Use joystick to move, Tap on portals to travel";
            document.getElementById("mobile-controls").classList.add("show");

            const instruction = this.tooltip.querySelector(
              ".tooltip-instruction"
            );
            if (instruction) {
              instruction.textContent = "Tap to enter";
            }
          }

          this.animate();
        }

        setupScene() {
          this.scene = new THREE.Scene();
          this.scene.fog = new THREE.Fog(CURRENT_WORLD.fogColor, CURRENT_WORLD.fogNear, CURRENT_WORLD.fogFar);

          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(0, CURRENT_WORLD.cameraHeight, 120);

          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "high-performance",
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoft;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.2;
          document
            .getElementById("three-container")
            .appendChild(this.renderer.domElement);
        }

        setupLighting() {
          // Bright warehouse-style fluorescent lighting
          const ambientLight = new THREE.AmbientLight(CURRENT_WORLD.ambientColor, 0.8);
          this.scene.add(ambientLight);

          // Main overhead lighting
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(30, 50, 20);
          dirLight.castShadow = true;
          if (dirLight.castShadow) {
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 200;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
          }
          this.scene.add(dirLight);

          // Fluorescent strip lights throughout the store
          for (let i = 0; i < 8; i++) {
            const stripLight = new THREE.RectAreaLight(0xffffff, 2, 15, 2);
            stripLight.position.set(
              (i % 2 === 0 ? -1 : 1) * 25,
              9.5,
              -40 + i * 10
            );
            stripLight.lookAt(
              stripLight.position.x,
              0,
              stripLight.position.z
            );
            this.scene.add(stripLight);
          }

          // Department spotlights
          const spotLight1 = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5);
          spotLight1.position.set(-30, 15, -20);
          spotLight1.target.position.set(-30, 0, -20);
          spotLight1.castShadow = true;
          this.scene.add(spotLight1);
          this.scene.add(spotLight1.target);

          const spotLight2 = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5);
          spotLight2.position.set(30, 15, 20);
          spotLight2.target.position.set(30, 0, 20);
          spotLight2.castShadow = true;
          this.scene.add(spotLight2);
          this.scene.add(spotLight2.target);
        }

        async loadWorlds() {
          try {
            const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
            const response = await fetch(apiUrl);

            if (!response.ok) {
              throw new Error(`GitHub API error: ${response.status}`);
            }

            const data = await response.json();

            this.worlds = data.tree
              .filter(
                (item) =>
                  item.type === "blob" &&
                  item.path.endsWith(".html") &&
                  !item.path.includes("/") &&
                  !item.path.toLowerCase().includes("index") &&
                  !item.path.toLowerCase().includes("readme") &&
                  !item.path
                    .toLowerCase()
                    .includes("nebraska_furniture_mart_90s")
              )
              .map((item) => ({
                path: item.path,
                name: this.formatWorldName(item.path),
                url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
              }));

            // Always include portal to hub
            this.worlds.unshift({
              name: "Nexus Hub",
              description: "Return to the central hub",
              url:
                "https://raw.githubusercontent.com/" +
                REPO_OWNER +
                "/" +
                REPO_NAME +
                "/" +
                BRANCH +
                "/index.html",
            });

            console.log(`Found ${this.worlds.length} worlds to connect`);
          } catch (error) {
            console.error("Error loading worlds:", error);
            this.worlds = this.getDemoWorlds();
          }
        }

        formatWorldName(filename) {
          return filename
            .replace(".html", "")
            .replace(/[-_]/g, " ")
            .replace(/\b\w/g, (l) => l.toUpperCase());
        }

        getDemoWorlds() {
          return [
            { name: "Nexus Hub", description: "Return to the central hub" },
            {
              name: "Crystal Caves",
              description: "A mystical underground realm",
            },
            {
              name: "Sky Islands",
              description: "Floating islands in the clouds",
            },
            { name: "Neon City", description: "Cyberpunk metropolis" },
            { name: "Quantum Realm", description: "Where physics breaks down" },
          ];
        }

        createEnvironment() {
          // Parking lot asphalt
          const asphaltGeometry = new THREE.PlaneGeometry(400, 300, 20, 20);
          const asphaltMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.9,
            metalness: 0.1,
          });

          const parkingLot = new THREE.Mesh(asphaltGeometry, asphaltMaterial);
          parkingLot.rotation.x = -Math.PI / 2;
          parkingLot.position.set(0, -0.01, 250);
          parkingLot.receiveShadow = true;
          this.scene.add(parkingLot);

          // Parking lines
          const lineMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            roughness: 0.8,
            metalness: 0,
          });

          for (let i = -10; i <= 10; i++) {
            if (i === 0) continue; // Skip center for driving lane
            const lineGeometry = new THREE.BoxGeometry(0.3, 0.02, 15);
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(i * 8, 0, 180);
            line.receiveShadow = true;
            this.scene.add(line);
          }

          // Parked cars
          const carColors = [0x1a1a1a, 0x8b0000, 0x00008b, 0x2f4f2f, 0x696969];
          for (let i = 0; i < 15; i++) {
            const carBody = new THREE.BoxGeometry(4, 1.5, 8);
            const carMaterial = new THREE.MeshStandardMaterial({
              color: carColors[i % carColors.length],
              roughness: 0.3,
              metalness: 0.7,
            });
            const car = new THREE.Mesh(carBody, carMaterial);
            const row = Math.floor(i / 5);
            const col = i % 5;
            car.position.set(-60 + col * 30, 0.75, 160 + row * 25);
            car.castShadow = true;
            car.receiveShadow = true;
            this.scene.add(car);

            // Car roof
            const roofGeometry = new THREE.BoxGeometry(3, 0.8, 4);
            const roof = new THREE.Mesh(roofGeometry, carMaterial);
            roof.position.set(-60 + col * 30, 1.9, 160 + row * 25);
            roof.castShadow = true;
            this.scene.add(roof);
          }

          // Store exterior walls
          const exteriorWallMaterial = new THREE.MeshStandardMaterial({
            color: 0xc8b88b,
            roughness: 0.8,
            metalness: 0,
          });

          // Extended front wall with entrance
          const frontWallExt1 = new THREE.BoxGeometry(120, 15, 4);
          const frontExt1 = new THREE.Mesh(frontWallExt1, exteriorWallMaterial);
          frontExt1.position.set(-80, 7.5, 102);
          frontExt1.castShadow = true;
          frontExt1.receiveShadow = true;
          this.scene.add(frontExt1);

          const frontWallExt2 = new THREE.BoxGeometry(120, 15, 4);
          const frontExt2 = new THREE.Mesh(frontWallExt2, exteriorWallMaterial);
          frontExt2.position.set(80, 7.5, 102);
          frontExt2.castShadow = true;
          frontExt2.receiveShadow = true;
          this.scene.add(frontExt2);

          // Store entrance frame
          const entranceFrameMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.5,
            metalness: 0.8,
          });

          const entranceFrame = new THREE.BoxGeometry(40, 12, 2);
          const frame = new THREE.Mesh(entranceFrame, entranceFrameMaterial);
          frame.position.set(0, 6, 101);
          frame.castShadow = true;
          this.scene.add(frame);

          // Sliding doors (will animate)
          this.createSlidingDoors();

          // Warehouse floor - polished concrete
          const groundGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
          const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.3,
            metalness: 0.1,
            wireframe: false,
          });

          const ground = new THREE.Mesh(groundGeometry, groundMaterial);
          ground.rotation.x = -Math.PI / 2;
          ground.receiveShadow = true;
          this.scene.add(ground);

          // Floor patterns - aisles
          const aisleGeometry = new THREE.PlaneGeometry(4, 180);
          const aisleMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.5,
            metalness: 0,
          });

          for (let i = -40; i <= 40; i += 20) {
            const aisle = new THREE.Mesh(aisleGeometry, aisleMaterial);
            aisle.rotation.x = -Math.PI / 2;
            aisle.position.set(i, 0.01, 0);
            aisle.receiveShadow = true;
            this.scene.add(aisle);
          }

          // Ceiling
          const ceilingGeometry = new THREE.PlaneGeometry(200, 200);
          const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0f0f0,
            roughness: 0.8,
            metalness: 0,
            side: THREE.DoubleSide,
          });

          const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
          ceiling.rotation.x = Math.PI / 2;
          ceiling.position.y = 12;
          ceiling.receiveShadow = true;
          this.scene.add(ceiling);

          // Ceiling grid pattern
          const gridSize = 2;
          const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc });
          
          for (let i = -100; i <= 100; i += gridSize) {
            const points = [];
            points.push(new THREE.Vector3(i, 11.9, -100));
            points.push(new THREE.Vector3(i, 11.9, 100));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            this.scene.add(line);
          }

          for (let i = -100; i <= 100; i += gridSize) {
            const points = [];
            points.push(new THREE.Vector3(-100, 11.9, i));
            points.push(new THREE.Vector3(100, 11.9, i));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            this.scene.add(line);
          }

          // Warehouse walls
          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xe8e4dd,
            roughness: 0.8,
            metalness: 0,
          });

          // Back wall
          const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(200, 12, 2),
            wallMaterial
          );
          backWall.position.set(0, 6, -100);
          backWall.castShadow = true;
          backWall.receiveShadow = true;
          this.scene.add(backWall);

          // Front wall sections (with entrance)
          const frontWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(80, 12, 2),
            wallMaterial
          );
          frontWall1.position.set(-60, 6, 100);
          frontWall1.castShadow = true;
          frontWall1.receiveShadow = true;
          this.scene.add(frontWall1);

          const frontWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(80, 12, 2),
            wallMaterial
          );
          frontWall2.position.set(60, 6, 100);
          frontWall2.castShadow = true;
          frontWall2.receiveShadow = true;
          this.scene.add(frontWall2);

          // Side walls
          const sideWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(2, 12, 200),
            wallMaterial
          );
          sideWall1.position.set(-100, 6, 0);
          sideWall1.castShadow = true;
          sideWall1.receiveShadow = true;
          this.scene.add(sideWall1);

          const sideWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(2, 12, 200),
            wallMaterial
          );
          sideWall2.position.set(100, 6, 0);
          sideWall2.castShadow = true;
          sideWall2.receiveShadow = true;
          this.scene.add(sideWall2);

          // Outdoor lighting poles
          const poleMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.8,
            metalness: 0.5,
          });

          for (let i = 0; i < 6; i++) {
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 20, 8);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set((i % 2 === 0 ? -1 : 1) * 100, 10, 150 + Math.floor(i / 2) * 50);
            pole.castShadow = true;
            this.scene.add(pole);

            // Parking lot light
            const lightGeometry = new THREE.BoxGeometry(4, 1, 4);
            const lightBox = new THREE.Mesh(lightGeometry, poleMaterial);
            lightBox.position.set((i % 2 === 0 ? -1 : 1) * 100, 20, 150 + Math.floor(i / 2) * 50);
            lightBox.castShadow = true;
            this.scene.add(lightBox);

            // Add actual light
            const parkingLight = new THREE.PointLight(0xfff8e1, 0.8, 50);
            parkingLight.position.copy(lightBox.position);
            parkingLight.position.y -= 1;
            this.scene.add(parkingLight);
          }
        }

        createSlidingDoors() {
          // Sliding glass doors
          const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x88ccff,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.9,
          });

          this.leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(19, 10, 0.5),
            glassMaterial
          );
          this.leftDoor.position.set(-9.5, 5, 101);
          this.leftDoor.castShadow = true;
          this.scene.add(this.leftDoor);

          this.rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(19, 10, 0.5),
            glassMaterial
          );
          this.rightDoor.position.set(9.5, 5, 101);
          this.rightDoor.castShadow = true;
          this.scene.add(this.rightDoor);

          // Door frames
          const doorFrameMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.7,
            metalness: 0.5,
          });

          const frameTop = new THREE.BoxGeometry(40, 1, 0.5);
          const topFrame = new THREE.Mesh(frameTop, doorFrameMaterial);
          topFrame.position.set(0, 10.5, 101);
          this.scene.add(topFrame);

          // Door sensor zone
          this.doorSensorZone = new THREE.Box3(
            new THREE.Vector3(-20, 0, 95),
            new THREE.Vector3(20, 10, 107)
          );
          this.doorsOpen = false;
        }

        createStructures() {
          // Create front entrance displays first
          this.createEntranceDisplays();
          
          // Living Room Department
          this.createLivingRoomDepartment();
          
          // Bedroom Department
          this.createBedroomDepartment();
          
          // Electronics Department (90s style)
          this.createElectronicsDepartment();
          
          // Appliances Department
          this.createAppliancesDepartment();
          
          // Office Furniture Department
          this.createOfficeDepartment();
          
          // Checkout area
          this.createCheckoutArea();
          
          // Department signs
          this.createDepartmentSigns();
          
          // Price tags everywhere
          this.createPriceTags();
          
          // Create NPCs
          this.createNPCs();
        }

        createNPCs() {
          this.npcs = [];
          
          // Create cashiers
          this.createCashiers();
          
          // Create shopping customers
          this.createCustomers();
          
          // Create sales associates
          this.createSalesAssociates();
        }

        createCashiers() {
          // Cashier material
          const cashierBodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e, // Store uniform green
            roughness: 0.8,
            metalness: 0,
          });

          const skinMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdbac,
            roughness: 0.7,
            metalness: 0,
          });

          // Create 4 cashiers at checkout counters
          for (let i = 0; i < 4; i++) {
            const cashierGroup = new THREE.Group();
            
            // Body (uniform)
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 3, 8);
            const body = new THREE.Mesh(bodyGeometry, cashierBodyMaterial);
            body.position.y = 1.5;
            cashierGroup.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.5;
            cashierGroup.add(head);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 6);
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.7, 2, 0);
            leftArm.rotation.z = Math.PI / 6;
            cashierGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.7, 2, 0);
            rightArm.rotation.z = -Math.PI / 6;
            cashierGroup.add(rightArm);

            // Name tag
            const tagGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.05);
            const tagMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.5,
              metalness: 0,
            });
            const nameTag = new THREE.Mesh(tagGeometry, tagMaterial);
            nameTag.position.set(0.3, 2.5, 0.6);
            cashierGroup.add(nameTag);

            // Position at checkout counter
            cashierGroup.position.set(-20 + i * 10, 0, 76);
            cashierGroup.userData = {
              type: 'cashier',
              name: ['Sarah', 'Mike', 'Jennifer', 'Tom'][i],
              animation: 'idle',
              greeting: `Hi! Welcome to Nebraska Furniture Mart! I'm ${['Sarah', 'Mike', 'Jennifer', 'Tom'][i]}. Find everything okay?`
            };

            this.npcs.push(cashierGroup);
            this.scene.add(cashierGroup);
          }
        }

        createCustomers() {
          // Various customer types
          const customerColors = [
            { body: 0x4169e1, skin: 0xffdbac }, // Blue shirt
            { body: 0xffc0cb, skin: 0xdaa520 }, // Pink shirt
            { body: 0x228b22, skin: 0xf4a460 }, // Green shirt
            { body: 0x8b4513, skin: 0xffe4b5 }, // Brown shirt
            { body: 0x9370db, skin: 0xcd853f }, // Purple shirt
          ];

          // Create 15 customers wandering the store
          for (let i = 0; i < 15; i++) {
            const customerGroup = new THREE.Group();
            const colors = customerColors[i % customerColors.length];
            
            // Body
            const bodyMaterial = new THREE.MeshStandardMaterial({
              color: colors.body,
              roughness: 0.8,
              metalness: 0,
            });
            
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.7, 2.5, 8);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.25;
            customerGroup.add(body);

            // Head
            const skinMaterial = new THREE.MeshStandardMaterial({
              color: colors.skin,
              roughness: 0.7,
              metalness: 0,
            });
            
            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3;
            customerGroup.add(head);

            // Legs
            const legMaterial = new THREE.MeshStandardMaterial({
              color: 0x000080,
              roughness: 0.9,
              metalness: 0,
            });
            
            const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 6);
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.75, 0);
            customerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.75, 0);
            customerGroup.add(rightLeg);

            // Initial random position
            customerGroup.position.set(
              (Math.random() - 0.5) * 140,
              0,
              (Math.random() - 0.5) * 120
            );

            // Customer data
            customerGroup.userData = {
              type: 'customer',
              targetPosition: new THREE.Vector3(),
              speed: 0.02 + Math.random() * 0.03,
              idleTime: 0,
              maxIdleTime: 3 + Math.random() * 5,
              currentDepartment: null,
              interests: ['sofa', 'bed', 'tv', 'appliance'][Math.floor(Math.random() * 4)],
              animation: 'walking',
              path: [],
              pathIndex: 0
            };

            // Set initial target
            this.setNewCustomerTarget(customerGroup);

            this.npcs.push(customerGroup);
            this.scene.add(customerGroup);
          }
        }

        createSalesAssociates() {
          // Sales associates in each department
          const associateMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e, // Store uniform
            roughness: 0.8,
            metalness: 0,
          });

          const skinMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdbac,
            roughness: 0.7,
            metalness: 0,
          });

          const departments = [
            { name: 'Living Room', pos: [-40, 0, -25] },
            { name: 'Bedroom', pos: [35, 0, -25] },
            { name: 'Electronics', pos: [0, 0, -45] },
            { name: 'Appliances', pos: [-70, 0, 0] },
            { name: 'Office', pos: [70, 0, 25] }
          ];

          departments.forEach((dept, i) => {
            const associateGroup = new THREE.Group();
            
            // Body with vest
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 3, 8);
            const body = new THREE.Mesh(bodyGeometry, associateMaterial);
            body.position.y = 1.5;
            associateGroup.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.5;
            associateGroup.add(head);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 6);
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.7, 2, 0);
            leftArm.rotation.z = Math.PI / 8;
            associateGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.7, 2, 0);
            rightArm.rotation.z = -Math.PI / 8;
            associateGroup.add(rightArm);

            // Clipboard
            const clipboardGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.1);
            const clipboardMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b4513,
              roughness: 0.7,
              metalness: 0,
            });
            const clipboard = new THREE.Mesh(clipboardGeometry, clipboardMaterial);
            clipboard.position.set(0.5, 2, 0.5);
            clipboard.rotation.x = -Math.PI / 6;
            associateGroup.add(clipboard);

            // Position in department
            associateGroup.position.set(dept.pos[0], dept.pos[1], dept.pos[2]);
            associateGroup.userData = {
              type: 'associate',
              department: dept.name,
              animation: 'helping',
              dialogue: [
                `Can I help you find something in our ${dept.name} department?`,
                `We have great deals on ${dept.name.toLowerCase()} furniture today!`,
                `Let me know if you need any assistance!`
              ],
              currentDialogue: 0,
              basePosition: new THREE.Vector3(dept.pos[0], dept.pos[1], dept.pos[2]),
              wanderRadius: 10
            };

            this.npcs.push(associateGroup);
            this.scene.add(associateGroup);
          });
        }

        setNewCustomerTarget(customer) {
          const data = customer.userData;
          
          // Pick random department area
          const areas = [
            { x: -40, z: -25, radius: 20 }, // Living room
            { x: 35, z: -25, radius: 20 },  // Bedroom
            { x: 0, z: -45, radius: 15 },   // Electronics
            { x: -70, z: 0, radius: 20 },   // Appliances
            { x: 70, z: 25, radius: 15 }    // Office
          ];
          
          const area = areas[Math.floor(Math.random() * areas.length)];
          data.targetPosition.set(
            area.x + (Math.random() - 0.5) * area.radius,
            0,
            area.z + (Math.random() - 0.5) * area.radius
          );
          
          data.idleTime = 0;
        }

        createEntranceDisplays() {
          // Grand entrance featured displays
          
          // Feature display platform 1 - Living room set
          const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.7,
            metalness: 0.2,
          });
          
          const platform1 = new THREE.BoxGeometry(20, 0.5, 20);
          const displayPlatform1 = new THREE.Mesh(platform1, platformMaterial);
          displayPlatform1.position.set(-25, 0.25, 65);
          displayPlatform1.receiveShadow = true;
          displayPlatform1.castShadow = true;
          this.scene.add(displayPlatform1);

          // Featured sofa on platform 1
          const featuredSofaMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b0000,
            roughness: 0.9,
            metalness: 0,
          });

          const featuredSofa = new THREE.BoxGeometry(12, 3, 5);
          const sofa1 = new THREE.Mesh(featuredSofa, featuredSofaMaterial);
          sofa1.position.set(-25, 2, 65);
          sofa1.castShadow = true;
          this.scene.add(sofa1);

          const sofaBack1 = new THREE.BoxGeometry(12, 4, 1);
          const back1 = new THREE.Mesh(sofaBack1, featuredSofaMaterial);
          back1.position.set(-25, 3.5, 62.5);
          back1.castShadow = true;
          this.scene.add(back1);

          // Feature display platform 2 - Bedroom set
          const platform2 = new THREE.BoxGeometry(20, 0.5, 20);
          const displayPlatform2 = new THREE.Mesh(platform2, platformMaterial);
          displayPlatform2.position.set(25, 0.25, 65);
          displayPlatform2.receiveShadow = true;
          displayPlatform2.castShadow = true;
          this.scene.add(displayPlatform2);

          // Featured bed on platform 2
          const featuredBedMaterial = new THREE.MeshStandardMaterial({
            color: 0x4b3621,
            roughness: 0.8,
            metalness: 0,
          });

          const featuredBed = new THREE.BoxGeometry(10, 1.5, 12);
          const bed2 = new THREE.Mesh(featuredBed, featuredBedMaterial);
          bed2.position.set(25, 1, 65);
          bed2.castShadow = true;
          this.scene.add(bed2);

          const featuredMattress = new THREE.BoxGeometry(9, 2.5, 11);
          const featuredMattressMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.95,
            metalness: 0,
          });
          const mattress2 = new THREE.Mesh(featuredMattress, featuredMattressMaterial);
          mattress2.position.set(25, 3, 65);
          mattress2.castShadow = true;
          this.scene.add(mattress2);

          // Center entrance display - Entertainment center
          const centerDisplay = new THREE.BoxGeometry(15, 10, 4);
          const centerDisplayMaterial = new THREE.MeshStandardMaterial({
            color: 0x2f1b14,
            roughness: 0.7,
            metalness: 0,
          });
          const entertainmentDisplay = new THREE.Mesh(centerDisplay, centerDisplayMaterial);
          entertainmentDisplay.position.set(0, 5, 60);
          entertainmentDisplay.castShadow = true;
          entertainmentDisplay.receiveShadow = true;
          this.scene.add(entertainmentDisplay);

          // Big CRT TV in center
          const bigTVGeometry = new THREE.BoxGeometry(6, 4.5, 4);
          const bigTVMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.2,
            metalness: 0.9,
          });
          const bigTV = new THREE.Mesh(bigTVGeometry, bigTVMaterial);
          bigTV.position.set(0, 6, 60);
          bigTV.castShadow = true;
          this.scene.add(bigTV);

          // "TODAY'S SPECIAL" signs
          const specialSignMaterial = new THREE.MeshStandardMaterial({
            color: 0xffeb3b,
            roughness: 0.5,
            metalness: 0,
            emissive: 0xffeb3b,
            emissiveIntensity: 0.4,
          });

          const specialSign1 = new THREE.BoxGeometry(8, 3, 0.2);
          const special1 = new THREE.Mesh(specialSign1, specialSignMaterial);
          special1.position.set(-25, 6, 55);
          special1.rotation.y = Math.PI / 6;
          this.scene.add(special1);

          const specialSign2 = new THREE.BoxGeometry(8, 3, 0.2);
          const special2 = new THREE.Mesh(specialSign2, specialSignMaterial);
          special2.position.set(25, 6, 55);
          special2.rotation.y = -Math.PI / 6;
          this.scene.add(special2);

          // "SALE" text on special signs (simulated with boxes)
          const saleTextMaterial = new THREE.MeshStandardMaterial({
            color: 0xc41e3a,
            roughness: 0.3,
            metalness: 0,
          });

          // Add "SALE" letters to both signs
          const salePositions = [
            { base: [-25, 6, 55.1], rotation: Math.PI / 6 },
            { base: [25, 6, 55.1], rotation: -Math.PI / 6 }
          ];

          salePositions.forEach(pos => {
            const letters = "SALE";
            for (let i = 0; i < letters.length; i++) {
              const letterBox = new THREE.BoxGeometry(1, 1.5, 0.1);
              const letter = new THREE.Mesh(letterBox, saleTextMaterial);
              
              // Calculate position with rotation
              const offset = (i - 1.5) * 1.2;
              letter.position.set(
                pos.base[0] + offset * Math.cos(pos.rotation),
                pos.base[1],
                pos.base[2] + offset * Math.sin(pos.rotation)
              );
              letter.rotation.y = pos.rotation;
              this.scene.add(letter);
            }
          });

          // Welcome mat
          const matGeometry = new THREE.BoxGeometry(10, 0.1, 6);
          const matMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.95,
            metalness: 0,
          });
          const welcomeMat = new THREE.Mesh(matGeometry, matMaterial);
          welcomeMat.position.set(0, 0.05, 85);
          welcomeMat.receiveShadow = true;
          this.scene.add(welcomeMat);

          // Entrance promotional stands
          const standMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.8,
            metalness: 0.3,
          });

          for (let i = 0; i < 4; i++) {
            const standGeometry = new THREE.CylinderGeometry(1.5, 1.5, 4, 16);
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.set((i % 2 === 0 ? -1 : 1) * 40, 2, 75 + (Math.floor(i / 2) * 10));
            stand.castShadow = true;
            stand.receiveShadow = true;
            this.scene.add(stand);

            // Promotional sign on stand
            const promoSign = new THREE.BoxGeometry(3, 2, 0.1);
            const promo = new THREE.Mesh(promoSign, specialSignMaterial);
            promo.position.set((i % 2 === 0 ? -1 : 1) * 40, 5, 75 + (Math.floor(i / 2) * 10));
            promo.rotation.y = (i % 2 === 0 ? 1 : -1) * Math.PI / 8;
            this.scene.add(promo);
          }

          // Stack of sale flyers near entrance
          const flyerStackGeometry = new THREE.BoxGeometry(2, 0.5, 3);
          const flyerMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.9,
            metalness: 0,
          });
          
          for (let i = 0; i < 3; i++) {
            const flyerStack = new THREE.Mesh(flyerStackGeometry, flyerMaterial);
            flyerStack.position.set(-10 + i * 10, 0.25, 88);
            flyerStack.receiveShadow = true;
            flyerStack.castShadow = true;
            this.scene.add(flyerStack);

            // Red stripe on flyers
            const stripeGeometry = new THREE.BoxGeometry(2, 0.51, 0.5);
            const stripeMaterial = new THREE.MeshStandardMaterial({
              color: 0xc41e3a,
              roughness: 0.8,
              metalness: 0,
            });
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.set(-10 + i * 10, 0.25, 89);
            this.scene.add(stripe);
          }

          // Shopping carts near entrance
          const cartMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.7,
            metalness: 0.8,
          });

          for (let i = 0; i < 6; i++) {
            const cartBasket = new THREE.BoxGeometry(2, 1.5, 3);
            const cart = new THREE.Mesh(cartBasket, cartMaterial);
            cart.position.set(-50 + i * 2, 1.5, 85 + (i % 2) * 2);
            cart.castShadow = true;
            this.scene.add(cart);

            // Cart wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
            const wheelPositions = [
              [-0.8, -1.2], [0.8, -1.2], [-0.8, 1.2], [0.8, 1.2]
            ];
            
            wheelPositions.forEach(([x, z]) => {
              const wheel = new THREE.Mesh(wheelGeometry, cartMaterial);
              wheel.position.set(-50 + i * 2 + x, 0.3, 85 + (i % 2) * 2 + z);
              wheel.rotation.z = Math.PI / 2;
              this.scene.add(wheel);
            });
          }
        }

        createLivingRoomDepartment() {
          // Sofa displays
          const sofaMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.8,
            metalness: 0,
          });

          // Large sectional sofa
          const sectionalBase = new THREE.BoxGeometry(15, 2, 8);
          const sectionalSeat = new THREE.Mesh(sectionalBase, sofaMaterial);
          sectionalSeat.position.set(-30, 1, -30);
          sectionalSeat.castShadow = true;
          sectionalSeat.receiveShadow = true;
          this.scene.add(sectionalSeat);

          const sectionalBack = new THREE.BoxGeometry(15, 4, 2);
          const sectionalBackRest = new THREE.Mesh(sectionalBack, sofaMaterial);
          sectionalBackRest.position.set(-30, 3, -34);
          sectionalBackRest.castShadow = true;
          this.scene.add(sectionalBackRest);

          // Coffee tables
          const tableMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.4,
            metalness: 0.1,
          });

          const coffeeTable = new THREE.BoxGeometry(6, 0.5, 3);
          const table1 = new THREE.Mesh(coffeeTable, tableMaterial);
          table1.position.set(-30, 1, -25);
          table1.castShadow = true;
          table1.receiveShadow = true;
          this.scene.add(table1);

          // Entertainment centers (90s style - huge!)
          const tvStandMaterial = new THREE.MeshStandardMaterial({
            color: 0x2f1b14,
            roughness: 0.6,
            metalness: 0,
          });

          const entertainmentCenter = new THREE.BoxGeometry(10, 8, 3);
          const tvStand = new THREE.Mesh(entertainmentCenter, tvStandMaterial);
          tvStand.position.set(-45, 4, -35);
          tvStand.castShadow = true;
          tvStand.receiveShadow = true;
          this.scene.add(tvStand);

          // CRT TV display
          const tvGeometry = new THREE.BoxGeometry(4, 3, 3);
          const tvMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.2,
            metalness: 0.8,
          });
          const tv = new THREE.Mesh(tvGeometry, tvMaterial);
          tv.position.set(-45, 5.5, -35);
          tv.castShadow = true;
          this.scene.add(tv);

          // Recliners
          const reclinerMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a5d3a,
            roughness: 0.9,
            metalness: 0,
          });

          for (let i = 0; i < 3; i++) {
            const reclinerSeat = new THREE.BoxGeometry(4, 2, 4);
            const chair = new THREE.Mesh(reclinerSeat, reclinerMaterial);
            chair.position.set(-50 + i * 6, 1, -20);
            chair.castShadow = true;
            chair.receiveShadow = true;
            this.scene.add(chair);

            const reclinerBack = new THREE.BoxGeometry(4, 3, 1);
            const back = new THREE.Mesh(reclinerBack, reclinerMaterial);
            back.position.set(-50 + i * 6, 2.5, -22);
            back.castShadow = true;
            this.scene.add(back);
          }
        }

        createBedroomDepartment() {
          // Bedroom sets
          const bedMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6f47,
            roughness: 0.7,
            metalness: 0,
          });

          // King size bed displays
          for (let i = 0; i < 3; i++) {
            const bedFrame = new THREE.BoxGeometry(8, 1, 10);
            const bed = new THREE.Mesh(bedFrame, bedMaterial);
            bed.position.set(30, 0.5, -40 + i * 15);
            bed.castShadow = true;
            bed.receiveShadow = true;
            this.scene.add(bed);

            // Mattress
            const mattressGeometry = new THREE.BoxGeometry(7.5, 2, 9.5);
            const mattressMaterial = new THREE.MeshStandardMaterial({
              color: 0xf0f0f0,
              roughness: 0.9,
              metalness: 0,
            });
            const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
            mattress.position.set(30, 2, -40 + i * 15);
            mattress.castShadow = true;
            this.scene.add(mattress);

            // Headboard
            const headboard = new THREE.BoxGeometry(8, 5, 0.5);
            const headboardMesh = new THREE.Mesh(headboard, bedMaterial);
            headboardMesh.position.set(30, 3, -45 + i * 15);
            headboardMesh.castShadow = true;
            this.scene.add(headboardMesh);
          }

          // Dressers
          const dresserMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.6,
            metalness: 0,
          });

          for (let i = 0; i < 4; i++) {
            const dresser = new THREE.BoxGeometry(5, 4, 2);
            const dresserMesh = new THREE.Mesh(dresser, dresserMaterial);
            dresserMesh.position.set(45, 2, -30 + i * 8);
            dresserMesh.castShadow = true;
            dresserMesh.receiveShadow = true;
            this.scene.add(dresserMesh);
          }
        }

        createElectronicsDepartment() {
          // 90s electronics section
          const shelfMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8,
            metalness: 0.2,
          });

          // TV wall
          const tvWallGeometry = new THREE.BoxGeometry(30, 10, 1);
          const tvWall = new THREE.Mesh(tvWallGeometry, shelfMaterial);
          tvWall.position.set(0, 5, -50);
          tvWall.castShadow = true;
          tvWall.receiveShadow = true;
          this.scene.add(tvWall);

          // CRT TVs on display
          const crtColors = [0x1a1a1a, 0x2d2d2d, 0x0f0f0f];
          for (let i = 0; i < 6; i++) {
            const crtGeometry = new THREE.BoxGeometry(3, 2.5, 2.5);
            const crtMaterial = new THREE.MeshStandardMaterial({
              color: crtColors[i % 3],
              roughness: 0.3,
              metalness: 0.7,
            });
            const crt = new THREE.Mesh(crtGeometry, crtMaterial);
            crt.position.set(-12 + i * 4, 3 + (i % 2) * 3, -48);
            crt.castShadow = true;
            this.scene.add(crt);

            // Screen
            const screenGeometry = new THREE.BoxGeometry(2.5, 2, 0.1);
            const screenMaterial = new THREE.MeshStandardMaterial({
              color: 0x001100,
              roughness: 0.1,
              metalness: 0.9,
              emissive: 0x002200,
              emissiveIntensity: 0.1,
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(-12 + i * 4, 3 + (i % 2) * 3, -47.4);
            this.scene.add(screen);
          }

          // Stereo systems
          const stereoMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.4,
            metalness: 0.6,
          });

          for (let i = 0; i < 4; i++) {
            const stereoGeometry = new THREE.BoxGeometry(4, 2, 1.5);
            const stereo = new THREE.Mesh(stereoGeometry, stereoMaterial);
            stereo.position.set(-20 + i * 5, 1, -45);
            stereo.castShadow = true;
            stereo.receiveShadow = true;
            this.scene.add(stereo);

            // Speakers
            const speakerGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
            const speaker1 = new THREE.Mesh(speakerGeometry, stereoMaterial);
            speaker1.position.set(-22 + i * 5, 1.5, -45);
            speaker1.castShadow = true;
            this.scene.add(speaker1);

            const speaker2 = new THREE.Mesh(speakerGeometry, stereoMaterial);
            speaker2.position.set(-18 + i * 5, 1.5, -45);
            speaker2.castShadow = true;
            this.scene.add(speaker2);
          }
        }

        createAppliancesDepartment() {
          // Refrigerators
          const fridgeMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0f0f0,
            roughness: 0.3,
            metalness: 0.8,
          });

          for (let i = 0; i < 5; i++) {
            const fridgeGeometry = new THREE.BoxGeometry(3, 6, 3);
            const fridge = new THREE.Mesh(fridgeGeometry, fridgeMaterial);
            fridge.position.set(-60, 3, -10 + i * 5);
            fridge.castShadow = true;
            fridge.receiveShadow = true;
            this.scene.add(fridge);

            // Handles
            const handleGeometry = new THREE.BoxGeometry(0.2, 2, 0.2);
            const handleMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.5,
              metalness: 0.9,
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(-58.4, 3, -10 + i * 5);
            this.scene.add(handle);
          }

          // Washing machines
          const washerMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.4,
            metalness: 0.6,
          });

          for (let i = 0; i < 4; i++) {
            const washerGeometry = new THREE.BoxGeometry(3, 3.5, 3);
            const washer = new THREE.Mesh(washerGeometry, washerMaterial);
            washer.position.set(-70, 1.75, -10 + i * 4);
            washer.castShadow = true;
            washer.receiveShadow = true;
            this.scene.add(washer);

            // Control panel
            const panelGeometry = new THREE.BoxGeometry(2.8, 0.5, 0.1);
            const panelMaterial = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.7,
              metalness: 0.3,
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(-70, 3.25, -8.45 + i * 4);
            this.scene.add(panel);
          }

          // Dishwashers
          for (let i = 0; i < 3; i++) {
            const dishwasherGeometry = new THREE.BoxGeometry(2.5, 3, 2.5);
            const dishwasher = new THREE.Mesh(dishwasherGeometry, washerMaterial);
            dishwasher.position.set(-80, 1.5, -5 + i * 4);
            dishwasher.castShadow = true;
            dishwasher.receiveShadow = true;
            this.scene.add(dishwasher);
          }
        }

        createOfficeDepartment() {
          // Office desks
          const deskMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6f47,
            roughness: 0.6,
            metalness: 0,
          });

          for (let i = 0; i < 4; i++) {
            // Desk top
            const deskTopGeometry = new THREE.BoxGeometry(6, 0.2, 3);
            const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
            deskTop.position.set(60, 2.4, 20 + i * 8);
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            this.scene.add(deskTop);

            // Desk legs
            const legGeometry = new THREE.BoxGeometry(0.2, 2.4, 0.2);
            const legPositions = [
              [-2.8, -1.4], [2.8, -1.4], [-2.8, 1.4], [2.8, 1.4]
            ];
            
            legPositions.forEach(([x, z]) => {
              const leg = new THREE.Mesh(legGeometry, deskMaterial);
              leg.position.set(60 + x, 1.2, 20 + i * 8 + z);
              leg.castShadow = true;
              this.scene.add(leg);
            });
          }

          // Office chairs
          const chairMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8,
            metalness: 0.2,
          });

          for (let i = 0; i < 6; i++) {
            const chairSeatGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.3, 16);
            const chairSeat = new THREE.Mesh(chairSeatGeometry, chairMaterial);
            chairSeat.position.set(70, 1.5, 15 + i * 5);
            chairSeat.castShadow = true;
            chairSeat.receiveShadow = true;
            this.scene.add(chairSeat);

            const chairBackGeometry = new THREE.BoxGeometry(2, 2, 0.3);
            const chairBack = new THREE.Mesh(chairBackGeometry, chairMaterial);
            chairBack.position.set(70, 2.5, 14.5 + i * 5);
            chairBack.castShadow = true;
            this.scene.add(chairBack);

            // Chair base
            const baseGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.2, 8);
            const base = new THREE.Mesh(baseGeometry, chairMaterial);
            base.position.set(70, 0.6, 15 + i * 5);
            base.castShadow = true;
            this.scene.add(base);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 8);
            for (let j = 0; j < 5; j++) {
              const wheelAngle = (j / 5) * Math.PI * 2;
              const wheel = new THREE.Mesh(wheelGeometry, chairMaterial);
              wheel.position.set(
                70 + Math.cos(wheelAngle) * 0.8,
                0.1,
                15 + i * 5 + Math.sin(wheelAngle) * 0.8
              );
              wheel.rotation.z = Math.PI / 2;
              this.scene.add(wheel);
            }
          }

          // File cabinets
          const cabinetMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.7,
            metalness: 0.5,
          });

          for (let i = 0; i < 3; i++) {
            const cabinetGeometry = new THREE.BoxGeometry(2, 4, 2.5);
            const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
            cabinet.position.set(80, 2, 20 + i * 6);
            cabinet.castShadow = true;
            cabinet.receiveShadow = true;
            this.scene.add(cabinet);

            // Drawer handles
            for (let j = 0; j < 4; j++) {
              const handleGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.1);
              const handle = new THREE.Mesh(handleGeometry, chairMaterial);
              handle.position.set(80, 0.5 + j * 1, 21.25 + i * 6);
              this.scene.add(handle);
            }
          }
        }

        createCheckoutArea() {
          // Checkout counters
          const counterMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.6,
            metalness: 0.3,
          });

          for (let i = 0; i < 4; i++) {
            const counterGeometry = new THREE.BoxGeometry(4, 3, 8);
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(-20 + i * 10, 1.5, 80);
            counter.castShadow = true;
            counter.receiveShadow = true;
            this.scene.add(counter);

            // Register (90s style)
            const registerGeometry = new THREE.BoxGeometry(2, 1, 2);
            const registerMaterial = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.4,
              metalness: 0.6,
            });
            const register = new THREE.Mesh(registerGeometry, registerMaterial);
            register.position.set(-20 + i * 10, 3.5, 80);
            register.castShadow = true;
            this.scene.add(register);

            // Conveyor belt
            const beltGeometry = new THREE.BoxGeometry(3, 0.1, 6);
            const beltMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.9,
              metalness: 0.1,
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.set(-20 + i * 10, 3.05, 78);
            this.scene.add(belt);
          }
        }

        createDepartmentSigns() {
          // Department hanging signs with text
          const loader = new THREE.FontLoader();
          const textMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.3,
            metalness: 0.1,
            emissive: 0xffffff,
            emissiveIntensity: 0.3,
          });

          const signMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.3,
            metalness: 0.1,
            emissive: 0x1a4d2e,
            emissiveIntensity: 0.2,
          });

          const signs = [
            { text: "LIVING ROOM", pos: [-40, 9, -25] },
            { text: "BEDROOM", pos: [35, 9, -25] },
            { text: "ELECTRONICS", pos: [0, 9, -45] },
            { text: "APPLIANCES", pos: [-70, 9, 0] },
            { text: "OFFICE", pos: [70, 9, 25] },
            { text: "CHECKOUT", pos: [0, 9, 75] }
          ];

          // Create signs with simulated text using boxes
          signs.forEach(sign => {
            const signGeometry = new THREE.BoxGeometry(15, 2, 0.5);
            const signMesh = new THREE.Mesh(signGeometry, signMaterial);
            signMesh.position.set(...sign.pos);
            signMesh.castShadow = true;
            this.scene.add(signMesh);

            // Simulated text using white boxes
            const letterWidth = 0.8;
            const letterSpacing = 0.9;
            const totalWidth = sign.text.length * letterSpacing;
            const startX = -totalWidth / 2 + letterSpacing / 2;

            for (let i = 0; i < sign.text.length; i++) {
              if (sign.text[i] !== ' ') {
                const letterGeometry = new THREE.BoxGeometry(letterWidth, 1.2, 0.1);
                const letter = new THREE.Mesh(letterGeometry, textMaterial);
                letter.position.set(
                  sign.pos[0] + startX + i * letterSpacing,
                  sign.pos[1],
                  sign.pos[2] + 0.31
                );
                this.scene.add(letter);
              }
            }

            // Sign posts
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const postMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.8,
              metalness: 0.5,
            });

            const post1 = new THREE.Mesh(postGeometry, postMaterial);
            post1.position.set(sign.pos[0] - 7, 10.5, sign.pos[2]);
            this.scene.add(post1);

            const post2 = new THREE.Mesh(postGeometry, postMaterial);
            post2.position.set(sign.pos[0] + 7, 10.5, sign.pos[2]);
            this.scene.add(post2);
          });

          // Main entrance sign
          const entranceSignGeometry = new THREE.BoxGeometry(40, 5, 1);
          const entranceSign = new THREE.Mesh(entranceSignGeometry, signMaterial);
          entranceSign.position.set(0, 8, 98);
          entranceSign.castShadow = true;
          this.scene.add(entranceSign);

          // "NEBRASKA FURNITURE MART" text on entrance
          const entranceText = "NEBRASKA FURNITURE MART";
          const entranceLetterWidth = 1.2;
          const entranceLetterSpacing = 1.4;
          const entranceTotalWidth = entranceText.length * entranceLetterSpacing;
          const entranceStartX = -entranceTotalWidth / 2 + entranceLetterSpacing / 2;

          for (let i = 0; i < entranceText.length; i++) {
            if (entranceText[i] !== ' ') {
              const letterGeometry = new THREE.BoxGeometry(entranceLetterWidth, 2.5, 0.2);
              const letter = new THREE.Mesh(letterGeometry, textMaterial);
              letter.position.set(
                entranceStartX + i * entranceLetterSpacing,
                8,
                98.51
              );
              this.scene.add(letter);
            }
          }
        }

        createPriceTags() {
          // Yellow sale tags everywhere (90s style)
          const tagMaterial = new THREE.MeshStandardMaterial({
            color: 0xffeb3b,
            roughness: 0.8,
            metalness: 0,
            emissive: 0xffeb3b,
            emissiveIntensity: 0.3,
          });

          // Random price tags throughout the store
          for (let i = 0; i < 50; i++) {
            const tagGeometry = new THREE.BoxGeometry(1, 0.6, 0.1);
            const tag = new THREE.Mesh(tagGeometry, tagMaterial);
            tag.position.set(
              (Math.random() - 0.5) * 160,
              Math.random() * 3 + 1,
              (Math.random() - 0.5) * 140
            );
            tag.rotation.y = Math.random() * Math.PI;
            this.scene.add(tag);
          }

          // "SALE" banners
          const bannerMaterial = new THREE.MeshStandardMaterial({
            color: 0xc41e3a,
            roughness: 0.6,
            metalness: 0,
            emissive: 0xc41e3a,
            emissiveIntensity: 0.2,
          });

          for (let i = 0; i < 6; i++) {
            const bannerGeometry = new THREE.BoxGeometry(8, 3, 0.2);
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            banner.position.set(
              (Math.random() - 0.5) * 140,
              7,
              (Math.random() - 0.5) * 120
            );
            banner.rotation.y = Math.random() * Math.PI;
            this.scene.add(banner);
          }
        }

        createEffects() {
          // Minimal particle effects for performance
          this.effects = [];

          // Simple dust particles
          const particleGeometry = new THREE.BufferGeometry();
          const particleCount = 50;
          const positions = new Float32Array(particleCount * 3);

          for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 180;
            positions[i + 1] = Math.random() * 10 + 2;
            positions[i + 2] = (Math.random() - 0.5) * 180;
          }

          particleGeometry.setAttribute(
            "position",
            new THREE.BufferAttribute(positions, 3)
          );

          const particleMaterial = new THREE.PointsMaterial({
            size: 0.1,
            color: 0xcccccc,
            transparent: true,
            opacity: 0.5,
          });

          const particles = new THREE.Points(particleGeometry, particleMaterial);
          particles.update = function(time) {
            this.rotation.y = time * 0.05;
          };
          this.effects.push(particles);
          this.scene.add(particles);
        }

        createPortals() {
          // Place portals near the entrance/exit area
          const numPortals = Math.min(this.worlds.length, 8);

          for (let i = 0; i < numPortals; i++) {
            const world = this.worlds[i];
            const angle = (i / numPortals) * Math.PI * 2;

            const portalGroup = new THREE.Group();

            // Portal frame
            const frameGeometry = new THREE.TorusGeometry(3, 0.3, 16, 32);
            const frameMaterial = new THREE.MeshStandardMaterial({
              color: CURRENT_WORLD.primaryColor,
              emissive: CURRENT_WORLD.primaryColor,
              emissiveIntensity: 0.5,
              metalness: 0.8,
              roughness: 0.2,
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);

            // Portal surface
            const portalGeometry = new THREE.CircleGeometry(2.7, 64);
            const portalMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(CURRENT_WORLD.portalColor1) },
                color2: { value: new THREE.Color(CURRENT_WORLD.portalColor2) },
                distortion: { value: 0 },
              },
              vertexShader: portalVertexShader,
              fragmentShader: portalFragmentShader,
              transparent: true,
              side: THREE.DoubleSide,
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.z = 0.1;

            portalGroup.add(frame);
            portalGroup.add(portal);

            // Position portals in the entrance area
            portalGroup.position.x = Math.cos(angle) * 15;
            portalGroup.position.z = 90 + Math.sin(angle) * 8;
            portalGroup.position.y = 2;
            portalGroup.rotation.y = -angle + Math.PI;

            const light = new THREE.PointLight(CURRENT_WORLD.primaryColor, 1, 10);
            light.position.copy(portalGroup.position);
            this.scene.add(light);

            portal.userData = {
              world: world, material: portalMaterial,
              light: light,
              url: world.url || world.raw_url,
              name: world.name,
              description: world.description || `Enter the ${world.name} world`,
              particles: portalGroup.userData.particles,
            };

            this.portals.push(portal);
            this.scene.add(portalGroup);

            // Platform
            const platformGeometry = new THREE.CylinderGeometry(4, 4, 0.5, 32);
            const platformMaterial = new THREE.MeshStandardMaterial({
              color: 0x444444,
              metalness: 0.5,
              roughness: 0.5,
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.copy(portalGroup.position);
            platform.position.y = 0.25;
            platform.receiveShadow = true;
            platform.castShadow = true;
            this.scene.add(platform);
          }
        }

        buildInheritanceParams() {
          const params = new URLSearchParams();

          params.set(
            "from",
            window.location.pathname.split("/").pop() ||
              "nebraska_furniture_mart_90s.html"
          );
          params.set("fromName", CURRENT_WORLD.name);
          params.set("moveSpeed", this.moveSpeed.toString());
          params.set("lookSpeed", this.lookSpeed.toString());
          params.set(
            "ambientColor",
            CURRENT_WORLD.ambientColor.toString(16).padStart(6, "0")
          );
          params.set(
            "fogColor",
            CURRENT_WORLD.fogColor.toString(16).padStart(6, "0")
          );
          params.set(
            "portalColor1",
            CURRENT_WORLD.portalColor1.toString(16).padStart(6, "0")
          );
          params.set(
            "portalColor2",
            CURRENT_WORLD.portalColor2.toString(16).padStart(6, "0")
          );
          params.set("particleCount", CURRENT_WORLD.particleCount.toString());
          params.set("cameraHeight", this.camera.position.y.toString());
          params.set("fogNear", CURRENT_WORLD.fogNear.toString());
          params.set("fogFar", CURRENT_WORLD.fogFar.toString());

          return params.toString();
        }

        setupEventListeners() {
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });

          if (this.isMobile) {
            this.setupMobileControls();
          } else {
            this.setupDesktopControls();
          }
        }

        setupDesktopControls() {
          window.addEventListener("keydown", (e) => {
            const key = e.key.toLowerCase();
            if (key in this.keys) {
              this.keys[key] = true;
            }
            if (e.key === " ") {
              this.keys[" "] = true;
              e.preventDefault();
            }
          });

          window.addEventListener("keyup", (e) => {
            const key = e.key.toLowerCase();
            if (key in this.keys) {
              this.keys[key] = false;
            }
            if (e.key === " ") {
              this.keys[" "] = false;
            }
          });

          this.renderer.domElement.addEventListener("click", (e) => {
            if (!this.isPointerLocked) {
              this.renderer.domElement.requestPointerLock();
            } else {
              this.raycaster.setFromCamera(
                new THREE.Vector2(0, 0),
                this.camera
              );
              const intersects = this.raycaster.intersectObjects(this.portals);

              if (intersects.length > 0) {
                const portal = intersects[0].object;
                if (portal.userData.url) {
                  this.enterWorld(portal.userData.url);
                }
              }
            }
          });

          document.addEventListener("pointerlockchange", () => {
            this.isPointerLocked =
              document.pointerLockElement === this.renderer.domElement;
          });

          document.addEventListener("mousemove", (e) => {
            if (this.isPointerLocked) {
              this.rotation.y -= e.movementX * this.lookSpeed;
              this.rotation.x -= e.movementY * this.lookSpeed;
              this.rotation.x = Math.max(
                -Math.PI / 2,
                Math.min(Math.PI / 2, this.rotation.x)
              );
            }
          });
        }

        setupMobileControls() {
          const lookArea = document.getElementById("look-area");

          lookArea.addEventListener(
            "touchstart",
            (e) => {
              const touch = e.touches[0];
              const rect = this.renderer.domElement.getBoundingClientRect();
              const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
              const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

              this.raycaster.setFromCamera(
                new THREE.Vector2(x, y),
                this.camera
              );
              const intersects = this.raycaster.intersectObjects(this.portals);

              if (intersects.length > 0) {
                const portal = intersects[0].object;
                if (portal.userData.url) {
                  e.preventDefault();
                  this.enterWorld(portal.userData.url);
                  return;
                }
              }

              this.lookTouch = {
                id: touch.identifier,
                startX: touch.clientX,
                startY: touch.clientY,
                currentX: touch.clientX,
                currentY: touch.clientY,
              };
            },
            { passive: true }
          );

          lookArea.addEventListener(
            "touchmove",
            (e) => {
              if (!this.lookTouch) return;

              for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                if (touch.identifier === this.lookTouch.id) {
                  const deltaX = touch.clientX - this.lookTouch.currentX;
                  const deltaY = touch.clientY - this.lookTouch.currentY;

                  this.rotation.y -= deltaX * this.lookSpeed * 2;
                  this.rotation.x -= deltaY * this.lookSpeed * 2;
                  this.rotation.x = Math.max(
                    -Math.PI / 2,
                    Math.min(Math.PI / 2, this.rotation.x)
                  );

                  this.lookTouch.currentX = touch.clientX;
                  this.lookTouch.currentY = touch.clientY;

                  e.preventDefault();
                  break;
                }
              }
            },
            { passive: false }
          );

          lookArea.addEventListener(
            "touchend",
            (e) => {
              for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                  this.lookTouch = null;
                  break;
                }
              }
            },
            { passive: true }
          );

          const joystick = document.getElementById("movement-joystick");
          const handle = document.getElementById("movement-handle");

          joystick.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              e.stopPropagation();

              const touch = e.touches[0];
              this.joystickTouch = {
                id: touch.identifier,
              };

              this.joystickActive = true;
              this.updateJoystick(touch, joystick, handle);
            },
            { passive: false }
          );

          joystick.addEventListener(
            "touchmove",
            (e) => {
              if (!this.joystickActive || !this.joystickTouch) return;

              e.preventDefault();
              e.stopPropagation();

              for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                if (touch.identifier === this.joystickTouch.id) {
                  this.updateJoystick(touch, joystick, handle);
                  break;
                }
              }
            },
            { passive: false }
          );

          joystick.addEventListener(
            "touchend",
            (e) => {
              for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (
                  this.joystickTouch &&
                  touch.identifier === this.joystickTouch.id
                ) {
                  this.joystickActive = false;
                  this.joystickTouch = null;
                  this.joystickVector.set(0, 0);
                  handle.style.transform = "translate(-50%, -50%)";

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }
              }
            },
            { passive: false }
          );

          window.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            return false;
          });
        }

        updateJoystick(touch, joystick, handle) {
          const rect = joystick.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          let deltaX = touch.clientX - centerX;
          let deltaY = touch.clientY - centerY;

          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const maxDistance = rect.width / 2 - 25;

          if (distance > maxDistance) {
            deltaX = (deltaX / distance) * maxDistance;
            deltaY = (deltaY / distance) * maxDistance;
          }

          handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

          this.joystickVector.x = deltaX / maxDistance;
          this.joystickVector.y = -deltaY / maxDistance;
        }

        updateMovement() {
          const forward = new THREE.Vector3();
          const right = new THREE.Vector3();

          this.camera.getWorldDirection(forward);
          forward.y = 0;
          forward.normalize();

          right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

          // Apply damping
          if (CURRENT_WORLD.enablePhysics) {
            this.velocity.x *= 0.9;
            this.velocity.z *= 0.9;
          }

          if (this.isMobile) {
            if (this.joystickActive) {
              const moveForward = forward.multiplyScalar(
                this.joystickVector.y * this.moveSpeed
              );
              const moveRight = right.multiplyScalar(
                this.joystickVector.x * this.moveSpeed
              );

              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(moveForward);
                this.velocity.add(moveRight);
              } else {
                this.camera.position.add(moveForward);
                this.camera.position.add(moveRight);
              }
            }
          } else {
            if (this.keys.w) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(forward.multiplyScalar(this.moveSpeed));
              } else {
                this.camera.position.add(
                  forward.multiplyScalar(this.moveSpeed)
                );
              }
            }
            if (this.keys.s) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(forward.multiplyScalar(-this.moveSpeed));
              } else {
                this.camera.position.add(
                  forward.multiplyScalar(-this.moveSpeed)
                );
              }
            }
            if (this.keys.a) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(right.multiplyScalar(-this.moveSpeed));
              } else {
                this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
              }
            }
            if (this.keys.d) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(right.multiplyScalar(this.moveSpeed));
              } else {
                this.camera.position.add(right.multiplyScalar(this.moveSpeed));
              }
            }

            // Vertical movement
            if (CURRENT_WORLD.enableFlying) {
              if (this.keys.q) this.camera.position.y -= this.moveSpeed;
              if (this.keys.e) this.camera.position.y += this.moveSpeed;
            }

            // Jumping
            if (CURRENT_WORLD.enablePhysics && this.keys[" "] && this.canJump) {
              this.velocity.y = CURRENT_WORLD.jumpForce;
              this.canJump = false;
            }
          }

          // Apply physics
          if (CURRENT_WORLD.enablePhysics) {
            this.velocity.y -= CURRENT_WORLD.gravity * 0.01;
            this.camera.position.add(this.velocity);

            // Ground collision
            if (this.camera.position.y < CURRENT_WORLD.cameraHeight) {
              this.camera.position.y = CURRENT_WORLD.cameraHeight;
              this.velocity.y = 0;
              this.canJump = true;
            }
          }

          // Keep camera within store bounds
          this.camera.position.x = Math.max(-95, Math.min(95, this.camera.position.x));
          this.camera.position.z = Math.max(-95, Math.min(95, this.camera.position.z));

          this.camera.rotation.order = "YXZ";
          this.camera.rotation.y = this.rotation.y;
          this.camera.rotation.x = this.rotation.x;
        }

        updateHover() {
          this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
          const intersects = this.raycaster.intersectObjects(this.portals);

          if (intersects.length > 0) {
            const portal = intersects[0].object;

            if (portal !== this.hoveredPortal) {
              this.hoveredPortal = portal;

              this.tooltipTitle.textContent = portal.userData.name;
              this.tooltipDescription.textContent = portal.userData.description;
              this.tooltip.classList.add("visible");

              const vector = new THREE.Vector3();
              portal.getWorldPosition(vector);
              vector.project(this.camera);

              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

              this.tooltip.style.left = `${Math.min(
                x + 20,
                window.innerWidth - 320
              )}px`;
              this.tooltip.style.top = `${Math.min(
                y - 50,
                window.innerHeight - 200
              )}px`;
            }
          } else {
            if (this.hoveredPortal) {
              this.hoveredPortal = null;
              this.tooltip.classList.remove("visible");
            }
          }
        }

        async enterWorld(url) {
          try {
            document.getElementById("loading").style.display = "block";
            document.getElementById("loading").innerHTML =
              "Quantum tunneling...";

            // Transition effect
            const transitionDuration = 1500;
            const startTime = Date.now();

            const transitionEffect = setInterval(() => {
              const elapsed = Date.now() - startTime;
              const progress = elapsed / transitionDuration;

              if (progress >= 1) {
                clearInterval(transitionEffect);
                this.loadNewWorld(url);
              } else {
                this.renderer.domElement.style.filter = `hue-rotate(${
                  progress * 360
                }deg) blur(${progress * 10}px)`;
                this.renderer.domElement.style.opacity = 1 - progress * 0.5;
              }
            }, 16);
          } catch (error) {
            console.error("Error entering world:", error);
            document.getElementById("loading").innerHTML =
              "Portal malfunction. Please try again.";
            setTimeout(() => {
              document.getElementById("loading").style.display = "none";
            }, 3000);
          }
        }

        async loadNewWorld(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Failed to load world (${response.status})`);
            }

            let htmlContent = await response.text();

            const inheritanceParams = this.buildInheritanceParams();

            sessionStorage.setItem(
              "worldInheritanceParams",
              "?" + inheritanceParams
            );

            const inheritanceData = {
              params: inheritanceParams,
              timestamp: Date.now(),
            };
            localStorage.setItem(
              "worldTransition",
              JSON.stringify(inheritanceData)
            );

            const paramScript = `<script>
                        window.INJECTED_PARAMS = '?${inheritanceParams}';
                        sessionStorage.setItem('worldInheritanceParams', '?${inheritanceParams}');
                        console.log('Injected params:', window.INJECTED_PARAMS);
                    <\/script>`;

            htmlContent = htmlContent.replace("<body>", `<body>${paramScript}`);

            const blob = new Blob([htmlContent], { type: "text/html" });
            const blobUrl = URL.createObjectURL(blob);

            window.location.href = blobUrl;
          } catch (error) {
            console.error("Error loading world:", error);
            document.getElementById("loading").innerHTML =
              "Failed to establish connection.";
            this.renderer.domElement.style.filter = "none";
            this.renderer.domElement.style.opacity = "1";
            setTimeout(() => {
              document.getElementById("loading").style.display = "none";
            }, 3000);
          }
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          const time = this.clock.getElapsedTime();
          const delta = this.clock.getDelta();

          this.updateMovement();
          this.updateHover();

          // Animate portals
          this.portals.forEach((portal, index) => {
            if (portal.userData.material) {
              portal.userData.material.uniforms.time.value = time;

              const intensity = 0.5 + Math.sin(time * 2 + index) * 0.3;
              portal.userData.light.intensity = intensity;

              if (portal.userData.particles) {
                portal.userData.particles.rotation.z = time * 0.5;
              }
            }

            portal.rotation.z = Math.sin(time * 0.5 + index) * 0.1;
          });

          // Animate particles
          if (this.particles) {
            this.particles.rotation.y = time * 0.05;

            if (this.particleSystem) {
              this.particleSystem.update(delta);
            }
          }

          // Animate structures
          if (this.structures) {
            this.structures.forEach((structure, i) => {
              if (structure.userData.animation === "rotate") {
                structure.rotation.y =
                  time * (structure.userData.animationSpeed || 1);
              } else if (structure.userData.animation === "float") {
                structure.position.y =
                  structure.userData.baseY +
                  Math.sin(time * (structure.userData.animationSpeed || 1)) * 2;
              } else if (structure.userData.animation === "pulse") {
                const scale =
                  1 +
                  Math.sin(
                    time * (structure.userData.animationSpeed || 1) * 2
                  ) *
                    0.1;
                structure.scale.setScalar(scale);
              }
            });
          }

          // Animate effects
          if (this.effects) {
            this.effects.forEach((effect, i) => {
              if (effect.update) {
                effect.update(time, delta);
              }
            });
          }

          // Animate lights
          this.scene.traverse((child) => {
            if (
              child.isLight &&
              child.type === "PointLight" &&
              child.userData.animationType
            ) {
              const time = this.clock.getElapsedTime();
              const animType = child.userData.animationType;

              if (animType === "pulse") {
                child.intensity =
                  child.userData.baseIntensity *
                  (0.5 + Math.sin(time * 2) * 0.5);
              } else if (animType === "orbit") {
                const angle = time * 0.5;
                const radius = 10;
                child.position.x =
                  child.userData.basePosition.x + Math.cos(angle) * radius;
                child.position.z =
                  child.userData.basePosition.z + Math.sin(angle) * radius;
              } else if (animType === "flicker") {
                child.intensity =
                  child.userData.baseIntensity * (0.8 + Math.random() * 0.2);
              }
            }
          });

          this.renderer.render(this.scene, this.camera);
        }
      }

      // Initialize world
      window.addEventListener("DOMContentLoaded", () => {
        const navigator = new WorldNavigator();
        navigator.init();
      });

      // Prevent pull-to-refresh on mobile
      let lastY = 0;
      window.addEventListener(
        "touchstart",
        (e) => {
          lastY = e.touches[0].clientY;
        },
        { passive: true }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          const y = e.touches[0].clientY;
          const scrollingUp = y > lastY;
          const atTop = window.pageYOffset === 0;

          if (scrollingUp && atTop) {
            e.preventDefault();
          }
          lastY = y;
        },
        { passive: false }
      );
    </script>
  </body>
</html>