<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <title>Nebraska Furniture Mart 90s</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
        -webkit-overflow-scrolling: touch;
      }

      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      .world-ui {
        position: absolute;
        top: env(safe-area-inset-top, 20px);
        left: env(safe-area-inset-left, 20px);
        z-index: 1001;
        pointer-events: none;
      }

      .world-title {
        font-size: 3em;
        font-weight: 100;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        background: linear-gradient(45deg, #2e5a74, #d0b783, #879195, #ffd700);
        background-size: 400% 100%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: shimmer 8s ease-in-out infinite;
        margin-bottom: 10px;
        text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      }

      @keyframes shimmer {
        0%,
        100% {
          background-position: 0% 50%;
          filter: hue-rotate(0deg);
        }
        50% {
          background-position: 100% 50%;
          filter: hue-rotate(30deg);
        }
      }

      .world-description {
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.6);
        max-width: 400px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }

      .world-origin {
        position: absolute;
        top: env(safe-area-inset-top, 20px);
        right: env(safe-area-inset-right, 20px);
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: none;
      }

      .world-origin.visible {
        display: block;
      }

      .origin-label {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.8em;
      }

      .origin-world {
        color: #2e5a74;
        font-weight: 500;
      }

      .controls-hint {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 30px);
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        padding: 15px 30px;
        border-radius: 25px;
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        text-align: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        pointer-events: none;
      }

      .portal-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid transparent;
        border-image: linear-gradient(45deg, #2e5a74, #d0b783, #879195) 1;
        border-radius: 15px;
        padding: 20px;
        max-width: 300px;
        display: none;
        z-index: 1002;
        pointer-events: none;
        backdrop-filter: blur(10px);
      }

      .portal-tooltip.visible {
        display: block;
      }

      .tooltip-title {
        font-size: 1.4em;
        font-weight: 300;
        margin-bottom: 10px;
        background: linear-gradient(45deg, #2e5a74, #d0b783);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .tooltip-description {
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.5;
      }

      .tooltip-instruction {
        font-size: 0.85em;
        color: #879195;
        text-align: center;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .mobile-controls {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
        left: 0;
        right: 0;
        display: none;
        z-index: 1001;
        padding: 0 20px;
        pointer-events: none;
      }

      .mobile-controls.show {
        display: block;
      }

      .controls-container {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
      }

      .joystick-container {
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(46, 90, 116, 0.5);
        border-radius: 50%;
        position: relative;
        pointer-events: auto;
        touch-action: none;
        box-shadow: 0 0 20px rgba(46, 90, 116, 0.5);
      }

      .joystick-handle {
        width: 50px;
        height: 50px;
        background: radial-gradient(circle, #2e5a74, #d0b783);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      }

      .look-area {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 200px;
        z-index: 999;
        touch-action: none;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.4);
        font-weight: 200;
        letter-spacing: 0.1em;
        z-index: 2000;
      }

      .loading::after {
        content: "";
        display: block;
        width: 100px;
        height: 100px;
        margin: 30px auto;
        border: 2px solid transparent;
        border-top-color: #2e5a74;
        border-radius: 50%;
        animation: quantum-spin 1s ease-in-out infinite;
      }

      @keyframes quantum-spin {
        0% {
          transform: rotate(0deg) scale(1);
          border-top-color: #2e5a74;
        }
        50% {
          transform: rotate(180deg) scale(1.2);
          border-top-color: #d0b783;
        }
        100% {
          transform: rotate(360deg) scale(1);
          border-top-color: #2e5a74;
        }
      }

      @media (max-width: 768px) {
        .world-title {
          font-size: 2em;
        }

        .world-description {
          font-size: 1em;
          max-width: 300px;
        }
      }

      @supports (-webkit-touch-callout: none) {
        body {
          position: fixed;
          height: 100vh;
          height: -webkit-fill-available;
        }

        #three-container {
          height: 100vh;
          height: -webkit-fill-available;
        }
      }
    </style>
  </head>
  <body>
    <div id="three-container"></div>

    <div class="look-area" id="look-area"></div>

    <div class="world-ui">
      <h1 class="world-title" id="world-title">NEBRASKA FURNITURE MART 90S</h1>
      <p class="world-description" id="world-description">
        Step into a faithfully recreated Nebraska Furniture Mart as it was in
        the 1990s, with sprawling showrooms, dazzling displays of furniture,
        vintage electronics, and bustling retail energy.
      </p>
    </div>

    <div class="world-origin" id="world-origin">
      <span class="origin-label">Arrived from:</span>
      <span class="origin-world" id="origin-world-name">Origin</span>
    </div>

    <div class="controls-hint" id="controls-hint">
      WASD: Move | Mouse: Look | Click: Travel | Space: Jump
    </div>

    <div class="mobile-controls" id="mobile-controls">
      <div class="controls-container">
        <div class="joystick-container" id="movement-joystick">
          <div class="joystick-handle" id="movement-handle"></div>
        </div>
      </div>
    </div>

    <div class="portal-tooltip" id="portal-tooltip">
      <h3 class="tooltip-title"></h3>
      <p class="tooltip-description"></p>
      <p class="tooltip-instruction">Click to enter</p>
    </div>

    <div class="loading" id="loading">
      Materializing nebraska furniture mart 90s...
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Configuration
      const REPO_OWNER = "kody-w";
      const REPO_NAME = "nexus-worlds";
      const BRANCH = "main";

      // World configuration
      const DEFAULT_WORLD_ATTRIBUTES = {
        name: "Nebraska Furniture Mart 90s",
        description:
          "Step into a faithfully recreated Nebraska Furniture Mart as it was in the 1990s, with sprawling showrooms, dazzling displays of furniture, vintage electronics, and bustling retail energy.",
        ambientColor: 0xfff8e6,
        fogColor: 0xf5f2ed,
        groundColor: 0xd4c9b8,
        skyTopColor: 0xffffff,
        skyBottomColor: 0xe8e4dd,
        primaryColor: 0x1a4d2e,
        secondaryColor: 0xc41e3a,
        tertiaryColor: 0x4169e1,
        emissiveColor: 0xffeb3b,
        moveSpeed: 0.15,
        lookSpeed: 0.002,
        portalColor1: 0x1a4d2e,
        portalColor2: 0xc41e3a,
        particleCount: 50,
        cameraHeight: 1.7,
        fogNear: 20,
        fogFar: 280,
        enablePhysics: true,
        enableFlying: false,
        gravity: 0.5,
        jumpForce: 0.3,
      };

      // Shader definitions
      const skyVertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      const skyFragmentShader = `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `;

      const portalVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      const portalFragmentShader = `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform float distortion;
            varying vec2 vUv;
            
            float noise(vec2 p) {
                return sin(p.x * 10.0) * sin(p.y * 10.0);
            }
            
            void main() {
                vec2 center = vUv - 0.5;
                float dist = length(center);
                float angle = atan(center.y, center.x);
                
                // Spiral pattern
                float spiral = sin(dist * 20.0 - time * 3.0 + angle * 5.0);
                
                // Distortion
                vec2 distortedUV = vUv;
                if (distortion > 0.0) {
                    distortedUV += sin(time + vUv * 10.0) * 0.02 * distortion;
                }
                
                // Noise
                float n = noise(distortedUV * 10.0 + time);
                
                // Mix colors
                vec3 color = mix(color1, color2, spiral * 0.5 + 0.5);
                color += n * 0.1;
                
                // Alpha falloff
                float alpha = 1.0 - smoothstep(0.35, 0.5, dist);
                alpha *= 0.8 + sin(time * 2.0 + dist * 10.0) * 0.2;
                
                gl_FragColor = vec4(color, alpha);
            }
        `;

      // Parse inherited attributes
      function parseInheritedAttributes() {
        let paramString = window.INJECTED_PARAMS || window.location.search;

        if (window.location.protocol === "blob:") {
          const storedParams = sessionStorage.getItem("worldInheritanceParams");
          if (storedParams) {
            paramString = storedParams;
          }
        }

        if (!paramString || paramString === "?") {
          const transitionData = localStorage.getItem("worldTransition");
          if (transitionData) {
            try {
              const data = JSON.parse(transitionData);
              if (Date.now() - data.timestamp < 5000) {
                paramString = "?" + data.params;
              }
            } catch (e) {
              console.error("Error parsing transition data:", e);
            }
            localStorage.removeItem("worldTransition");
          }
        }

        const params = new URLSearchParams(paramString);
        const inherited = {};

        inherited.sourceWorld = params.get("from") || null;
        inherited.sourceWorldName = params.get("fromName") || null;

        if (params.has("moveSpeed"))
          inherited.moveSpeed = parseFloat(params.get("moveSpeed"));
        if (params.has("lookSpeed"))
          inherited.lookSpeed = parseFloat(params.get("lookSpeed"));
        if (params.has("ambientColor"))
          inherited.ambientColor = parseInt(params.get("ambientColor"), 16);
        if (params.has("fogColor"))
          inherited.fogColor = parseInt(params.get("fogColor"), 16);
        if (params.has("portalColor1"))
          inherited.portalColor1 = parseInt(params.get("portalColor1"), 16);
        if (params.has("portalColor2"))
          inherited.portalColor2 = parseInt(params.get("portalColor2"), 16);
        if (params.has("particleCount"))
          inherited.particleCount = parseInt(params.get("particleCount"));
        if (params.has("cameraHeight"))
          inherited.cameraHeight = parseFloat(params.get("cameraHeight"));
        if (params.has("fogNear"))
          inherited.fogNear = parseFloat(params.get("fogNear"));
        if (params.has("fogFar"))
          inherited.fogFar = parseFloat(params.get("fogFar"));

        console.log("Parsed inherited attributes:", inherited);
        return inherited;
      }

      const inheritedAttributes = parseInheritedAttributes();
      const CURRENT_WORLD = {
        ...DEFAULT_WORLD_ATTRIBUTES,
        ...inheritedAttributes,
      };

      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
        (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);

      const isIOS =
        /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

      class WorldNavigator {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.composer = null;
          this.portals = [];
          this.worlds = [];
          this.structures = [];
          this.effects = [];
          this.raycaster = new THREE.Raycaster();
          this.clock = new THREE.Clock();

          this.moveSpeed = CURRENT_WORLD.moveSpeed;
          this.lookSpeed = CURRENT_WORLD.lookSpeed;
          this.keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            q: false,
            e: false,
            " ": false,
          };
          this.rotation = { x: 0, y: 0 };
          this.velocity = new THREE.Vector3();
          this.canJump = true;

          this.isMobile = isMobile;
          this.isIOS = isIOS;
          this.joystickActive = false;
          this.joystickVector = new THREE.Vector2();
          this.lookTouch = null;
          this.joystickTouch = null;

          this.hoveredPortal = null;
          this.tooltip = document.getElementById("portal-tooltip");
          this.tooltipTitle = this.tooltip.querySelector(".tooltip-title");
          this.tooltipDescription = this.tooltip.querySelector(
            ".tooltip-description"
          );
          this.isPointerLocked = false;

          this.inheritedAttributes = inheritedAttributes;

          if (this.isIOS) {
            document.body.addEventListener(
              "touchmove",
              (e) => {
                if (e.target === document.body) {
                  e.preventDefault();
                }
              },
              { passive: false }
            );
          }
        }

        async init() {
          if (this.inheritedAttributes.sourceWorldName) {
            const originDiv = document.getElementById("world-origin");
            const originName = document.getElementById("origin-world-name");
            originName.textContent = this.inheritedAttributes.sourceWorldName;
            originDiv.classList.add("visible");
          }

          setTimeout(() => {
            document.getElementById("loading").style.display = "none";
          }, 2000);

          document.getElementById("world-title").textContent =
            CURRENT_WORLD.name.toUpperCase();
          document.getElementById("world-description").textContent =
            CURRENT_WORLD.description;

          this.setupScene();
          this.setupLighting();
          await this.loadWorlds();
          this.createEnvironment();
          this.createStructures();
          this.createEffects();
          this.createPortals();
          this.setupEventListeners();

          // Physics system initialization
          this.physicsEnabled = true;
          this.gravity = 0.5;
          this.jumpForce = 0.3;

          // Ground collision check
          this.checkGroundCollision = function () {
            // Simple height-based collision
            const groundHeight = this.getGroundHeightAt(
              this.camera.position.x,
              this.camera.position.z
            );
            return (
              this.camera.position.y <=
              groundHeight + CURRENT_WORLD.cameraHeight
            );
          };

          this.getGroundHeightAt = function (x, z) {
            // Sample terrain height at position
            // This is simplified - in reality you'd raycast or sample the terrain geometry
            return 0;
          };

          if (this.isMobile) {
            document.getElementById("controls-hint").textContent =
              "Touch & drag to look around, Use joystick to move, Tap on portals to travel";
            document.getElementById("mobile-controls").classList.add("show");

            const instruction = this.tooltip.querySelector(
              ".tooltip-instruction"
            );
            if (instruction) {
              instruction.textContent = "Tap to enter";
            }
          }

          this.animate();
        }

        setupScene() {
          this.scene = new THREE.Scene();
          this.scene.fog = new THREE.Fog(CURRENT_WORLD.fogColor, CURRENT_WORLD.fogNear, CURRENT_WORLD.fogFar);

          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(0, CURRENT_WORLD.cameraHeight, 145);

          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "high-performance",
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoft;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.2;
          document
            .getElementById("three-container")
            .appendChild(this.renderer.domElement);
        }

        setupLighting() {
          // Bright warehouse-style fluorescent lighting
          const ambientLight = new THREE.AmbientLight(CURRENT_WORLD.ambientColor, 0.8);
          this.scene.add(ambientLight);

          // Main overhead lighting
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(30, 50, 20);
          dirLight.castShadow = true;
          if (dirLight.castShadow) {
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 300;
            dirLight.shadow.camera.left = -150;
            dirLight.shadow.camera.right = 150;
            dirLight.shadow.camera.top = 150;
            dirLight.shadow.camera.bottom = -150;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
          }
          this.scene.add(dirLight);

          // Fluorescent strip lights throughout the store
          for (let i = 0; i < 12; i++) {
            const stripLight = new THREE.RectAreaLight(0xffffff, 2, 15, 2);
            stripLight.position.set(
              (i % 3 - 1) * 35,
              11.5,
              -60 + Math.floor(i / 3) * 40
            );
            stripLight.lookAt(
              stripLight.position.x,
              0,
              stripLight.position.z
            );
            this.scene.add(stripLight);
          }

          // Department spotlights
          const spotLight1 = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5);
          spotLight1.position.set(-30, 15, -20);
          spotLight1.target.position.set(-30, 0, -20);
          spotLight1.castShadow = true;
          this.scene.add(spotLight1);
          this.scene.add(spotLight1.target);

          const spotLight2 = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5);
          spotLight2.position.set(30, 15, 20);
          spotLight2.target.position.set(30, 0, 20);
          spotLight2.castShadow = true;
          this.scene.add(spotLight2);
          this.scene.add(spotLight2.target);

          // Entrance spotlights
          const entranceLight1 = new THREE.SpotLight(0xffffff, 1.5, 40, Math.PI / 4, 0.3);
          entranceLight1.position.set(-15, 10, 95);
          entranceLight1.target.position.set(-15, 0, 70);
          entranceLight1.castShadow = true;
          this.scene.add(entranceLight1);
          this.scene.add(entranceLight1.target);

          const entranceLight2 = new THREE.SpotLight(0xffffff, 1.5, 40, Math.PI / 4, 0.3);
          entranceLight2.position.set(15, 10, 95);
          entranceLight2.target.position.set(15, 0, 70);
          entranceLight2.castShadow = true;
          this.scene.add(entranceLight2);
          this.scene.add(entranceLight2.target);
        }

        async loadWorlds() {
          try {
            const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
            const response = await fetch(apiUrl);

            if (!response.ok) {
              throw new Error(`GitHub API error: ${response.status}`);
            }

            const data = await response.json();

            this.worlds = data.tree
              .filter(
                (item) =>
                  item.type === "blob" &&
                  item.path.endsWith(".html") &&
                  !item.path.includes("/") &&
                  !item.path.toLowerCase().includes("index") &&
                  !item.path.toLowerCase().includes("readme") &&
                  !item.path
                    .toLowerCase()
                    .includes("nebraska_furniture_mart_90s")
              )
              .map((item) => ({
                path: item.path,
                name: this.formatWorldName(item.path),
                url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
              }));

            // Always include portal to hub
            this.worlds.unshift({
              name: "Nexus Hub",
              description: "Return to the central hub",
              url:
                "https://raw.githubusercontent.com/" +
                REPO_OWNER +
                "/" +
                REPO_NAME +
                "/" +
                BRANCH +
                "/index.html",
            });

            console.log(`Found ${this.worlds.length} worlds to connect`);
          } catch (error) {
            console.error("Error loading worlds:", error);
            this.worlds = this.getDemoWorlds();
          }
        }

        formatWorldName(filename) {
          return filename
            .replace(".html", "")
            .replace(/[-_]/g, " ")
            .replace(/\b\w/g, (l) => l.toUpperCase());
        }

        getDemoWorlds() {
          return [
            { name: "Nexus Hub", description: "Return to the central hub" },
            {
              name: "Crystal Caves",
              description: "A mystical underground realm",
            },
            {
              name: "Sky Islands",
              description: "Floating islands in the clouds",
            },
            { name: "Neon City", description: "Cyberpunk metropolis" },
            { name: "Quantum Realm", description: "Where physics breaks down" },
          ];
        }

        createEnvironment() {
          // Parking lot asphalt
          const asphaltGeometry = new THREE.PlaneGeometry(400, 300, 20, 20);
          const asphaltMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.9,
            metalness: 0.1,
          });

          const parkingLot = new THREE.Mesh(asphaltGeometry, asphaltMaterial);
          parkingLot.rotation.x = -Math.PI / 2;
          parkingLot.position.set(0, -0.01, 250);
          parkingLot.receiveShadow = true;
          this.scene.add(parkingLot);

          // Parking lines
          const lineMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            roughness: 0.8,
            metalness: 0,
          });

          for (let i = -10; i <= 10; i++) {
            if (i === 0) continue; // Skip center for driving lane
            const lineGeometry = new THREE.BoxGeometry(0.3, 0.02, 15);
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(i * 8, 0, 180);
            line.receiveShadow = true;
            this.scene.add(line);
          }

          // Parked cars
          const carColors = [0x1a1a1a, 0x8b0000, 0x00008b, 0x2f4f2f, 0x696969];
          for (let i = 0; i < 15; i++) {
            const carBody = new THREE.BoxGeometry(4, 1.5, 8);
            const carMaterial = new THREE.MeshStandardMaterial({
              color: carColors[i % carColors.length],
              roughness: 0.3,
              metalness: 0.7,
            });
            const car = new THREE.Mesh(carBody, carMaterial);
            const row = Math.floor(i / 5);
            const col = i % 5;
            car.position.set(-60 + col * 30, 0.75, 160 + row * 25);
            car.castShadow = true;
            car.receiveShadow = true;
            this.scene.add(car);

            // Car roof
            const roofGeometry = new THREE.BoxGeometry(3, 0.8, 4);
            const roof = new THREE.Mesh(roofGeometry, carMaterial);
            roof.position.set(-60 + col * 30, 1.9, 160 + row * 25);
            roof.castShadow = true;
            this.scene.add(roof);
          }

          // Store exterior walls - tan/beige brick texture
          const exteriorWallMaterial = new THREE.MeshStandardMaterial({
            color: 0xc8b88b,
            roughness: 0.8,
            metalness: 0,
          });

          // Extended front wall with entrance
          const frontWallExt1 = new THREE.BoxGeometry(120, 15, 4);
          const frontExt1 = new THREE.Mesh(frontWallExt1, exteriorWallMaterial);
          frontExt1.position.set(-80, 7.5, 102);
          frontExt1.castShadow = true;
          frontExt1.receiveShadow = true;
          this.scene.add(frontExt1);

          const frontWallExt2 = new THREE.BoxGeometry(120, 15, 4);
          const frontExt2 = new THREE.Mesh(frontWallExt2, exteriorWallMaterial);
          frontExt2.position.set(80, 7.5, 102);
          frontExt2.castShadow = true;
          frontExt2.receiveShadow = true;
          this.scene.add(frontExt2);

          // Store entrance frame
          const entranceFrameMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.5,
            metalness: 0.8,
          });

          const entranceFrame = new THREE.BoxGeometry(40, 12, 2);
          const frame = new THREE.Mesh(entranceFrame, entranceFrameMaterial);
          frame.position.set(0, 6, 101);
          frame.castShadow = true;
          this.scene.add(frame);

          // Sliding doors (will animate)
          this.createSlidingDoors();

          // Warehouse floor - polished concrete with subtle texture
          const groundGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
          const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.3,
            metalness: 0.1,
            wireframe: false,
          });

          const ground = new THREE.Mesh(groundGeometry, groundMaterial);
          ground.rotation.x = -Math.PI / 2;
          ground.receiveShadow = true;
          this.scene.add(ground);

          // Floor patterns - main aisles
          const aisleGeometry = new THREE.PlaneGeometry(4, 180);
          const aisleMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.5,
            metalness: 0,
          });

          for (let i = -40; i <= 40; i += 20) {
            const aisle = new THREE.Mesh(aisleGeometry, aisleMaterial);
            aisle.rotation.x = -Math.PI / 2;
            aisle.position.set(i, 0.01, 0);
            aisle.receiveShadow = true;
            this.scene.add(aisle);
          }

          // Cross aisles
          const crossAisleGeometry = new THREE.PlaneGeometry(180, 4);
          for (let i = -60; i <= 60; i += 30) {
            const crossAisle = new THREE.Mesh(crossAisleGeometry, aisleMaterial);
            crossAisle.rotation.x = -Math.PI / 2;
            crossAisle.position.set(0, 0.01, i);
            crossAisle.receiveShadow = true;
            this.scene.add(crossAisle);
          }

          // Ceiling
          const ceilingGeometry = new THREE.PlaneGeometry(200, 200);
          const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0f0f0,
            roughness: 0.8,
            metalness: 0,
            side: THREE.DoubleSide,
          });

          const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
          ceiling.rotation.x = Math.PI / 2;
          ceiling.position.y = 12;
          ceiling.receiveShadow = true;
          this.scene.add(ceiling);

          // Ceiling grid pattern with support beams
          const gridSize = 2;
          const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc });
          
          for (let i = -100; i <= 100; i += gridSize) {
            const points = [];
            points.push(new THREE.Vector3(i, 11.9, -100));
            points.push(new THREE.Vector3(i, 11.9, 100));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            this.scene.add(line);
          }

          for (let i = -100; i <= 100; i += gridSize) {
            const points = [];
            points.push(new THREE.Vector3(-100, 11.9, i));
            points.push(new THREE.Vector3(100, 11.9, i));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            this.scene.add(line);
          }

          // Support pillars
          const pillarMaterial = new THREE.MeshStandardMaterial({
            color: 0xe8e4dd,
            roughness: 0.7,
            metalness: 0.1,
          });

          for (let x = -60; x <= 60; x += 40) {
            for (let z = -60; z <= 60; z += 40) {
              const pillarGeometry = new THREE.CylinderGeometry(1, 1, 12, 8);
              const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
              pillar.position.set(x, 6, z);
              pillar.castShadow = true;
              pillar.receiveShadow = true;
              this.scene.add(pillar);
            }
          }

          // Warehouse walls
          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xe8e4dd,
            roughness: 0.8,
            metalness: 0,
          });

          // Back wall
          const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(200, 12, 2),
            wallMaterial
          );
          backWall.position.set(0, 6, -100);
          backWall.castShadow = true;
          backWall.receiveShadow = true;
          this.scene.add(backWall);

          // Front wall sections (with entrance)
          const frontWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(80, 12, 2),
            wallMaterial
          );
          frontWall1.position.set(-60, 6, 100);
          frontWall1.castShadow = true;
          frontWall1.receiveShadow = true;
          this.scene.add(frontWall1);

          const frontWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(80, 12, 2),
            wallMaterial
          );
          frontWall2.position.set(60, 6, 100);
          frontWall2.castShadow = true;
          frontWall2.receiveShadow = true;
          this.scene.add(frontWall2);

          // Side walls
          const sideWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(2, 12, 200),
            wallMaterial
          );
          sideWall1.position.set(-100, 6, 0);
          sideWall1.castShadow = true;
          sideWall1.receiveShadow = true;
          this.scene.add(sideWall1);

          const sideWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(2, 12, 200),
            wallMaterial
          );
          sideWall2.position.set(100, 6, 0);
          sideWall2.castShadow = true;
          sideWall2.receiveShadow = true;
          this.scene.add(sideWall2);

          // Outdoor lighting poles
          const poleMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.8,
            metalness: 0.5,
          });

          for (let i = 0; i < 6; i++) {
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 20, 8);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set((i % 2 === 0 ? -1 : 1) * 100, 10, 150 + Math.floor(i / 2) * 50);
            pole.castShadow = true;
            this.scene.add(pole);

            // Parking lot light
            const lightGeometry = new THREE.BoxGeometry(4, 1, 4);
            const lightBox = new THREE.Mesh(lightGeometry, poleMaterial);
            lightBox.position.set((i % 2 === 0 ? -1 : 1) * 100, 20, 150 + Math.floor(i / 2) * 50);
            lightBox.castShadow = true;
            this.scene.add(lightBox);

            // Add actual light
            const parkingLight = new THREE.PointLight(0xfff8e1, 0.8, 50);
            parkingLight.position.copy(lightBox.position);
            parkingLight.position.y -= 1;
            this.scene.add(parkingLight);
          }
        }

        createSlidingDoors() {
          // Sliding glass doors
          const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x88ccff,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.9,
          });

          this.leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(19, 10, 0.5),
            glassMaterial
          );
          this.leftDoor.position.set(-9.5, 5, 101);
          this.leftDoor.castShadow = true;
          this.scene.add(this.leftDoor);

          this.rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(19, 10, 0.5),
            glassMaterial
          );
          this.rightDoor.position.set(9.5, 5, 101);
          this.rightDoor.castShadow = true;
          this.scene.add(this.rightDoor);

          // Door frames
          const doorFrameMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.7,
            metalness: 0.5,
          });

          const frameTop = new THREE.BoxGeometry(40, 1, 0.5);
          const topFrame = new THREE.Mesh(frameTop, doorFrameMaterial);
          topFrame.position.set(0, 10.5, 101);
          this.scene.add(topFrame);

          // Door sensor zone
          this.doorSensorZone = new THREE.Box3(
            new THREE.Vector3(-20, 0, 95),
            new THREE.Vector3(20, 10, 107)
          );
          this.doorsOpen = false;
        }

        createStructures() {
          // Create comprehensive store layout
          this.createEntranceDisplays();
          this.createCustomerServiceDesk();
          this.createLivingRoomDepartment();
          this.createBedroomDepartment();
          this.createElectronicsDepartment();
          this.createAppliancesDepartment();
          this.createOfficeDepartment();
          this.createRugSection();
          this.createLampSection();
          this.createMattressSection();
          this.createKidsSection();
          this.createClearanceSection();
          this.createCheckoutArea();
          this.createDepartmentSigns();
          this.createPriceTags();
          this.createNPCs();
        }

        createEntranceDisplays() {
          // Grand entrance featured displays with massive "WELCOME" signage
          
          // Giant NFM Logo Display
          const logoBackingGeometry = new THREE.BoxGeometry(30, 8, 2);
          const logoBackingMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.3,
            metalness: 0.1,
            emissive: 0x1a4d2e,
            emissiveIntensity: 0.2,
          });
          const logoBacking = new THREE.Mesh(logoBackingGeometry, logoBackingMaterial);
          logoBacking.position.set(0, 8, 90);
          logoBacking.castShadow = true;
          this.scene.add(logoBacking);

          // "NFM" letters
          const letterMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.1,
            emissive: 0xffffff,
            emissiveIntensity: 0.3,
          });

          // N
          const nGeometry = new THREE.BoxGeometry(1, 6, 0.5);
          const n1 = new THREE.Mesh(nGeometry, letterMaterial);
          n1.position.set(-10, 8, 91);
          this.scene.add(n1);
          const n2 = new THREE.Mesh(nGeometry, letterMaterial);
          n2.position.set(-6, 8, 91);
          this.scene.add(n2);
          const nDiagonal = new THREE.BoxGeometry(5.7, 1, 0.5);
          const n3 = new THREE.Mesh(nDiagonal, letterMaterial);
          n3.position.set(-8, 8, 91);
          n3.rotation.z = -Math.PI / 4;
          this.scene.add(n3);

          // F
          const fVertical = new THREE.Mesh(nGeometry, letterMaterial);
          fVertical.position.set(-2, 8, 91);
          this.scene.add(fVertical);
          const fTop = new THREE.BoxGeometry(4, 1, 0.5);
          const f1 = new THREE.Mesh(fTop, letterMaterial);
          f1.position.set(0, 10.5, 91);
          this.scene.add(f1);
          const fMiddle = new THREE.BoxGeometry(3, 1, 0.5);
          const f2 = new THREE.Mesh(fMiddle, letterMaterial);
          f2.position.set(-0.5, 8, 91);
          this.scene.add(f2);

          // M
          const m1 = new THREE.Mesh(nGeometry, letterMaterial);
          m1.position.set(4, 8, 91);
          this.scene.add(m1);
          const m2 = new THREE.Mesh(nGeometry, letterMaterial);
          m2.position.set(10, 8, 91);
          this.scene.add(m2);
          const mPeak1 = new THREE.BoxGeometry(3.5, 1, 0.5);
          const m3 = new THREE.Mesh(mPeak1, letterMaterial);
          m3.position.set(5.5, 10, 91);
          m3.rotation.z = Math.PI / 6;
          this.scene.add(m3);
          const m4 = new THREE.Mesh(mPeak1, letterMaterial);
          m4.position.set(8.5, 10, 91);
          m4.rotation.z = -Math.PI / 6;
          this.scene.add(m4);

          // Feature display platforms with raised edges
          const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.7,
            metalness: 0.2,
          });

          const platformEdgeMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.8,
            metalness: 0.3,
          });
          
          // Platform 1 - Living room vignette
          const platform1 = new THREE.BoxGeometry(25, 0.5, 25);
          const displayPlatform1 = new THREE.Mesh(platform1, platformMaterial);
          displayPlatform1.position.set(-30, 0.25, 65);
          displayPlatform1.receiveShadow = true;
          displayPlatform1.castShadow = true;
          this.scene.add(displayPlatform1);

          // Platform edges
          const edge1 = new THREE.BoxGeometry(25, 0.8, 0.5);
          const platformEdge1 = new THREE.Mesh(edge1, platformEdgeMaterial);
          platformEdge1.position.set(-30, 0.65, 77.75);
          this.scene.add(platformEdge1);

          // Featured leather sectional
          const leatherMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a2511,
            roughness: 0.4,
            metalness: 0.1,
          });

          const sectionalBase = new THREE.BoxGeometry(18, 2.5, 8);
          const sectional = new THREE.Mesh(sectionalBase, leatherMaterial);
          sectional.position.set(-30, 1.5, 65);
          sectional.castShadow = true;
          this.scene.add(sectional);

          const sectionalBack = new THREE.BoxGeometry(18, 4, 2);
          const sectionBack = new THREE.Mesh(sectionalBack, leatherMaterial);
          sectionBack.position.set(-30, 3, 61);
          sectionBack.castShadow = true;
          this.scene.add(sectionBack);

          const sectionalSide = new THREE.BoxGeometry(6, 2.5, 8);
          const sectionSide = new THREE.Mesh(sectionalSide, leatherMaterial);
          sectionSide.position.set(-42, 1.5, 65);
          sectionSide.castShadow = true;
          this.scene.add(sectionSide);

          const sideBack = new THREE.BoxGeometry(2, 4, 8);
          const sideBackRest = new THREE.Mesh(sideBack, leatherMaterial);
          sideBackRest.position.set(-44, 3, 65);
          sideBackRest.castShadow = true;
          this.scene.add(sideBackRest);

          // Glass coffee table
          const glassTableMaterial = new THREE.MeshStandardMaterial({
            color: 0x88ccff,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.9,
          });

          const tableTop = new THREE.BoxGeometry(8, 0.3, 4);
          const coffeeTableTop = new THREE.Mesh(tableTop, glassTableMaterial);
          coffeeTableTop.position.set(-30, 1.5, 70);
          coffeeTableTop.castShadow = true;
          this.scene.add(coffeeTableTop);

          const tableLegMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.3,
            metalness: 0.8,
          });

          const legPositions = [[-33, -27], [-33, -27], [-27, -33], [-27, -33]];
          legPositions.forEach(([x, z], i) => {
            const leg = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const tableLeg = new THREE.Mesh(leg, tableLegMaterial);
            tableLeg.position.set(x, 0.75, 68 + (i < 2 ? 0 : 4));
            this.scene.add(tableLeg);
          });

          // Platform 2 - Bedroom showcase
          const platform2 = new THREE.BoxGeometry(25, 0.5, 25);
          const displayPlatform2 = new THREE.Mesh(platform2, platformMaterial);
          displayPlatform2.position.set(30, 0.25, 65);
          displayPlatform2.receiveShadow = true;
          displayPlatform2.castShadow = true;
          this.scene.add(displayPlatform2);

          const edge2 = new THREE.BoxGeometry(25, 0.8, 0.5);
          const platformEdge2 = new THREE.Mesh(edge2, platformEdgeMaterial);
          platformEdge2.position.set(30, 0.65, 77.75);
          this.scene.add(platformEdge2);

          // King size sleigh bed
          const sleighBedMaterial = new THREE.MeshStandardMaterial({
            color: 0x5c3317,
            roughness: 0.5,
            metalness: 0.1,
          });

          const bedFrame = new THREE.BoxGeometry(10, 2, 12);
          const sleighBed = new THREE.Mesh(bedFrame, sleighBedMaterial);
          sleighBed.position.set(30, 1.25, 65);
          sleighBed.castShadow = true;
          this.scene.add(sleighBed);

          // Curved headboard
          const headboardGeometry = new THREE.BoxGeometry(10, 6, 1.5);
          const headboard = new THREE.Mesh(headboardGeometry, sleighBedMaterial);
          headboard.position.set(30, 4, 59);
          headboard.castShadow = true;
          this.scene.add(headboard);

          // Curved footboard
          const footboardGeometry = new THREE.BoxGeometry(10, 3, 1);
          const footboard = new THREE.Mesh(footboardGeometry, sleighBedMaterial);
          footboard.position.set(30, 2, 71);
          footboard.castShadow = true;
          this.scene.add(footboard);

          // Luxury mattress with pillow top
          const mattressGeometry = new THREE.BoxGeometry(9, 3, 11);
          const mattressMaterial = new THREE.MeshStandardMaterial({
            color: 0xf5f5dc,
            roughness: 0.9,
            metalness: 0,
          });
          const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
          mattress.position.set(30, 3.5, 65);
          mattress.castShadow = true;
          this.scene.add(mattress);

          // Pillows
          const pillowGeometry = new THREE.BoxGeometry(3, 0.8, 2);
          const pillow1 = new THREE.Mesh(pillowGeometry, mattressMaterial);
          pillow1.position.set(27, 5.4, 60);
          pillow1.rotation.z = 0.1;
          this.scene.add(pillow1);

          const pillow2 = new THREE.Mesh(pillowGeometry, mattressMaterial);
          pillow2.position.set(33, 5.4, 60);
          pillow2.rotation.z = -0.1;
          this.scene.add(pillow2);

          // Matching nightstands
          const nightstandMaterial = new THREE.MeshStandardMaterial({
            color: 0x5c3317,
            roughness: 0.5,
            metalness: 0.1,
          });

          for (let i = 0; i < 2; i++) {
            const nightstand = new THREE.BoxGeometry(3, 2.5, 3);
            const stand = new THREE.Mesh(nightstand, nightstandMaterial);
            stand.position.set(i === 0 ? 22 : 38, 1.25, 60);
            stand.castShadow = true;
            this.scene.add(stand);

            // Drawer handles
            const handleGeometry = new THREE.BoxGeometry(1.5, 0.2, 0.2);
            const handleMaterial = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.5,
              metalness: 0.9,
            });
            const handle1 = new THREE.Mesh(handleGeometry, handleMaterial);
            handle1.position.set(i === 0 ? 22 : 38, 1.8, 61.6);
            this.scene.add(handle1);

            const handle2 = new THREE.Mesh(handleGeometry, handleMaterial);
            handle2.position.set(i === 0 ? 22 : 38, 0.7, 61.6);
            this.scene.add(handle2);
          }

          // Center entertainment wall unit
          const entertainmentWallGeometry = new THREE.BoxGeometry(20, 10, 3);
          const entertainmentMaterial = new THREE.MeshStandardMaterial({
            color: 0x2f1b14,
            roughness: 0.6,
            metalness: 0,
          });
          const entertainmentWall = new THREE.Mesh(entertainmentWallGeometry, entertainmentMaterial);
          entertainmentWall.position.set(0, 5, 55);
          entertainmentWall.castShadow = true;
          this.scene.add(entertainmentWall);

          // TV opening
          const tvOpeningGeometry = new THREE.BoxGeometry(10, 6, 1);
          const tvOpeningMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8,
            metalness: 0,
          });
          const tvOpening = new THREE.Mesh(tvOpeningGeometry, tvOpeningMaterial);
          tvOpening.position.set(0, 5, 56.6);
          this.scene.add(tvOpening);

          // 32" CRT TV
          const crtTVGeometry = new THREE.BoxGeometry(5, 4, 4);
          const crtMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.2,
            metalness: 0.8,
          });
          const bigCRT = new THREE.Mesh(crtTVGeometry, crtMaterial);
          bigCRT.position.set(0, 5, 55);
          bigCRT.castShadow = true;
          this.scene.add(bigCRT);

          // CRT Screen
          const screenGeometry = new THREE.BoxGeometry(4, 3, 0.1);
          const screenMaterial = new THREE.MeshStandardMaterial({
            color: 0x001100,
            roughness: 0.1,
            metalness: 0.9,
            emissive: 0x003300,
            emissiveIntensity: 0.1,
          });
          const crtScreen = new THREE.Mesh(screenGeometry, screenMaterial);
          crtScreen.position.set(0, 5, 57.1);
          this.scene.add(crtScreen);

          // VCR on shelf below
          const vcrGeometry = new THREE.BoxGeometry(3, 0.8, 2);
          const vcrMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.6,
            metalness: 0.4,
          });
          const vcr = new THREE.Mesh(vcrGeometry, vcrMaterial);
          vcr.position.set(0, 2, 56);
          this.scene.add(vcr);

          // "GRAND OPENING SALE" banner
          const bannerGeometry = new THREE.BoxGeometry(40, 6, 0.5);
          const bannerMaterial = new THREE.MeshStandardMaterial({
            color: 0xc41e3a,
            roughness: 0.4,
            metalness: 0,
            emissive: 0xc41e3a,
            emissiveIntensity: 0.3,
          });
          const saleBanner = new THREE.Mesh(bannerGeometry, bannerMaterial);
          saleBanner.position.set(0, 6, 45);
          saleBanner.rotation.x = -0.2;
          this.scene.add(saleBanner);

          // Banner text (simulated)
          const bannerTextMaterial = new THREE.MeshStandardMaterial({
            color: 0xffeb3b,
            roughness: 0.3,
            metalness: 0,
            emissive: 0xffeb3b,
            emissiveIntensity: 0.4,
          });

          const textBlocks = ["GRAND", "OPENING", "SALE!"];
          textBlocks.forEach((text, i) => {
            const blockGeometry = new THREE.BoxGeometry(text.length * 1.5, 2, 0.2);
            const textBlock = new THREE.Mesh(blockGeometry, bannerTextMaterial);
            textBlock.position.set(0, 6 + (i - 1) * 2.2, 45.3);
            textBlock.rotation.x = -0.2;
            this.scene.add(textBlock);
          });

          // Welcome mat with "WELCOME TO NFM" texture
          const matGeometry = new THREE.BoxGeometry(12, 0.1, 8);
          const matMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.95,
            metalness: 0,
          });
          const welcomeMat = new THREE.Mesh(matGeometry, matMaterial);
          welcomeMat.position.set(0, 0.05, 85);
          welcomeMat.receiveShadow = true;
          this.scene.add(welcomeMat);

          // Shopping cart corral
          const corralMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.7,
            metalness: 0.8,
          });

          // Cart corral rails
          const railGeometry = new THREE.BoxGeometry(15, 1.5, 0.2);
          const leftRail = new THREE.Mesh(railGeometry, corralMaterial);
          leftRail.position.set(-45, 0.75, 85);
          this.scene.add(leftRail);

          const rightRail = new THREE.Mesh(railGeometry, corralMaterial);
          rightRail.position.set(-45, 0.75, 91);
          this.scene.add(rightRail);

          // Shopping carts
          const cartMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.7,
            metalness: 0.8,
          });

          for (let i = 0; i < 10; i++) {
            const cartBasket = new THREE.BoxGeometry(2, 1.5, 3);
            const cart = new THREE.Mesh(cartBasket, cartMaterial);
            cart.position.set(-52 + i * 1.5, 1.5, 88);
            cart.castShadow = true;
            this.scene.add(cart);

            // Cart handle
            const handleGeometry = new THREE.BoxGeometry(2, 0.2, 0.2);
            const handle = new THREE.Mesh(handleGeometry, cartMaterial);
            handle.position.set(-52 + i * 1.5, 2.5, 86.5);
            this.scene.add(handle);

            // Cart wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
            const wheelPositions = [
              [-0.8, -1.2], [0.8, -1.2], [-0.8, 1.2], [0.8, 1.2]
            ];
            
            wheelPositions.forEach(([x, z]) => {
              const wheel = new THREE.Mesh(wheelGeometry, cartMaterial);
              wheel.position.set(-52 + i * 1.5 + x, 0.3, 88 + z);
              wheel.rotation.z = Math.PI / 2;
              this.scene.add(wheel);
            });
          }

          // Promotional standees with weekly specials
          const standeeMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.8,
            metalness: 0,
          });

          for (let i = 0; i < 4; i++) {
            const standeeBase = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const base = new THREE.Mesh(standeeBase, corralMaterial);
            base.position.set((i % 2 === 0 ? -1 : 1) * 35, 0.25, 75 + Math.floor(i / 2) * 8);
            base.castShadow = true;
            this.scene.add(base);

            const standeeBoard = new THREE.BoxGeometry(4, 5, 0.3);
            const board = new THREE.Mesh(standeeBoard, standeeMaterial);
            board.position.set((i % 2 === 0 ? -1 : 1) * 35, 3, 75 + Math.floor(i / 2) * 8);
            board.castShadow = true;
            this.scene.add(board);

            // Sale sticker
            const stickerGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.1, 16);
            const stickerMaterial = new THREE.MeshStandardMaterial({
              color: 0xffeb3b,
              roughness: 0.5,
              metalness: 0,
              emissive: 0xffeb3b,
              emissiveIntensity: 0.3,
            });
            const sticker = new THREE.Mesh(stickerGeometry, stickerMaterial);
            sticker.position.set((i % 2 === 0 ? -1 : 1) * 35, 4.5, 75.2 + Math.floor(i / 2) * 8);
            sticker.rotation.x = Math.PI / 2;
            this.scene.add(sticker);
          }
        }

        createCustomerServiceDesk() {
          // Large customer service desk near entrance
          const deskMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6f47,
            roughness: 0.6,
            metalness: 0,
          });

          // Main desk structure
          const deskGeometry = new THREE.BoxGeometry(20, 3.5, 8);
          const serviceDesk = new THREE.Mesh(deskGeometry, deskMaterial);
          serviceDesk.position.set(45, 1.75, 85);
          serviceDesk.castShadow = true;
          serviceDesk.receiveShadow = true;
          this.scene.add(serviceDesk);

          // Desk counter top
          const counterTopGeometry = new THREE.BoxGeometry(21, 0.3, 9);
          const counterMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.4,
            metalness: 0.1,
          });
          const counterTop = new THREE.Mesh(counterTopGeometry, counterMaterial);
          counterTop.position.set(45, 3.65, 85);
          this.scene.add(counterTop);

          // Customer Service sign
          const signBackingGeometry = new THREE.BoxGeometry(15, 3, 0.5);
          const signBackingMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.3,
            metalness: 0.1,
            emissive: 0x1a4d2e,
            emissiveIntensity: 0.2,
          });
          const signBacking = new THREE.Mesh(signBackingGeometry, signBackingMaterial);
          signBacking.position.set(45, 7, 81);
          this.scene.add(signBacking);

          // Sign text
          const signTextMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0,
            emissive: 0xffffff,
            emissiveIntensity: 0.3,
          });

          const textLine1 = new THREE.BoxGeometry(10, 1, 0.1);
          const customerText = new THREE.Mesh(textLine1, signTextMaterial);
          customerText.position.set(45, 7.5, 81.3);
          this.scene.add(customerText);

          const textLine2 = new THREE.BoxGeometry(8, 0.8, 0.1);
          const serviceText = new THREE.Mesh(textLine2, signTextMaterial);
          serviceText.position.set(45, 6.5, 81.3);
          this.scene.add(serviceText);

          // Computers (90s CRT monitors)
          for (let i = 0; i < 3; i++) {
            const monitorBase = new THREE.BoxGeometry(1, 0.2, 1);
            const monitorMaterial = new THREE.MeshStandardMaterial({
              color: 0xf5f5dc,
              roughness: 0.7,
              metalness: 0.2,
            });
            const base = new THREE.Mesh(monitorBase, monitorMaterial);
            base.position.set(40 + i * 5, 3.9, 85);
            this.scene.add(base);

            const monitorGeometry = new THREE.BoxGeometry(1.5, 1.2, 1.2);
            const monitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
            monitor.position.set(40 + i * 5, 4.6, 85);
            this.scene.add(monitor);

            const screenGeometry = new THREE.BoxGeometry(1.2, 0.9, 0.1);
            const screenMaterial = new THREE.MeshStandardMaterial({
              color: 0x001100,
              roughness: 0.1,
              metalness: 0.9,
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(40 + i * 5, 4.6, 85.6);
            this.scene.add(screen);

            // Keyboard
            const keyboardGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.6);
            const keyboard = new THREE.Mesh(keyboardGeometry, monitorMaterial);
            keyboard.position.set(40 + i * 5, 3.8, 86.5);
            this.scene.add(keyboard);
          }

          // Brochure racks
          const rackMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.8,
            metalness: 0.5,
          });

          for (let i = 0; i < 2; i++) {
            const rackGeometry = new THREE.BoxGeometry(2, 4, 1);
            const rack = new THREE.Mesh(rackGeometry, rackMaterial);
            rack.position.set(35 + i * 20, 2, 82);
            rack.castShadow = true;
            this.scene.add(rack);

            // Brochures
            for (let j = 0; j < 4; j++) {
              const brochureGeometry = new THREE.BoxGeometry(1.5, 0.5, 0.1);
              const brochureMaterial = new THREE.MeshStandardMaterial({
                color: j % 2 === 0 ? 0xffeb3b : 0x87ceeb,
                roughness: 0.8,
                metalness: 0,
              });
              const brochure = new THREE.Mesh(brochureGeometry, brochureMaterial);
              brochure.position.set(35 + i * 20, 0.5 + j * 1, 82.6);
              this.scene.add(brochure);
            }
          }
        }

        createLivingRoomDepartment() {
          // Massive living room showroom
          
          // Department platform
          const platformGeometry = new THREE.BoxGeometry(60, 0.3, 50);
          const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            roughness: 0.8,
            metalness: 0,
          });
          const livingRoomPlatform = new THREE.Mesh(platformGeometry, platformMaterial);
          livingRoomPlatform.position.set(-40, 0.15, -25);
          livingRoomPlatform.receiveShadow = true;
          this.scene.add(livingRoomPlatform);

          // Multiple sofa groupings
          const sofaColors = [0x8b4513, 0x2f4f4f, 0x483d8b, 0x8b0000, 0x696969];
          const sofaStyles = ['sectional', 'loveseat', 'sofa', 'recliner_sofa', 'sleeper'];

          for (let i = 0; i < 8; i++) {
            const groupX = -60 + (i % 4) * 20;
            const groupZ = -40 + Math.floor(i / 4) * 25;
            const sofaColor = sofaColors[i % sofaColors.length];
            
            const sofaMaterial = new THREE.MeshStandardMaterial({
              color: sofaColor,
              roughness: 0.8,
              metalness: 0,
            });

            if (i % 3 === 0) {
              // Sectional
              const sectionMain = new THREE.BoxGeometry(12, 3, 5);
              const mainSofa = new THREE.Mesh(sectionMain, sofaMaterial);
              mainSofa.position.set(groupX, 1.8, groupZ);
              mainSofa.castShadow = true;
              this.scene.add(mainSofa);

              const sectionSide = new THREE.BoxGeometry(5, 3, 8);
              const sideSofa = new THREE.Mesh(sectionSide, sofaMaterial);
              sideSofa.position.set(groupX - 8.5, 1.8, groupZ);
              sideSofa.castShadow = true;
              this.scene.add(sideSofa);

              const backMain = new THREE.BoxGeometry(12, 3.5, 1.5);
              const mainBack = new THREE.Mesh(backMain, sofaMaterial);
              mainBack.position.set(groupX, 3.5, groupZ - 3.25);
              mainBack.castShadow = true;
              this.scene.add(mainBack);

              const backSide = new THREE.BoxGeometry(1.5, 3.5, 8);
              const sideBack = new THREE.Mesh(backSide, sofaMaterial);
              sideBack.position.set(groupX - 10.75, 3.5, groupZ);
              sideBack.castShadow = true;
              this.scene.add(sideBack);
            } else if (i % 3 === 1) {
              // Traditional sofa
              const sofaBase = new THREE.BoxGeometry(10, 2.5, 4);
              const sofa = new THREE.Mesh(sofaBase, sofaMaterial);
              sofa.position.set(groupX, 1.5, groupZ);
              sofa.castShadow = true;
              this.scene.add(sofa);

              const sofaBack = new THREE.BoxGeometry(10, 3, 1);
              const back = new THREE.Mesh(sofaBack, sofaMaterial);
              back.position.set(groupX, 3, groupZ - 2.5);
              back.castShadow = true;
              this.scene.add(back);

              // Arms
              const armGeometry = new THREE.BoxGeometry(1, 2, 4);
              const leftArm = new THREE.Mesh(armGeometry, sofaMaterial);
              leftArm.position.set(groupX - 4.5, 2, groupZ);
              leftArm.castShadow = true;
              this.scene.add(leftArm);

              const rightArm = new THREE.Mesh(armGeometry, sofaMaterial);
              rightArm.position.set(groupX + 4.5, 2, groupZ);
              rightArm.castShadow = true;
              this.scene.add(rightArm);
            } else {
              // Loveseat
              const loveseatBase = new THREE.BoxGeometry(6, 2.5, 4);
              const loveseat = new THREE.Mesh(loveseatBase, sofaMaterial);
              loveseat.position.set(groupX, 1.5, groupZ);
              loveseat.castShadow = true;
              this.scene.add(loveseat);

              const loveseatBack = new THREE.BoxGeometry(6, 3, 1);
              const loveBack = new THREE.Mesh(loveseatBack, sofaMaterial);
              loveBack.position.set(groupX, 3, groupZ - 2.5);
              loveBack.castShadow = true;
              this.scene.add(loveBack);
            }

            // Coffee table for each grouping
            const tableWood = [0x654321, 0x8b6f47, 0x2f1b14][i % 3];
            const tableMaterial = new THREE.MeshStandardMaterial({
              color: tableWood,
              roughness: 0.4,
              metalness: 0.1,
            });

            const tableGeometry = new THREE.BoxGeometry(5, 0.8, 3);
            const coffeeTable = new THREE.Mesh(tableGeometry, tableMaterial);
            coffeeTable.position.set(groupX, 0.7, groupZ + 5);
            coffeeTable.castShadow = true;
            coffeeTable.receiveShadow = true;
            this.scene.add(coffeeTable);

            // End tables
            for (let j = 0; j < 2; j++) {
              const endTableGeometry = new THREE.BoxGeometry(2, 1.5, 2);
              const endTable = new THREE.Mesh(endTableGeometry, tableMaterial);
              endTable.position.set(groupX + (j === 0 ? -6 : 6), 0.95, groupZ);
              endTable.castShadow = true;
              endTable.receiveShadow = true;
              this.scene.add(endTable);

              // Table lamp
              const lampBase = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12);
              const lampMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.3,
                metalness: 0.7,
              });
              const lamp = new THREE.Mesh(lampBase, lampMaterial);
              lamp.position.set(groupX + (j === 0 ? -6 : 6), 2.6, groupZ);
              this.scene.add(lamp);

              const lampShade = new THREE.CylinderGeometry(0.8, 1, 1, 12);
              const shadeMaterial = new THREE.MeshStandardMaterial({
                color: 0xfff8dc,
                roughness: 0.8,
                metalness: 0,
              });
              const shade = new THREE.Mesh(lampShade, shadeMaterial);
              shade.position.set(groupX + (j === 0 ? -6 : 6), 3.3, groupZ);
              this.scene.add(shade);
            }
          }

          // Entertainment center displays
          const entertainmentMaterial = new THREE.MeshStandardMaterial({
            color: 0x2f1b14,
            roughness: 0.6,
            metalness: 0,
          });

          for (let i = 0; i < 4; i++) {
            const centerGeometry = new THREE.BoxGeometry(8, 8, 2.5);
            const entertainmentCenter = new THREE.Mesh(centerGeometry, entertainmentMaterial);
            entertainmentCenter.position.set(-65, 4, -40 + i * 12);
            entertainmentCenter.castShadow = true;
            entertainmentCenter.receiveShadow = true;
            this.scene.add(entertainmentCenter);

            // TV cavity
            const cavityGeometry = new THREE.BoxGeometry(5, 4, 1);
            const cavityMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.9,
              metalness: 0,
            });
            const cavity = new THREE.Mesh(cavityGeometry, cavityMaterial);
            cavity.position.set(-65, 5, -39 + i * 12);
            this.scene.add(cavity);

            // CRT TV
            const tvGeometry = new THREE.BoxGeometry(3.5, 2.8, 2.8);
            const tvMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.2,
              metalness: 0.8,
            });
            const tv = new THREE.Mesh(tvGeometry, tvMaterial);
            tv.position.set(-65, 5, -40 + i * 12);
            tv.castShadow = true;
            this.scene.add(tv);

            // VCR shelf
            const shelfGeometry = new THREE.BoxGeometry(7.5, 0.2, 2);
            const shelf = new THREE.Mesh(shelfGeometry, entertainmentMaterial);
            shelf.position.set(-65, 2.5, -40 + i * 12);
            this.scene.add(shelf);

            // VCR
            const vcrGeometry = new THREE.BoxGeometry(2.5, 0.6, 1.5);
            const vcrMaterial = new THREE.MeshStandardMaterial({
              color: 0x2a2a2a,
              roughness: 0.6,
              metalness: 0.4,
            });
            const vcr = new THREE.Mesh(vcrGeometry, vcrMaterial);
            vcr.position.set(-65, 3, -40 + i * 12);
            this.scene.add(vcr);
          }

          // Recliner section
          const reclinerMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a5d3a,
            roughness: 0.9,
            metalness: 0,
          });

          for (let i = 0; i < 6; i++) {
            const reclinerBase = new THREE.BoxGeometry(4, 2.5, 4.5);
            const recliner = new THREE.Mesh(reclinerBase, reclinerMaterial);
            recliner.position.set(-20 + (i % 3) * 6, 1.5, -45 + Math.floor(i / 3) * 8);
            recliner.castShadow = true;
            recliner.receiveShadow = true;
            this.scene.add(recliner);

            const reclinerBack = new THREE.BoxGeometry(4, 3.5, 1.5);
            const back = new THREE.Mesh(reclinerBack, reclinerMaterial);
            back.position.set(-20 + (i % 3) * 6, 3, -47.25 + Math.floor(i / 3) * 8);
            back.rotation.x = -0.2;
            back.castShadow = true;
            this.scene.add(back);

            // Footrest
            const footrestGeometry = new THREE.BoxGeometry(3.5, 1, 2);
            const footrest = new THREE.Mesh(footrestGeometry, reclinerMaterial);
            footrest.position.set(-20 + (i % 3) * 6, 0.8, -42 + Math.floor(i / 3) * 8);
            footrest.castShadow = true;
            this.scene.add(footrest);
          }
        }

        createBedroomDepartment() {
          // Expansive bedroom showroom
          
          // Department flooring
          const carpetGeometry = new THREE.PlaneGeometry(60, 50);
          const carpetMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7d6b,
            roughness: 0.9,
            metalness: 0,
          });
          const bedroomCarpet = new THREE.Mesh(carpetGeometry, carpetMaterial);
          bedroomCarpet.rotation.x = -Math.PI / 2;
          bedroomCarpet.position.set(35, 0.02, -25);
          bedroomCarpet.receiveShadow = true;
          this.scene.add(bedroomCarpet);

          // Multiple bedroom sets
          const bedStyles = ['sleigh', 'poster', 'platform', 'traditional', 'contemporary'];
          const woodColors = [0x5c3317, 0x8b6f47, 0x2f1b14, 0x654321, 0x4a3c28];

          for (let i = 0; i < 6; i++) {
            const setX = 15 + (i % 3) * 20;
            const setZ = -40 + Math.floor(i / 3) * 25;
            const woodColor = woodColors[i % woodColors.length];
            
            const bedMaterial = new THREE.MeshStandardMaterial({
              color: woodColor,
              roughness: 0.6,
              metalness: 0,
            });

            // Bed frame
            const bedFrameGeometry = new THREE.BoxGeometry(9, 1.5, 11);
            const bedFrame = new THREE.Mesh(bedFrameGeometry, bedMaterial);
            bedFrame.position.set(setX, 0.95, setZ);
            bedFrame.castShadow = true;
            bedFrame.receiveShadow = true;
            this.scene.add(bedFrame);

            // Headboard styles
            if (i % 3 === 0) {
              // Sleigh bed curved headboard
              const headboardGeometry = new THREE.BoxGeometry(9, 6, 2);
              const headboard = new THREE.Mesh(headboardGeometry, bedMaterial);
              headboard.position.set(setX, 4, setZ - 6.5);
              headboard.rotation.x = -0.1;
              headboard.castShadow = true;
              this.scene.add(headboard);

              // Footboard
              const footboardGeometry = new THREE.BoxGeometry(9, 3, 1.5);
              const footboard = new THREE.Mesh(footboardGeometry, bedMaterial);
              footboard.position.set(setX, 2, setZ + 6);
              footboard.rotation.x = 0.1;
              footboard.castShadow = true;
              this.scene.add(footboard);
            } else if (i % 3 === 1) {
              // Four-poster bed
              const postPositions = [
                [setX - 4, setZ - 5], [setX + 4, setZ - 5],
                [setX - 4, setZ + 5], [setX + 4, setZ + 5]
              ];
              
              postPositions.forEach(([x, z]) => {
                const postGeometry = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
                const post = new THREE.Mesh(postGeometry, bedMaterial);
                post.position.set(x, 4, z);
                post.castShadow = true;
                this.scene.add(post);
              });

              // Canopy frame
              const canopyGeometry = new THREE.BoxGeometry(9, 0.3, 11);
              const canopy = new THREE.Mesh(canopyGeometry, bedMaterial);
              canopy.position.set(setX, 8, setZ);
              canopy.castShadow = true;
              this.scene.add(canopy);
            } else {
              // Traditional headboard
              const headboardGeometry = new THREE.BoxGeometry(9, 5, 1);
              const headboard = new THREE.Mesh(headboardGeometry, bedMaterial);
              headboard.position.set(setX, 3.5, setZ - 6);
              headboard.castShadow = true;
              this.scene.add(headboard);
            }

            // Mattress and bedding
            const mattressGeometry = new THREE.BoxGeometry(8, 2.5, 10);
            const mattressMaterial = new THREE.MeshStandardMaterial({
              color: 0xf5f5dc,
              roughness: 0.9,
              metalness: 0,
            });
            const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
            mattress.position.set(setX, 3, setZ);
            mattress.castShadow = true;
            this.scene.add(mattress);

            // Comforter
            const comforterGeometry = new THREE.BoxGeometry(8.5, 0.5, 9);
            const comforterColors = [0x4169e1, 0x8b4513, 0x2f4f4f, 0x8b0000, 0x483d8b];
            const comforterMaterial = new THREE.MeshStandardMaterial({
              color: comforterColors[i % comforterColors.length],
              roughness: 0.8,
              metalness: 0,
            });
            const comforter = new THREE.Mesh(comforterGeometry, comforterMaterial);
            comforter.position.set(setX, 4.5, setZ + 0.5);
            comforter.castShadow = true;
            this.scene.add(comforter);

            // Pillows
            const pillowGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.5);
            for (let j = 0; j < 2; j++) {
              const pillow = new THREE.Mesh(pillowGeometry, mattressMaterial);
              pillow.position.set(setX - 2 + j * 4, 5, setZ - 4);
              pillow.rotation.z = j === 0 ? 0.1 : -0.1;
              this.scene.add(pillow);
            }

            // Matching dresser
            const dresserGeometry = new THREE.BoxGeometry(6, 4, 2.5);
            const dresser = new THREE.Mesh(dresserGeometry, bedMaterial);
            dresser.position.set(setX + 10, 2, setZ);
            dresser.castShadow = true;
            dresser.receiveShadow = true;
            this.scene.add(dresser);

            // Drawer handles
            const handleMaterial = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.5,
              metalness: 0.9,
            });

            for (let row = 0; row < 4; row++) {
              for (let col = 0; col < 2; col++) {
                const handleGeometry = new THREE.BoxGeometry(0.8, 0.15, 0.15);
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.set(
                  setX + 8.5 + col * 3,
                  0.5 + row * 1,
                  setZ + 1.3
                );
                this.scene.add(handle);
              }
            }

            // Mirror above dresser
            const mirrorFrame = new THREE.BoxGeometry(5, 3, 0.2);
            const mirrorFrameMaterial = new THREE.MeshStandardMaterial({
              color: woodColor,
              roughness: 0.6,
              metalness: 0,
            });
            const frame = new THREE.Mesh(mirrorFrame, mirrorFrameMaterial);
            frame.position.set(setX + 10, 6, setZ - 2);
            frame.castShadow = true;
            this.scene.add(frame);

            const mirrorGlass = new THREE.BoxGeometry(4.5, 2.5, 0.05);
            const mirrorMaterial = new THREE.MeshStandardMaterial({
              color: 0x88ccff,
              roughness: 0.1,
              metalness: 0.9,
            });
            const mirror = new THREE.Mesh(mirrorGlass, mirrorMaterial);
            mirror.position.set(setX + 10, 6, setZ - 1.85);
            this.scene.add(mirror);

            // Nightstands
            for (let j = 0; j < 2; j++) {
              const nightstandGeometry = new THREE.BoxGeometry(2.5, 2, 2.5);
              const nightstand = new THREE.Mesh(nightstandGeometry, bedMaterial);
              nightstand.position.set(setX + (j === 0 ? -6 : 6), 1.2, setZ - 4);
              nightstand.castShadow = true;
              nightstand.receiveShadow = true;
              this.scene.add(nightstand);

              // Drawer handles
              const nsHandleGeometry = new THREE.BoxGeometry(1, 0.15, 0.15);
              const nsHandle1 = new THREE.Mesh(nsHandleGeometry, handleMaterial);
              nsHandle1.position.set(setX + (j === 0 ? -6 : 6), 1.6, setZ - 2.65);
              this.scene.add(nsHandle1);

              const nsHandle2 = new THREE.Mesh(nsHandleGeometry, handleMaterial);
              nsHandle2.position.set(setX + (j === 0 ? -6 : 6), 0.8, setZ - 2.65);
              this.scene.add(nsHandle2);

              // Table lamp
              const lampBase = new THREE.CylinderGeometry(0.3, 0.3, 0.3, 12);
              const lampBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.3,
                metalness: 0.7,
              });
              const lamp = new THREE.Mesh(lampBase, lampBaseMaterial);
              lamp.position.set(setX + (j === 0 ? -6 : 6), 2.35, setZ - 4);
              this.scene.add(lamp);

              const lampPole = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
              const pole = new THREE.Mesh(lampPole, lampBaseMaterial);
              pole.position.set(setX + (j === 0 ? -6 : 6), 2.85, setZ - 4);
              this.scene.add(pole);

              const lampShade = new THREE.CylinderGeometry(0.6, 0.8, 0.8, 12);
              const shadeMaterial = new THREE.MeshStandardMaterial({
                color: 0xfff8dc,
                roughness: 0.8,
                metalness: 0,
              });
              const shade = new THREE.Mesh(lampShade, shadeMaterial);
              shade.position.set(setX + (j === 0 ? -6 : 6), 3.4, setZ - 4);
              this.scene.add(shade);
            }
          }

          // Armoire display area
          const armoireMaterial = new THREE.MeshStandardMaterial({
            color: 0x5c3317,
            roughness: 0.6,
            metalness: 0,
          });

          for (let i = 0; i < 3; i++) {
            const armoireGeometry = new THREE.BoxGeometry(8, 10, 3);
            const armoire = new THREE.Mesh(armoireGeometry, armoireMaterial);
            armoire.position.set(55, 5, -35 + i * 15);
            armoire.castShadow = true;
            armoire.receiveShadow = true;
            this.scene.add(armoire);

            // Doors
            const doorGeometry = new THREE.BoxGeometry(3.8, 8, 0.2);
            const leftDoor = new THREE.Mesh(doorGeometry, armoireMaterial);
            leftDoor.position.set(53, 5, -33.4 + i * 15);
            this.scene.add(leftDoor);

            const rightDoor = new THREE.Mesh(doorGeometry, armoireMaterial);
            rightDoor.position.set(57, 5, -33.4 + i * 15);
            this.scene.add(rightDoor);

            // Door handles
            const handleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const armoireHandleMaterial = new THREE.MeshStandardMaterial({
              color: 0xffd700,
              roughness: 0.3,
              metalness: 0.8,
            });
            const handle1 = new THREE.Mesh(handleGeometry, armoireHandleMaterial);
            handle1.position.set(54.5, 5, -33.3 + i * 15);
            handle1.rotation.z = Math.PI / 2;
            this.scene.add(handle1);

            const handle2 = new THREE.Mesh(handleGeometry, armoireHandleMaterial);
            handle2.position.set(55.5, 5, -33.3 + i * 15);
            handle2.rotation.z = Math.PI / 2;
            this.scene.add(handle2);
          }
        }

        createElectronicsDepartment() {
          // 90s electronics paradise
          
          // Black and chrome department styling
          const floorGeometry = new THREE.PlaneGeometry(40, 30);
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.3,
            metalness: 0.7,
          });
          const electronicsFloor = new THREE.Mesh(floorGeometry, floorMaterial);
          electronicsFloor.rotation.x = -Math.PI / 2;
          electronicsFloor.position.set(0, 0.03, -45);
          electronicsFloor.receiveShadow = true;
          this.scene.add(electronicsFloor);

          // TV wall display
          const tvWallGeometry = new THREE.BoxGeometry(35, 10, 2);
          const tvWallMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8,
            metalness: 0.2,
          });
          const tvWall = new THREE.Mesh(tvWallGeometry, tvWallMaterial);
          tvWall.position.set(0, 5, -58);
          tvWall.castShadow = true;
          tvWall.receiveShadow = true;
          this.scene.add(tvWall);

          // Multiple CRT TVs on display
          const tvSizes = [
            { w: 2, h: 1.8, d: 1.8, screen: 1.5 }, // 13"
            { w: 2.5, h: 2.2, d: 2.2, screen: 2 },  // 19"
            { w: 3.5, h: 3, d: 3, screen: 2.8 },    // 27"
            { w: 4.5, h: 3.8, d: 3.8, screen: 3.5 }, // 32"
          ];

          for (let i = 0; i < 12; i++) {
            const size = tvSizes[i % tvSizes.length];
            const tvGeometry = new THREE.BoxGeometry(size.w, size.h, size.d);
            const tvMaterial = new THREE.MeshStandardMaterial({
              color: i % 3 === 0 ? 0x1a1a1a : i % 3 === 1 ? 0x2d2d2d : 0x0f0f0f,
              roughness: 0.3,
              metalness: 0.7,
            });
            const tv = new THREE.Mesh(tvGeometry, tvMaterial);
            tv.position.set(
              -15 + (i % 6) * 6,
              2 + Math.floor(i / 6) * 4,
              -56.5
            );
            tv.castShadow = true;
            this.scene.add(tv);

            // TV screen
            const screenGeometry = new THREE.BoxGeometry(size.screen, size.screen * 0.75, 0.1);
            const screenMaterial = new THREE.MeshStandardMaterial({
              color: 0x001100,
              roughness: 0.1,
              metalness: 0.9,
              emissive: 0x003300,
              emissiveIntensity: 0.05,
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(
              -15 + (i % 6) * 6,
              2 + Math.floor(i / 6) * 4,
              -55.5
            );
            this.scene.add(screen);

            // Brand badge
            const badgeGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.05);
            const badgeMaterial = new THREE.MeshStandardMaterial({
              color: 0xc0c0c0,
              roughness: 0.3,
              metalness: 0.8,
            });
            const badge = new THREE.Mesh(badgeGeometry, badgeMaterial);
            badge.position.set(
              -15 + (i % 6) * 6,
              1.5 + Math.floor(i / 6) * 4,
              -55.4
            );
            this.scene.add(badge);
          }

          // Stereo systems display
          const stereoRackGeometry = new THREE.BoxGeometry(30, 8, 3);
          const stereoRackMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.7,
            metalness: 0.3,
          });
          const stereoRack = new THREE.Mesh(stereoRackGeometry, stereoRackMaterial);
          stereoRack.position.set(-18, 4, -45);
          stereoRack.castShadow = true;
          stereoRack.receiveShadow = true;
          this.scene.add(stereoRack);

          // Individual stereo components
          const componentTypes = ['receiver', 'cd_player', 'tape_deck', 'equalizer'];
          
          for (let i = 0; i < 8; i++) {
            const shelfY = 1 + Math.floor(i / 4) * 4;
            const shelfX = -28 + (i % 4) * 7;
            
            // Main unit
            const unitGeometry = new THREE.BoxGeometry(5, 1.5, 2);
            const unitMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.4,
              metalness: 0.6,
            });
            const unit = new THREE.Mesh(unitGeometry, unitMaterial);
            unit.position.set(shelfX, shelfY, -45);
            unit.castShadow = true;
            this.scene.add(unit);

            // Display panel
            const displayGeometry = new THREE.BoxGeometry(3, 0.6, 0.1);
            const displayMaterial = new THREE.MeshStandardMaterial({
              color: 0x00ff00,
              roughness: 0.2,
              metalness: 0.1,
              emissive: 0x00ff00,
              emissiveIntensity: 0.2,
            });
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.set(shelfX, shelfY + 0.3, -43.9);
            this.scene.add(display);

            // Knobs and buttons
            for (let j = 0; j < 5; j++) {
              const knobGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 12);
              const knobMaterial = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                roughness: 0.4,
                metalness: 0.8,
              });
              const knob = new THREE.Mesh(knobGeometry, knobMaterial);
              knob.position.set(shelfX - 2 + j * 1, shelfY - 0.3, -43.9);
              knob.rotation.x = Math.PI / 2;
              this.scene.add(knob);
            }

            // Speakers
            const speakerGeometry = new THREE.BoxGeometry(2, 3.5, 2);
            const speakerMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.8,
              metalness: 0.2,
            });
            
            const leftSpeaker = new THREE.Mesh(speakerGeometry, speakerMaterial);
            leftSpeaker.position.set(shelfX - 4, shelfY + 0.5, -45);
            leftSpeaker.castShadow = true;
            this.scene.add(leftSpeaker);

            const rightSpeaker = new THREE.Mesh(speakerGeometry, speakerMaterial);
            rightSpeaker.position.set(shelfX + 4, shelfY + 0.5, -45);
            rightSpeaker.castShadow = true;
            this.scene.add(rightSpeaker);

            // Woofers
            const wooferGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 16);
            const wooferMaterial = new THREE.MeshStandardMaterial({
              color: 0x2a2a2a,
              roughness: 0.9,
              metalness: 0.1,
            });
            
            const leftWoofer = new THREE.Mesh(wooferGeometry, wooferMaterial);
            leftWoofer.position.set(shelfX - 4, shelfY, -43.9);
            leftWoofer.rotation.x = Math.PI / 2;
            this.scene.add(leftWoofer);

            const rightWoofer = new THREE.Mesh(wooferGeometry, wooferMaterial);
            rightWoofer.position.set(shelfX + 4, shelfY, -43.9);
            rightWoofer.rotation.x = Math.PI / 2;
            this.scene.add(rightWoofer);
          }

          // Camcorder display
          const camcorderStand = new THREE.BoxGeometry(15, 1, 8);
          const standMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.7,
            metalness: 0.3,
          });
          const camStand = new THREE.Mesh(camcorderStand, standMaterial);
          camStand.position.set(15, 0.5, -45);
          camStand.castShadow = true;
          camStand.receiveShadow = true;
          this.scene.add(camStand);

          // Camcorders on display
          for (let i = 0; i < 4; i++) {
            const camBodyGeometry = new THREE.BoxGeometry(3, 1.5, 1);
            const camMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.4,
              metalness: 0.6,
            });
            const camBody = new THREE.Mesh(camBodyGeometry, camMaterial);
            camBody.position.set(10 + i * 3, 1.5, -45);
            camBody.castShadow = true;
            this.scene.add(camBody);

            // Lens
            const lensGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 12);
            const lensMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.2,
              metalness: 0.8,
            });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.position.set(11.5 + i * 3, 1.5, -45);
            lens.rotation.z = Math.PI / 2;
            this.scene.add(lens);

            // Viewfinder
            const viewfinderGeometry = new THREE.BoxGeometry(0.5, 0.5, 1.5);
            const viewfinder = new THREE.Mesh(viewfinderGeometry, camMaterial);
            viewfinder.position.set(8.8 + i * 3, 1.8, -45);
            this.scene.add(viewfinder);
          }

          // Boombox display table
          const boomboxTableGeometry = new THREE.BoxGeometry(10, 1, 6);
          const boomboxTable = new THREE.Mesh(boomboxTableGeometry, standMaterial);
          boomboxTable.position.set(0, 0.5, -35);
          boomboxTable.castShadow = true;
          boomboxTable.receiveShadow = true;
          this.scene.add(boomboxTable);

          // Boomboxes
          for (let i = 0; i < 3; i++) {
            const boomboxGeometry = new THREE.BoxGeometry(4, 2, 1);
            const boomboxMaterial = new THREE.MeshStandardMaterial({
              color: i === 0 ? 0xc0c0c0 : i === 1 ? 0x1a1a1a : 0xff0000,
              roughness: 0.4,
              metalness: 0.6,
            });
            const boombox = new THREE.Mesh(boomboxGeometry, boomboxMaterial);
            boombox.position.set(-3 + i * 3, 2, -35);
            boombox.castShadow = true;
            this.scene.add(boombox);

            // Speakers
            const speakerGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 12);
            const leftBoomSpeaker = new THREE.Mesh(speakerGeometry, wooferMaterial);
            leftBoomSpeaker.position.set(-4 + i * 3, 2, -34.4);
            leftBoomSpeaker.rotation.x = Math.PI / 2;
            this.scene.add(leftBoomSpeaker);

            const rightBoomSpeaker = new THREE.Mesh(speakerGeometry, wooferMaterial);
            rightBoomSpeaker.position.set(-2 + i * 3, 2, -34.4);
            rightBoomSpeaker.rotation.x = Math.PI / 2;
            this.scene.add(rightBoomSpeaker);

            // Cassette deck
            const cassetteGeometry = new THREE.BoxGeometry(1, 0.5, 0.1);
            const cassetteMaterial = new THREE.MeshStandardMaterial({
              color: 0x444444,
              roughness: 0.6,
              metalness: 0.4,
            });
            const cassetteDeck = new THREE.Mesh(cassetteGeometry, cassetteMaterial);
            cassetteDeck.position.set(-3 + i * 3, 2.5, -34.4);
            this.scene.add(cassetteDeck);

            // Handle
            const handleGeometry = new THREE.BoxGeometry(3, 0.2, 0.2);
            const handle = new THREE.Mesh(handleGeometry, boomboxMaterial);
            handle.position.set(-3 + i * 3, 3.2, -35);
            this.scene.add(handle);
          }
        }

        createAppliancesDepartment() {
          // Major appliances section
          
          // White tile flooring
          const tileGeometry = new THREE.PlaneGeometry(40, 40);
          const tileMaterial = new THREE.MeshStandardMaterial({
            color: 0xf5f5f5,
            roughness: 0.3,
            metalness: 0.1,
          });
          const applianceFloor = new THREE.Mesh(tileGeometry, tileMaterial);
          applianceFloor.rotation.x = -Math.PI / 2;
          applianceFloor.position.set(-70, 0.02, 0);
          applianceFloor.receiveShadow = true;
          this.scene.add(applianceFloor);

          // Refrigerator lineup
          const fridgeColors = [0xffffff, 0xf5f5dc, 0x1a1a1a, 0xc0c0c0];
          
          for (let i = 0; i < 8; i++) {
            const fridgeGeometry = new THREE.BoxGeometry(3.5, 7, 3);
            const fridgeMaterial = new THREE.MeshStandardMaterial({
              color: fridgeColors[i % fridgeColors.length],
              roughness: 0.3,
              metalness: 0.8,
            });
            const fridge = new THREE.Mesh(fridgeGeometry, fridgeMaterial);
            fridge.position.set(-85, 3.5, -15 + i * 4);
            fridge.castShadow = true;
            fridge.receiveShadow = true;
            this.scene.add(fridge);

            // Door split
            const doorLineGeometry = new THREE.BoxGeometry(3.4, 0.05, 0.05);
            const doorLineMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.5,
              metalness: 0.5,
            });
            const doorLine = new THREE.Mesh(doorLineGeometry, doorLineMaterial);
            doorLine.position.set(-85, 5, -13.45 + i * 4);
            this.scene.add(doorLine);

            // Handles
            const handleGeometry = new THREE.BoxGeometry(0.2, 2.5, 0.2);
            const handleMaterial = new THREE.MeshStandardMaterial({
              color: i % 4 === 2 ? 0xc0c0c0 : 0x666666,
              roughness: 0.4,
              metalness: 0.9,
            });
            const topHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            topHandle.position.set(-83.2, 6, -15 + i * 4);
            this.scene.add(topHandle);

            const bottomHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            bottomHandle.position.set(-83.2, 2.5, -15 + i * 4);
            this.scene.add(bottomHandle);

            // Water/ice dispenser on some models
            if (i % 3 === 0) {
              const dispenserGeometry = new THREE.BoxGeometry(1, 1.5, 0.2);
              const dispenserMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.6,
                metalness: 0.4,
              });
              const dispenser = new THREE.Mesh(dispenserGeometry, dispenserMaterial);
              dispenser.position.set(-85, 5.5, -13.35 + i * 4);
              this.scene.add(dispenser);
            }
          }

          // Stove/range display
          const stoveColors = [0xffffff, 0x1a1a1a, 0xf5f5dc, 0xc0c0c0];
          
          for (let i = 0; i < 6; i++) {
            const stoveGeometry = new THREE.BoxGeometry(3, 3.5, 3);
            const stoveMaterial = new THREE.MeshStandardMaterial({
              color: stoveColors[i % stoveColors.length],
              roughness: 0.4,
              metalness: 0.7,
            });
            const stove = new THREE.Mesh(stoveGeometry, stoveMaterial);
            stove.position.set(-75, 1.75, -10 + i * 4);
            stove.castShadow = true;
            stove.receiveShadow = true;
            this.scene.add(stove);

            // Cooktop
            const cooktopGeometry = new THREE.BoxGeometry(2.8, 0.1, 2.5);
            const cooktopMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.2,
              metalness: 0.8,
            });
            const cooktop = new THREE.Mesh(cooktopGeometry, cooktopMaterial);
            cooktop.position.set(-75, 3.55, -10 + i * 4);
            this.scene.add(cooktop);

            // Burners
            const burnerPositions = [
              [-0.7, -0.6], [0.7, -0.6], [-0.7, 0.6], [0.7, 0.6]
            ];
            
            burnerPositions.forEach(([x, z]) => {
              const burnerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
              const burnerMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2,
              });
              const burner = new THREE.Mesh(burnerGeometry, burnerMaterial);
              burner.position.set(-75 + x, 3.6, -10 + i * 4 + z);
              this.scene.add(burner);
            });

            // Control panel
            const panelGeometry = new THREE.BoxGeometry(2.8, 0.5, 0.2);
            const panelMaterial = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.7,
              metalness: 0.3,
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(-75, 3.2, -8.35 + i * 4);
            this.scene.add(panel);

            // Oven door
            const doorGeometry = new THREE.BoxGeometry(2.5, 2, 0.2);
            const ovenDoor = new THREE.Mesh(doorGeometry, stoveMaterial);
            ovenDoor.position.set(-75, 1.5, -8.35 + i * 4);
            this.scene.add(ovenDoor);

            // Oven window
            const windowGeometry = new THREE.BoxGeometry(2, 1, 0.05);
            const windowMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              transparent: true,
              opacity: 0.7,
              roughness: 0.1,
              metalness: 0.9,
            });
            const ovenWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            ovenWindow.position.set(-75, 1.5, -8.27 + i * 4);
            this.scene.add(ovenWindow);

            // Oven handle
            const ovenHandleGeometry = new THREE.BoxGeometry(2, 0.2, 0.3);
            const ovenHandle = new THREE.Mesh(ovenHandleGeometry, handleMaterial);
            ovenHandle.position.set(-75, 2.6, -8.15 + i * 4);
            this.scene.add(ovenHandle);
          }

          // Dishwasher display
          for (let i = 0; i < 5; i++) {
            const dishwasherGeometry = new THREE.BoxGeometry(2.5, 3, 2.5);
            const dishwasherMaterial = new THREE.MeshStandardMaterial({
              color: i % 2 === 0 ? 0xffffff : 0x1a1a1a,
              roughness: 0.4,
              metalness: 0.7,
            });
            const dishwasher = new THREE.Mesh(dishwasherGeometry, dishwasherMaterial);
            dishwasher.position.set(-65, 1.5, -8 + i * 4);
            dishwasher.castShadow = true;
            dishwasher.receiveShadow = true;
            this.scene.add(dishwasher);

            // Control panel
            const dwPanelGeometry = new THREE.BoxGeometry(2.3, 0.4, 0.1);
            const dwPanel = new THREE.Mesh(dwPanelGeometry, panelMaterial);
            dwPanel.position.set(-65, 2.8, -6.7 + i * 4);
            this.scene.add(dwPanel);

            // Handle
            const dwHandleGeometry = new THREE.BoxGeometry(1.5, 0.15, 0.2);
            const dwHandle = new THREE.Mesh(dwHandleGeometry, handleMaterial);
            dwHandle.position.set(-65, 2.3, -6.6 + i * 4);
            this.scene.add(dwHandle);
          }

          // Washer and dryer section
          const laundryPlatform = new THREE.BoxGeometry(25, 0.5, 15);
          const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.7,
            metalness: 0.1,
            roughness: 0.7,
            metalness: 0.2,
          });
          const laundryPlat = new THREE.Mesh(laundryPlatform, platformMaterial);
          laundryPlat.position.set(-70, 0.25, 15);
          laundryPlat.receiveShadow = true;
          this.scene.add(laundryPlat);

          // Washers and dryers
          for (let i = 0; i < 8; i++) {
            const isWasher = i % 2 === 0;
            const machineGeometry = new THREE.BoxGeometry(3, 3.5, 3);
            const machineMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.4,
              metalness: 0.6,
            });
            const machine = new THREE.Mesh(machineGeometry, machineMaterial);
            machine.position.set(-78 + (i % 4) * 4, 2, 10 + Math.floor(i / 4) * 5);
            machine.castShadow = true;
            machine.receiveShadow = true;
            this.scene.add(machine);

            // Control panel
            const controlPanelGeometry = new THREE.BoxGeometry(2.8, 0.6, 0.1);
            const controlPanel = new THREE.Mesh(controlPanelGeometry, panelMaterial);
            controlPanel.position.set(-78 + (i % 4) * 4, 3.5, 11.55 + Math.floor(i / 4) * 5);
            this.scene.add(controlPanel);

            // Dial
            const dialGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const dialMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.5,
              metalness: 0.7,
            });
            const dial = new THREE.Mesh(dialGeometry, dialMaterial);
            dial.position.set(-78 + (i % 4) * 4, 3.5, 11.6 + Math.floor(i / 4) * 5);
            dial.rotation.x = Math.PI / 2;
            this.scene.add(dial);

            // Door
            const doorGeometry = new THREE.CylinderGeometry(1, 1, 0.1, 32);
            const doorMaterial = new THREE.MeshStandardMaterial({
              color: 0xf0f0f0,
              roughness: 0.3,
              metalness: 0.7,
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(-78 + (i % 4) * 4, 2, 11.5 + Math.floor(i / 4) * 5);
            door.rotation.x = Math.PI / 2;
            this.scene.add(door);

            // Window
            const windowGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.05, 32);
            const windowMaterial = new THREE.MeshStandardMaterial({
              color: 0x333333,
              transparent: true,
              opacity: 0.5,
              roughness: 0.1,
              metalness: 0.9,
            });
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(-78 + (i % 4) * 4, 2, 11.53 + Math.floor(i / 4) * 5);
            window.rotation.x = Math.PI / 2;
            this.scene.add(window);
          }

          // Microwave display shelf
          const microwaveShelf = new THREE.BoxGeometry(20, 1, 10);
          const shelfMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6f47,
            roughness: 0.7,
            metalness: 0.1,
          });
          const mwShelf = new THREE.Mesh(microwaveShelf, shelfMaterial);
          mwShelf.position.set(-55, 3, 0);
          mwShelf.castShadow = true;
          mwShelf.receiveShadow = true;
          this.scene.add(mwShelf);

          // Microwaves
          for (let i = 0; i < 6; i++) {
            const microwaveGeometry = new THREE.BoxGeometry(2, 1.5, 2);
            const microwaveMaterial = new THREE.MeshStandardMaterial({
              color: i % 3 === 0 ? 0xffffff : i % 3 === 1 ? 0x1a1a1a : 0xc0c0c0,
              roughness: 0.4,
              metalness: 0.6,
            });
            const microwave = new THREE.Mesh(microwaveGeometry, microwaveMaterial);
            microwave.position.set(-60 + (i % 3) * 5, 4, -3 + Math.floor(i / 3) * 4);
            microwave.castShadow = true;
            this.scene.add(microwave);

            // Door
            const mwDoorGeometry = new THREE.BoxGeometry(1.5, 1.2, 0.1);
            const mwDoor = new THREE.Mesh(mwDoorGeometry, microwaveMaterial);
            mwDoor.position.set(-60.3 + (i % 3) * 5, 4, -2 + Math.floor(i / 3) * 4);
            this.scene.add(mwDoor);

            // Window
            const mwWindowGeometry = new THREE.BoxGeometry(1.2, 0.9, 0.05);
            const mwWindow = new THREE.Mesh(mwWindowGeometry, windowMaterial);
            mwWindow.position.set(-60.3 + (i % 3) * 5, 4, -1.92 + Math.floor(i / 3) * 4);
            this.scene.add(mwWindow);

            // Control panel
            const mwPanelGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.1);
            const mwPanel = new THREE.Mesh(mwPanelGeometry, panelMaterial);
            mwPanel.position.set(-59 + (i % 3) * 5, 4, -2 + Math.floor(i / 3) * 4);
            this.scene.add(mwPanel);
          }
        }

        createOfficeDepartment() {
          // Professional office furniture section
          
          // Blue commercial carpet
          const carpetGeometry = new THREE.PlaneGeometry(40, 35);
          const carpetMaterial = new THREE.MeshStandardMaterial({
            color: 0x1e3a5f,
            roughness: 0.9,
            metalness: 0,
          });
          const officeCarpet = new THREE.Mesh(carpetGeometry, carpetMaterial);
          officeCarpet.rotation.x = -Math.PI / 2;
          officeCarpet.position.set(70, 0.02, 25);
          officeCarpet.receiveShadow = true;
          this.scene.add(officeCarpet);

          // Executive desk displays
          const deskWoods = [0x654321, 0x8b4513, 0x2f1b14, 0x1a1a1a];
          
          for (let i = 0; i < 6; i++) {
            const deskX = 55 + (i % 2) * 20;
            const deskZ = 10 + Math.floor(i / 2) * 12;
            
            const deskMaterial = new THREE.MeshStandardMaterial({
              color: deskWoods[i % deskWoods.length],
              roughness: 0.4,
              metalness: 0.1,
            });

            // L-shaped executive desk
            const mainDeskGeometry = new THREE.BoxGeometry(8, 0.3, 4);
            const mainDesk = new THREE.Mesh(mainDeskGeometry, deskMaterial);
            mainDesk.position.set(deskX, 2.5, deskZ);
            mainDesk.castShadow = true;
            mainDesk.receiveShadow = true;
            this.scene.add(mainDesk);

            const sideDeskGeometry = new THREE.BoxGeometry(4, 0.3, 6);
            const sideDesk = new THREE.Mesh(sideDeskGeometry, deskMaterial);
            sideDesk.position.set(deskX + 6, 2.5, deskZ + 5);
            sideDesk.castShadow = true;
            sideDesk.receiveShadow = true;
            this.scene.add(sideDesk);

            // Desk pedestals
            const pedestalGeometry = new THREE.BoxGeometry(2, 2.3, 3.5);
            const leftPedestal = new THREE.Mesh(pedestalGeometry, deskMaterial);
            leftPedestal.position.set(deskX - 3, 1.15, deskZ);
            leftPedestal.castShadow = true;
            this.scene.add(leftPedestal);

            const rightPedestal = new THREE.Mesh(pedestalGeometry, deskMaterial);
            rightPedestal.position.set(deskX + 3, 1.15, deskZ);
            rightPedestal.castShadow = true;
            this.scene.add(rightPedestal);

            // Drawer handles
            const handleMaterial = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.4,
              metalness: 0.9,
            });

            for (let j = 0; j < 3; j++) {
              const handleGeometry = new THREE.BoxGeometry(1, 0.1, 0.1);
              const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
              leftHandle.position.set(deskX - 3, 0.5 + j * 0.7, deskZ + 1.8);
              this.scene.add(leftHandle);

              const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
              rightHandle.position.set(deskX + 3, 0.5 + j * 0.7, deskZ + 1.8);
              this.scene.add(rightHandle);
            }

            // Computer monitor (CRT)
            const monitorBase = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 12);
            const monitorBaseMaterial = new THREE.MeshStandardMaterial({
              color: 0xf5f5dc,
              roughness: 0.7,
              metalness: 0.2,
            });
            const base = new THREE.Mesh(monitorBase, monitorBaseMaterial);
            base.position.set(deskX, 2.7, deskZ);
            this.scene.add(base);

            const monitorGeometry = new THREE.BoxGeometry(2, 1.8, 1.8);
            const monitor = new THREE.Mesh(monitorGeometry, monitorBaseMaterial);
            monitor.position.set(deskX, 3.7, deskZ);
            monitor.castShadow = true;
            this.scene.add(monitor);

            const screenGeometry = new THREE.BoxGeometry(1.6, 1.4, 0.1);
            const screenMaterial = new THREE.MeshStandardMaterial({
              color: 0x001100,
              roughness: 0.1,
              metalness: 0.9,
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(deskX, 3.7, deskZ + 0.85);
            this.scene.add(screen);

            // Keyboard
            const keyboardGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
            const keyboard = new THREE.Mesh(keyboardGeometry, monitorBaseMaterial);
            keyboard.position.set(deskX, 2.65, deskZ + 1.5);
            this.scene.add(keyboard);

            // Mouse
            const mouseGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.5);
            const mouse = new THREE.Mesh(mouseGeometry, monitorBaseMaterial);
            mouse.position.set(deskX + 1.5, 2.65, deskZ + 1.5);
            this.scene.add(mouse);

            // Desk lamp
            const lampBaseGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 12);
            const lampMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.4,
              metalness: 0.7,
            });
            const lampBase = new THREE.Mesh(lampBaseGeometry, lampMaterial);
            lampBase.position.set(deskX - 2.5, 2.7, deskZ - 1);
            this.scene.add(lampBase);

            const lampArmGeometry = new THREE.BoxGeometry(0.1, 2, 0.1);
            const lampArm = new THREE.Mesh(lampArmGeometry, lampMaterial);
            lampArm.position.set(deskX - 2.5, 3.7, deskZ - 1);
            lampArm.rotation.z = -0.3;
            this.scene.add(lampArm);

            const lampShadeGeometry = new THREE.CylinderGeometry(0.3, 0.6, 0.5, 12);
            const lampShade = new THREE.Mesh(lampShadeGeometry, lampMaterial);
            lampShade.position.set(deskX - 3, 4.5, deskZ - 1);
            lampShade.rotation.z = -0.5;
            this.scene.add(lampShade);
          }

          // Office chair showroom
          const chairTypes = ['executive', 'task', 'ergonomic', 'conference'];
          const chairColors = [0x1a1a1a, 0x8b4513, 0x2f4f4f, 0x4169e1];

          for (let i = 0; i < 12; i++) {
            const chairX = 50 + (i % 4) * 5;
            const chairZ = 35 + Math.floor(i / 4) * 5;
            
            const chairMaterial = new THREE.MeshStandardMaterial({
              color: chairColors[i % chairColors.length],
              roughness: i % 2 === 0 ? 0.3 : 0.8,
              metalness: i % 2 === 0 ? 0.1 : 0,
            });

            // Seat
            const seatGeometry = new THREE.BoxGeometry(2, 0.3, 2);
            const seat = new THREE.Mesh(seatGeometry, chairMaterial);
            seat.position.set(chairX, 2, chairZ);
            seat.castShadow = true;
            seat.receiveShadow = true;
            this.scene.add(seat);

            // Backrest
            const backGeometry = new THREE.BoxGeometry(2, 2.5, 0.3);
            const backrest = new THREE.Mesh(backGeometry, chairMaterial);
            backrest.position.set(chairX, 3.25, chairZ - 0.85);
            backrest.rotation.x = -0.1;
            backrest.castShadow = true;
            this.scene.add(backrest);

            // Armrests
            if (i % 3 !== 2) {
              const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 2);
              const leftArm = new THREE.Mesh(armGeometry, chairMaterial);
              leftArm.position.set(chairX - 1, 2.4, chairZ);
              leftArm.castShadow = true;
              this.scene.add(leftArm);

              const rightArm = new THREE.Mesh(armGeometry, chairMaterial);
              rightArm.position.set(chairX + 1, 2.4, chairZ);
              rightArm.castShadow = true;
              this.scene.add(rightArm);
            }

            // Chair base
            const baseMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.3,
              metalness: 0.8,
            });

            const centerPost = new THREE.CylinderGeometry(0.15, 0.15, 1.8, 8);
            const post = new THREE.Mesh(centerPost, baseMaterial);
            post.position.set(chairX, 1, chairZ);
            post.castShadow = true;
            this.scene.add(post);

            // Five-star base
            for (let j = 0; j < 5; j++) {
              const angle = (j / 5) * Math.PI * 2;
              const legGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.2);
              const leg = new THREE.Mesh(legGeometry, baseMaterial);
              leg.position.set(
                chairX + Math.cos(angle) * 0.7,
                0.1,
                chairZ + Math.sin(angle) * 0.7
              );
              leg.rotation.y = angle;
              this.scene.add(leg);

              // Caster wheel
              const wheelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 8);
              const wheel = new THREE.Mesh(wheelGeometry, baseMaterial);
              wheel.position.set(
                chairX + Math.cos(angle) * 1.2,
                0.15,
                chairZ + Math.sin(angle) * 1.2
              );
              wheel.rotation.z = Math.PI / 2;
              this.scene.add(wheel);
            }
          }

          // File cabinet display
          const cabinetColors = [0x404040, 0xf5f5dc, 0x1a1a1a, 0x8b6f47];

          for (let i = 0; i < 8; i++) {
            const cabinetMaterial = new THREE.MeshStandardMaterial({
              color: cabinetColors[i % cabinetColors.length],
              roughness: 0.7,
              metalness: 0.5,
            });

            const cabinetGeometry = new THREE.BoxGeometry(2, 4, 3);
            const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
            cabinet.position.set(80 + (i % 4) * 3, 2, 10 + Math.floor(i / 4) * 5);
            cabinet.castShadow = true;
            cabinet.receiveShadow = true;
            this.scene.add(cabinet);

            // Drawer fronts
            for (let j = 0; j < 4; j++) {
              const drawerFrontGeometry = new THREE.BoxGeometry(1.8, 0.9, 0.1);
              const drawerFront = new THREE.Mesh(drawerFrontGeometry, cabinetMaterial);
              drawerFront.position.set(
                80 + (i % 4) * 3,
                0.5 + j * 1,
                11.55 + Math.floor(i / 4) * 5
              );
              this.scene.add(drawerFront);

              // Handle
              const handleGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.1);
              const handle = new THREE.Mesh(handleGeometry, handleMaterial);
              handle.position.set(
                80 + (i % 4) * 3,
                0.5 + j * 1,
                11.65 + Math.floor(i / 4) * 5
              );
              this.scene.add(handle);

              // Label holder
              const labelGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.05);
              const labelMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.8,
                metalness: 0,
              });
              const label = new THREE.Mesh(labelGeometry, labelMaterial);
              label.position.set(
                80 + (i % 4) * 3,
                0.5 + j * 1,
                11.6 + Math.floor(i / 4) * 5
              );
              this.scene.add(label);
            }
          }

          // Conference table display
          const conferenceTableGeometry = new THREE.BoxGeometry(12, 0.4, 6);
          const confTableMaterial = new THREE.MeshStandardMaterial({
            color: 0x2f1b14,
            roughness: 0.3,
            metalness: 0.1,
          });
          const conferenceTable = new THREE.Mesh(conferenceTableGeometry, confTableMaterial);
          conferenceTable.position.set(85, 2.5, 35);
          conferenceTable.castShadow = true;
          conferenceTable.receiveShadow = true;
          this.scene.add(conferenceTable);

          // Table legs
          const legPositions = [
            [-5, -2.5], [5, -2.5], [-5, 2.5], [5, 2.5]
          ];
          
          legPositions.forEach(([x, z]) => {
            const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2.5, 8);
            const leg = new THREE.Mesh(legGeometry, confTableMaterial);
            leg.position.set(85 + x, 1.25, 35 + z);
            leg.castShadow = true;
            this.scene.add(leg);
          });

          // Conference chairs around table
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const chairX = 85 + Math.cos(angle) * 8;
            const chairZ = 35 + Math.sin(angle) * 4;
            
            const confChairMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.3,
              metalness: 0.1,
            });

            const seatGeometry = new THREE.BoxGeometry(1.8, 0.3, 1.8);
            const seat = new THREE.Mesh(seatGeometry, confChairMaterial);
            seat.position.set(chairX, 2, chairZ);
            seat.rotation.y = -angle;
            seat.castShadow = true;
            this.scene.add(seat);

            const backGeometry = new THREE.BoxGeometry(1.8, 2, 0.2);
            const back = new THREE.Mesh(backGeometry, confChairMaterial);
            back.position.set(
              chairX - Math.sin(angle) * 0.8,
              3,
              chairZ + Math.cos(angle) * 0.8
            );
            back.rotation.y = -angle;
            back.castShadow = true;
            this.scene.add(back);
          }
        }

        createRugSection() {
          // Area rug display
          const rugDisplayGeometry = new THREE.BoxGeometry(30, 0.2, 20);
          const rugDisplayMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            roughness: 0.8,
            metalness: 0,
          });
          const rugDisplay = new THREE.Mesh(rugDisplayGeometry, rugDisplayMaterial);
          rugDisplay.position.set(0, 0.1, 20);
          rugDisplay.receiveShadow = true;
          this.scene.add(rugDisplay);

          // Hanging rug racks
          const rackMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.8,
            metalness: 0.5,
          });

          for (let i = 0; i < 3; i++) {
            const rackGeometry = new THREE.BoxGeometry(0.5, 8, 0.5);
            const leftRack = new THREE.Mesh(rackGeometry, rackMaterial);
            leftRack.position.set(-10 + i * 10, 4, 30);
            leftRack.castShadow = true;
            this.scene.add(leftRack);

            const rightRack = new THREE.Mesh(rackGeometry, rackMaterial);
            rightRack.position.set(-8 + i * 10, 4, 30);
            rightRack.castShadow = true;
            this.scene.add(rightRack);

            // Horizontal bar
            const barGeometry = new THREE.BoxGeometry(2.5, 0.3, 0.3);
            const bar = new THREE.Mesh(barGeometry, rackMaterial);
            bar.position.set(-9 + i * 10, 7, 30);
            this.scene.add(bar);

            // Hanging rugs
            const rugColors = [0x8b4513, 0x2f4f4f, 0x8b0000, 0x4169e1, 0x696969];
            for (let j = 0; j < 4; j++) {
              const rugGeometry = new THREE.BoxGeometry(0.1, 6 - j * 0.5, 4 - j * 0.3);
              const rugMaterial = new THREE.MeshStandardMaterial({
                color: rugColors[(i * 4 + j) % rugColors.length],
                roughness: 0.9,
                metalness: 0,
              });
              const rug = new THREE.Mesh(rugGeometry, rugMaterial);
              rug.position.set(-9 + i * 10, 4 - j * 0.25, 30 + j * 0.3);
              rug.castShadow = true;
              this.scene.add(rug);
            }
          }

          // Floor rug samples
          const sampleRugs = [
            { size: [8, 0.2, 10], pattern: 'persian', color: 0x8b0000 },
            { size: [6, 0.2, 9], pattern: 'modern', color: 0x4169e1 },
            { size: [10, 0.2, 12], pattern: 'traditional', color: 0x2f4f4f },
            { size: [5, 0.2, 7], pattern: 'geometric', color: 0x696969 },
            { size: [9, 0.2, 11], pattern: 'floral', color: 0x8b4513 }
          ];

          sampleRugs.forEach((rug, i) => {
            const rugGeometry = new THREE.BoxGeometry(...rug.size);
            const rugMaterial = new THREE.MeshStandardMaterial({
              color: rug.color,
              roughness: 0.9,
              metalness: 0,
            });
            const floorRug = new THREE.Mesh(rugGeometry, rugMaterial);
            floorRug.position.set(
              -10 + (i % 3) * 10,
              0.2,
              15 + Math.floor(i / 3) * 6
            );
            floorRug.receiveShadow = true;
            floorRug.castShadow = true;
            this.scene.add(floorRug);

            // Pattern overlay (simulated with lines)
            if (rug.pattern === 'geometric') {
              const lineGeometry = new THREE.BoxGeometry(rug.size[0] - 1, 0.01, 0.2);
              const lineMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.9,
                metalness: 0,
              });
              for (let j = 0; j < 3; j++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(
                  -10 + (i % 3) * 10,
                  0.31,
                  13 + Math.floor(i / 3) * 6 + j * 2
                );
                this.scene.add(line);
              }
            }
          });
        }

        createLampSection() {
          // Lamp showcase area
          const lampPlatformGeometry = new THREE.BoxGeometry(25, 0.3, 15);
          const lampPlatformMaterial = new THREE.MeshStandardMaterial({
            color: 0xf5f5dc,
            roughness: 0.7,
            metalness: 0.1,
          });
          const lampPlatform = new THREE.Mesh(lampPlatformGeometry, lampPlatformMaterial);
          lampPlatform.position.set(-25, 0.15, 35);
          lampPlatform.receiveShadow = true;
          this.scene.add(lampPlatform);

          // Various lamp styles
          const lampStyles = [
            { base: 'ceramic', shade: 'fabric', height: 3 },
            { base: 'brass', shade: 'glass', height: 4 },
            { base: 'wood', shade: 'paper', height: 2.5 },
            { base: 'crystal', shade: 'silk', height: 3.5 },
            { base: 'iron', shade: 'metal', height: 3 }
          ];

          const baseColors = {
            ceramic: 0xf5f5dc,
            brass: 0xffd700,
            wood: 0x8b4513,
            crystal: 0xe0e0e0,
            iron: 0x2a2a2a
          };

          const shadeColors = {
            fabric: 0xfff8dc,
            glass: 0xf0f8ff,
            paper: 0xfffff0,
            silk: 0xfaf0e6,
            metal: 0x696969
          };

          for (let i = 0; i < 12; i++) {
            const style = lampStyles[i % lampStyles.length];
            const lampX = -35 + (i % 4) * 6;
            const lampZ = 30 + Math.floor(i / 4) * 5;

            // Lamp base
            const baseGeometry = new THREE.CylinderGeometry(0.5, 0.7, 1, 12);
            const baseMaterial = new THREE.MeshStandardMaterial({
              color: baseColors[style.base],
              roughness: style.base === 'crystal' ? 0.1 : 0.5,
              metalness: style.base === 'brass' || style.base === 'iron' ? 0.8 : 0.2,
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(lampX, 0.8, lampZ);
            base.castShadow = true;
            this.scene.add(base);

            // Lamp pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, style.height - 1, 8);
            const pole = new THREE.Mesh(poleGeometry, baseMaterial);
            pole.position.set(lampX, 1.3 + (style.height - 1) / 2, lampZ);
            pole.castShadow = true;
            this.scene.add(pole);

            // Lamp shade
            const shadeGeometry = new THREE.CylinderGeometry(
              0.8 + i * 0.05,
              1.2 + i * 0.05,
              1 + i * 0.1,
              16
            );
            const shadeMaterial = new THREE.MeshStandardMaterial({
              color: shadeColors[style.shade],
              roughness: style.shade === 'glass' ? 0.1 : 0.8,
              metalness: style.shade === 'metal' ? 0.7 : 0,
              transparent: style.shade === 'glass',
              opacity: style.shade === 'glass' ? 0.5 : 1,
            });
            const shade = new THREE.Mesh(shadeGeometry, shadeMaterial);
            shade.position.set(lampX, 0.8 + style.height, lampZ);
            shade.castShadow = true;
            this.scene.add(shade);

            // Price tag
            const tagGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.05);
            const tagMaterial = new THREE.MeshStandardMaterial({
              color: 0xffeb3b,
              roughness: 0.8,
              metalness: 0,
            });
            const tag = new THREE.Mesh(tagGeometry, tagMaterial);
            tag.position.set(lampX + 1, 1, lampZ);
            tag.rotation.y = -Math.PI / 4;
            this.scene.add(tag);
          }

          // Floor lamp section
          for (let i = 0; i < 4; i++) {
            const floorLampX = -15 + i * 3;
            const floorLampZ = 40;

            // Base
            const baseGeometry = new THREE.CylinderGeometry(1, 1, 0.3, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.5,
              metalness: 0.7,
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(floorLampX, 0.15, floorLampZ);
            base.castShadow = true;
            this.scene.add(base);

            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 5, 8);
            const pole = new THREE.Mesh(poleGeometry, baseMaterial);
            pole.position.set(floorLampX, 2.5, floorLampZ);
            pole.castShadow = true;
            this.scene.add(pole);

            // Adjustable arm
            const armGeometry = new THREE.BoxGeometry(2, 0.1, 0.1);
            const arm = new THREE.Mesh(armGeometry, baseMaterial);
            arm.position.set(floorLampX + 0.5, 4.5, floorLampZ);
            arm.rotation.z = -Math.PI / 6;
            this.scene.add(arm);

            // Shade
            const shadeGeometry = new THREE.CylinderGeometry(0.5, 1, 1.2, 12);
            const shadeMaterial = new THREE.MeshStandardMaterial({
              color: i % 2 === 0 ? 0xfff8dc : 0x1a1a1a,
              roughness: 0.8,
              metalness: 0.1,
            });
            const shade = new THREE.Mesh(shadeGeometry, shadeMaterial);
            shade.position.set(floorLampX + 1.5, 4.2, floorLampZ);
            shade.rotation.z = -Math.PI / 6;
            shade.castShadow = true;
            this.scene.add(shade);
          }
        }

        createMattressSection() {
          // Mattress testing area
          const mattressPlatformGeometry = new THREE.BoxGeometry(35, 0.5, 25);
          const mattressPlatformMaterial = new THREE.MeshStandardMaterial({
            color: 0xe8e4dd,
            roughness: 0.8,
            metalness: 0,
          });
          const mattressPlatform = new THREE.Mesh(mattressPlatformGeometry, mattressPlatformMaterial);
          mattressPlatform.position.set(35, 0.25, 55);
          mattressPlatform.receiveShadow = true;
          this.scene.add(mattressPlatform);

          // Different mattress types on display
          const mattressTypes = [
            { name: 'Firm', color: 0xf5f5dc, thickness: 2 },
            { name: 'Plush', color: 0xfff8dc, thickness: 3 },
            { name: 'Memory Foam', color: 0xf0e68c, thickness: 2.5 },
            { name: 'Pillow Top', color: 0xfffff0, thickness: 3.5 },
            { name: 'Hybrid', color: 0xfaebd7, thickness: 2.8 }
          ];

          mattressTypes.forEach((type, i) => {
            const mattressGeometry = new THREE.BoxGeometry(8, type.thickness, 10);
            const mattressMaterial = new THREE.MeshStandardMaterial({
              color: type.color,
              roughness: 0.9,
              metalness: 0,
            });
            const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
            mattress.position.set(
              20 + (i % 3) * 10,
              0.5 + type.thickness / 2,
              45 + Math.floor(i / 3) * 12
            );
            mattress.castShadow = true;
            mattress.receiveShadow = true;
            this.scene.add(mattress);

            // Quilting pattern (simulated)
            const quiltLineGeometry = new THREE.BoxGeometry(7.8, 0.05, 0.1);
            const quiltMaterial = new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.9,
              metalness: 0,
            });
            for (let j = 0; j < 4; j++) {
              const line = new THREE.Mesh(quiltLineGeometry, quiltMaterial);
              line.position.set(
                20 + (i % 3) * 10,
                0.5 + type.thickness + 0.03,
                43 + Math.floor(i / 3) * 12 + j * 2.5
              );
              this.scene.add(line);
            }

            // Info placard
            const placardGeometry = new THREE.BoxGeometry(2, 1.5, 0.1);
            const placardMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.8,
              metalness: 0,
            });
            const placard = new THREE.Mesh(placardGeometry, placardMaterial);
            placard.position.set(
              25 + (i % 3) * 10,
              2,
              45 + Math.floor(i / 3) * 12
            );
            placard.rotation.y = -Math.PI / 6;
            placard.castShadow = true;
            this.scene.add(placard);

            // Price tag
            const priceGeometry = new THREE.BoxGeometry(1, 0.6, 0.05);
            const priceMaterial = new THREE.MeshStandardMaterial({
              color: 0xffeb3b,
              roughness: 0.7,
              metalness: 0,
              emissive: 0xffeb3b,
              emissiveIntensity: 0.2,
            });
            const priceTag = new THREE.Mesh(priceGeometry, priceMaterial);
            priceTag.position.set(
              25 + (i % 3) * 10,
              1.3,
              45.1 + Math.floor(i / 3) * 12
            );
            priceTag.rotation.y = -Math.PI / 6;
            this.scene.add(priceTag);
          });

          // Box spring display
          const boxSpringGeometry = new THREE.BoxGeometry(8, 1.5, 10);
          const boxSpringMaterial = new THREE.MeshStandardMaterial({
            color: 0xd3d3d3,
            roughness: 0.8,
            metalness: 0.1,
          });

          for (let i = 0; i < 3; i++) {
            const boxSpring = new THREE.Mesh(boxSpringGeometry, boxSpringMaterial);
            boxSpring.position.set(50, 0.75, 50 + i * 5);
            boxSpring.castShadow = true;
            boxSpring.receiveShadow = true;
            this.scene.add(boxSpring);
          }
        }

        createKidsSection() {
          // Children's furniture section
          const kidsPlatformGeometry = new THREE.BoxGeometry(30, 0.3, 25);
          const kidsPlatformMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            roughness: 0.9,
            metalness: 0,
          });
          const kidsPlatform = new THREE.Mesh(kidsPlatformGeometry, kidsPlatformMaterial);
          kidsPlatform.position.set(-50, 0.15, 55);
          kidsPlatform.receiveShadow = true;
          this.scene.add(kidsPlatform);

          // Bunk beds
          const bunkBedMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.7,
            metalness: 0,
          });

          for (let i = 0; i < 2; i++) {
            const bunkX = -60 + i * 15;
            const bunkZ = 50;

            // Bottom bunk
            const bottomBunkGeometry = new THREE.BoxGeometry(5, 1, 8);
            const bottomBunk = new THREE.Mesh(bottomBunkGeometry, bunkBedMaterial);
            bottomBunk.position.set(bunkX, 1, bunkZ);
            bottomBunk.castShadow = true;
            bottomBunk.receiveShadow = true;
            this.scene.add(bottomBunk);

            // Top bunk
            const topBunkGeometry = new THREE.BoxGeometry(5, 1, 8);
            const topBunk = new THREE.Mesh(topBunkGeometry, bunkBedMaterial);
            topBunk.position.set(bunkX, 4, bunkZ);
            topBunk.castShadow = true;
            topBunk.receiveShadow = true;
            this.scene.add(topBunk);

            // Corner posts
            const postPositions = [
              [bunkX - 2.4, bunkZ - 3.9],
              [bunkX + 2.4, bunkZ - 3.9],
              [bunkX - 2.4, bunkZ + 3.9],
              [bunkX + 2.4, bunkZ + 3.9]
            ];

            postPositions.forEach(([x, z]) => {
              const postGeometry = new THREE.BoxGeometry(0.3, 6, 0.3);
              const post = new THREE.Mesh(postGeometry, bunkBedMaterial);
              post.position.set(x, 3, z);
              post.castShadow = true;
              this.scene.add(post);
            });

            // Ladder
            const ladderSideGeometry = new THREE.BoxGeometry(0.2, 4, 0.2);
            const leftLadder = new THREE.Mesh(ladderSideGeometry, bunkBedMaterial);
            leftLadder.position.set(bunkX + 2.8, 2.5, bunkZ);
            leftLadder.castShadow = true;
            this.scene.add(leftLadder);

            const rightLadder = new THREE.Mesh(ladderSideGeometry, bunkBedMaterial);
            rightLadder.position.set(bunkX + 3.2, 2.5, bunkZ);
            rightLadder.castShadow = true;
            this.scene.add(rightLadder);

            // Ladder rungs
            for (let j = 0; j < 4; j++) {
              const rungGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.2);
              const rung = new THREE.Mesh(rungGeometry, bunkBedMaterial);
              rung.position.set(bunkX + 3, 1 + j * 1, bunkZ);
              this.scene.add(rung);
            }

            // Mattresses
            const kidMattressGeometry = new THREE.BoxGeometry(4.5, 1.5, 7.5);
            const kidMattressMaterial = new THREE.MeshStandardMaterial({
              color: 0xffc0cb,
              roughness: 0.9,
              metalness: 0,
            });
            
            const bottomMattress = new THREE.Mesh(kidMattressGeometry, kidMattressMaterial);
            bottomMattress.position.set(bunkX, 2, bunkZ);
            bottomMattress.castShadow = true;
            this.scene.add(bottomMattress);

            const topMattress = new THREE.Mesh(kidMattressGeometry, kidMattressMaterial);
            topMattress.position.set(bunkX, 5, bunkZ);
            topMattress.castShadow = true;
            this.scene.add(topMattress);
          }

          // Kids' dressers with fun colors
          const dresserColors = [0xff69b4, 0x00ced1, 0xffa500, 0x32cd32];

          for (let i = 0; i < 4; i++) {
            const dresserMaterial = new THREE.MeshStandardMaterial({
              color: dresserColors[i],
              roughness: 0.7,
              metalness: 0.1,
            });

            const dresserGeometry = new THREE.BoxGeometry(4, 3, 2);
            const dresser = new THREE.Mesh(dresserGeometry, dresserMaterial);
            dresser.position.set(-55 + i * 5, 1.5, 60);
            dresser.castShadow = true;
            dresser.receiveShadow = true;
            this.scene.add(dresser);

            // Fun shaped handles
            for (let j = 0; j < 3; j++) {
              const handleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
              const handleMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.3,
              });
              const handle = new THREE.Mesh(handleGeometry, handleMaterial);
              handle.position.set(-55 + i * 5, 0.5 + j * 1, 61.1);
              this.scene.add(handle);
            }
          }

          // Kids' desks
          const deskColors = [0x87ceeb, 0xffb6c1, 0x98fb98, 0xdda0dd];

          for (let i = 0; i < 3; i++) {
            const kidDeskMaterial = new THREE.MeshStandardMaterial({
              color: deskColors[i],
              roughness: 0.7,
              metalness: 0.1,
            });

            const deskTopGeometry = new THREE.BoxGeometry(4, 0.3, 3);
            const deskTop = new THREE.Mesh(deskTopGeometry, kidDeskMaterial);
            deskTop.position.set(-40, 2, 50 + i * 5);
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            this.scene.add(deskTop);

            // Desk legs
            const legPositions = [
              [-1.8, -1.3], [1.8, -1.3], [-1.8, 1.3], [1.8, 1.3]
            ];

            legPositions.forEach(([x, z]) => {
              const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);
              const leg = new THREE.Mesh(legGeometry, kidDeskMaterial);
              leg.position.set(-40 + x, 1, 50 + i * 5 + z);
              leg.castShadow = true;
              this.scene.add(leg);
            });

            // Pencil holder
            const holderGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 12);
            const holderMaterial = new THREE.MeshStandardMaterial({
              color: 0xff69b4,
              roughness: 0.8,
              metalness: 0.2,
            });
            const holder = new THREE.Mesh(holderGeometry, holderMaterial);
            holder.position.set(-39, 2.4, 50 + i * 5);
            this.scene.add(holder);
          }
        }

        createClearanceSection() {
          // Clearance section with mixed furniture
          const clearanceSignGeometry = new THREE.BoxGeometry(20, 4, 0.5);
          const clearanceSignMaterial = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            roughness: 0.4,
            metalness: 0,
            emissive: 0xff0000,
            emissiveIntensity: 0.3,
          });
          const clearanceSign = new THREE.Mesh(clearanceSignGeometry, clearanceSignMaterial);
          clearanceSign.position.set(0, 6, -75);
          clearanceSign.castShadow = true;
          this.scene.add(clearanceSign);

          // "CLEARANCE" text
          const clearanceTextMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            roughness: 0.3,
            metalness: 0,
            emissive: 0xffff00,
            emissiveIntensity: 0.4,
          });

          const letters = "CLEARANCE";
          for (let i = 0; i < letters.length; i++) {
            const letterGeometry = new THREE.BoxGeometry(1.5, 2, 0.2);
            const letter = new THREE.Mesh(letterGeometry, clearanceTextMaterial);
            letter.position.set(-8 + i * 1.8, 6, -74.7);
            this.scene.add(letter);
          }

          // "50-70% OFF" sub-text
          const subTextGeometry = new THREE.BoxGeometry(10, 1, 0.2);
          const subText = new THREE.Mesh(subTextGeometry, clearanceTextMaterial);
          subText.position.set(0, 3.5, -74.7);
          this.scene.add(subText);

          // Mixed clearance items
          const clearanceArea = new THREE.BoxGeometry(40, 0.1, 30);
          const clearanceFloorMaterial = new THREE.MeshStandardMaterial({
            color: 0xffeb3b,
            roughness: 0.9,
            metalness: 0,
          });
          const clearanceFloor = new THREE.Mesh(clearanceArea, clearanceFloorMaterial);
          clearanceFloor.rotation.x = -Math.PI / 2;
          clearanceFloor.position.set(0, 0.05, -85);
          clearanceFloor.receiveShadow = true;
          this.scene.add(clearanceFloor);

          // Random clearance furniture
          const clearanceItems = [
            { type: 'chair', color: 0x8b4513, pos: [-15, 1, -80] },
            { type: 'table', color: 0x654321, pos: [-10, 1, -85] },
            { type: 'lamp', color: 0xffd700, pos: [-5, 1, -82] },
            { type: 'ottoman', color: 0x2f4f4f, pos: [0, 0.5, -88] },
            { type: 'shelf', color: 0x8b6f47, pos: [5, 2, -83] },
            { type: 'stool', color: 0x696969, pos: [10, 0.8, -86] },
            { type: 'cabinet', color: 0x4a3c28, pos: [15, 2, -81] }
          ];

          clearanceItems.forEach(item => {
            const material = new THREE.MeshStandardMaterial({
              color: item.color,
              roughness: 0.7,
              metalness: 0.1,
            });

            let geometry;
            switch(item.type) {
              case 'chair':
                geometry = new THREE.BoxGeometry(2, 2, 2);
                break;
              case 'table':
                geometry = new THREE.BoxGeometry(4, 0.3, 3);
                break;
              case 'lamp':
                geometry = new THREE.CylinderGeometry(0.5, 0.7, 2, 12);
                break;
              case 'ottoman':
                geometry = new THREE.BoxGeometry(2.5, 1, 2.5);
                break;
              case 'shelf':
                geometry = new THREE.BoxGeometry(3, 4, 1);
                break;
              case 'stool':
                geometry = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16);
                break;
              case 'cabinet':
                geometry = new THREE.BoxGeometry(2.5, 4, 2);
                break;
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(...item.pos);
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            this.scene.add(mesh);

            // Red sale tag on each item
            const tagGeometry = new THREE.BoxGeometry(1, 0.6, 0.05);
            const tagMaterial = new THREE.MeshStandardMaterial({
              color: 0xff0000,
              roughness: 0.7,
              metalness: 0,
              emissive: 0xff0000,
              emissiveIntensity: 0.2,
            });
            const tag = new THREE.Mesh(tagGeometry, tagMaterial);
            tag.position.set(item.pos[0] + 1, item.pos[1] + 1, item.pos[2]);
            tag.rotation.y = Math.random() * Math.PI;
            this.scene.add(tag);
          });
        }

        createCheckoutArea() {
          // Extended checkout area with multiple registers
          const checkoutPlatformGeometry = new THREE.BoxGeometry(60, 0.5, 20);
          const checkoutPlatformMaterial = new THREE.MeshStandardMaterial({
            color: 0xd3d3d3,
            roughness: 0.7,
            metalness: 0.2,
          });
          const checkoutPlatform = new THREE.Mesh(checkoutPlatformGeometry, checkoutPlatformMaterial);
          checkoutPlatform.position.set(0, 0.25, 80);
          checkoutPlatform.receiveShadow = true;
          this.scene.add(checkoutPlatform);

          // Checkout counters
          const counterMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.6,
            metalness: 0.3,
          });

          for (let i = 0; i < 6; i++) {
            const counterGeometry = new THREE.BoxGeometry(5, 3.5, 10);
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(-25 + i * 10, 1.75, 80);
            counter.castShadow = true;
            counter.receiveShadow = true;
            this.scene.add(counter);

            // Counter top
            const topGeometry = new THREE.BoxGeometry(5.2, 0.3, 10.2);
            const topMaterial = new THREE.MeshStandardMaterial({
              color: 0x2a2a2a,
              roughness: 0.4,
              metalness: 0.6,
            });
            const counterTop = new THREE.Mesh(topGeometry, topMaterial);
            counterTop.position.set(-25 + i * 10, 3.65, 80);
            this.scene.add(counterTop);

            // Register (90s style with physical buttons)
            const registerGeometry = new THREE.BoxGeometry(2.5, 1.5, 2.5);
            const registerMaterial = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.4,
              metalness: 0.6,
            });
            const register = new THREE.Mesh(registerGeometry, registerMaterial);
            register.position.set(-25 + i * 10, 4.5, 80);
            register.castShadow = true;
            this.scene.add(register);

            // Register display
            const displayGeometry = new THREE.BoxGeometry(2, 0.5, 0.1);
            const displayMaterial = new THREE.MeshStandardMaterial({
              color: 0x00ff00,
              roughness: 0.2,
              metalness: 0.1,
              emissive: 0x00ff00,
              emissiveIntensity: 0.3,
            });
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.set(-25 + i * 10, 5.2, 81.3);
            this.scene.add(display);

            // Number pad
            for (let row = 0; row < 4; row++) {
              for (let col = 0; col < 3; col++) {
                const buttonGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.2);
                const buttonMaterial = new THREE.MeshStandardMaterial({
                  color: 0x333333,
                  roughness: 0.7,
                  metalness: 0.3,
                });
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(
                  -25.5 + i * 10 + col * 0.4,
                  4.3 - row * 0.4,
                  81.3
                );
                this.scene.add(button);
              }
            }

            // Conveyor belt
            const beltGeometry = new THREE.BoxGeometry(4, 0.1, 8);
            const beltMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.9,
              metalness: 0.1,
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.set(-25 + i * 10, 3.55, 76);
            this.scene.add(belt);

            // Divider bars
            const dividerGeometry = new THREE.BoxGeometry(0.1, 0.5, 6);
            const dividerMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.8,
              metalness: 0.5,
            });
            const divider = new THREE.Mesh(dividerGeometry, dividerMaterial);
            divider.position.set(-22.5 + i * 10, 3.9, 76);
            this.scene.add(divider);

            // Bag area
            const bagAreaGeometry = new THREE.BoxGeometry(2, 0.1, 4);
            const bagArea = new THREE.Mesh(bagAreaGeometry, beltMaterial);
            bagArea.position.set(-25 + i * 10, 3.55, 72);
            this.scene.add(bagArea);

            // Register light
            const lightPoleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
            const lightPoleMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.7,
              metalness: 0.6,
            });
            const lightPole = new THREE.Mesh(lightPoleGeometry, lightPoleMaterial);
            lightPole.position.set(-25 + i * 10, 5.5, 80);
            this.scene.add(lightPole);

            // Lane number sign
            const laneSignGeometry = new THREE.BoxGeometry(1.5, 1, 0.1);
            const laneSignMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a4d2e,
              roughness: 0.5,
              metalness: 0.1,
              emissive: 0x1a4d2e,
              emissiveIntensity: 0.2,
            });
            const laneSign = new THREE.Mesh(laneSignGeometry, laneSignMaterial);
            laneSign.position.set(-25 + i * 10, 6.5, 80);
            laneSign.castShadow = true;
            this.scene.add(laneSign);

            // Lane number
            const numberGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.05);
            const numberMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.3,
              metalness: 0,
              emissive: 0xffffff,
              emissiveIntensity: 0.3,
            });
            const number = new THREE.Mesh(numberGeometry, numberMaterial);
            number.position.set(-25 + i * 10, 6.5, 80.06);
            this.scene.add(number);
          }

          // Customer service podium near checkout
          const podiumGeometry = new THREE.CylinderGeometry(3, 3, 1, 16);
          const podiumMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6f47,
            roughness: 0.6,
            metalness: 0.1,
          });
          const podium = new THREE.Mesh(podiumGeometry, podiumMaterial);
          podium.position.set(40, 0.5, 80);
          podium.castShadow = true;
          podium.receiveShadow = true;
          this.scene.add(podium);

          // Impulse buy displays
          const impulseRackMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.8,
            metalness: 0.5,
          });

          for (let i = 0; i < 10; i++) {
            const rackGeometry = new THREE.BoxGeometry(2, 3, 1);
            const rack = new THREE.Mesh(rackGeometry, impulseRackMaterial);
            rack.position.set(-28 + i * 6, 1.5, 70);
            rack.castShadow = true;
            this.scene.add(rack);

            // Candy/magazines
            for (let j = 0; j < 3; j++) {
              const itemGeometry = new THREE.BoxGeometry(1.5, 0.3, 0.2);
              const itemColors = [0xff0000, 0x0000ff, 0xffff00, 0x00ff00];
              const itemMaterial = new THREE.MeshStandardMaterial({
                color: itemColors[j % itemColors.length],
                roughness: 0.8,
                metalness: 0,
              });
              const item = new THREE.Mesh(itemGeometry, itemMaterial);
              item.position.set(-28 + i * 6, 0.5 + j * 1, 70.6);
              this.scene.add(item);
            }
          }
        }

        createDepartmentSigns() {
          // Enhanced department hanging signs with proper NFM branding
          const signMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.3,
            metalness: 0.1,
            emissive: 0x1a4d2e,
            emissiveIntensity: 0.2,
          });

          const textMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.3,
            metalness: 0.1,
            emissive: 0xffffff,
            emissiveIntensity: 0.3,
          });

          const signs = [
            { text: "LIVING ROOM", pos: [-40, 10, -25] },
            { text: "BEDROOM", pos: [35, 10, -25] },
            { text: "ELECTRONICS", pos: [0, 10, -45] },
            { text: "APPLIANCES", pos: [-70, 10, 0] },
            { text: "OFFICE", pos: [70, 10, 25] },
            { text: "RUGS & LAMPS", pos: [0, 10, 25] },
            { text: "MATTRESSES", pos: [35, 10, 55] },
            { text: "KIDS", pos: [-50, 10, 55] },
            { text: "CLEARANCE", pos: [0, 10, -85] },
            { text: "CHECKOUT", pos: [0, 10, 75] }
          ];

          // Create signs with simulated text using boxes
          signs.forEach(sign => {
            const signGeometry = new THREE.BoxGeometry(sign.text.length * 1.2 + 2, 3, 0.5);
            const signMesh = new THREE.Mesh(signGeometry, signMaterial);
            signMesh.position.set(...sign.pos);
            signMesh.castShadow = true;
            this.scene.add(signMesh);

            // Simulated text using white boxes
            const letterWidth = 0.8;
            const letterSpacing = 1;
            const totalWidth = sign.text.length * letterSpacing;
            const startX = -totalWidth / 2 + letterSpacing / 2;

            for (let i = 0; i < sign.text.length; i++) {
              if (sign.text[i] !== ' ') {
                const letterGeometry = new THREE.BoxGeometry(letterWidth, 1.8, 0.1);
                const letter = new THREE.Mesh(letterGeometry, textMaterial);
                letter.position.set(
                  sign.pos[0] + startX + i * letterSpacing,
                  sign.pos[1],
                  sign.pos[2] + 0.31
                );
                this.scene.add(letter);
              }
            }

            // Sign posts with chains
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const postMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.8,
              metalness: 0.5,
            });

            const signWidth = sign.text.length * 1.2 + 2;
            const post1 = new THREE.Mesh(postGeometry, postMaterial);
            post1.position.set(sign.pos[0] - signWidth/2 + 1, 11.5, sign.pos[2]);
            this.scene.add(post1);

            const post2 = new THREE.Mesh(postGeometry, postMaterial);
            post2.position.set(sign.pos[0] + signWidth/2 - 1, 11.5, sign.pos[2]);
            this.scene.add(post2);
          });

          // Main entrance sign - massive NFM branding
          const entranceSignGeometry = new THREE.BoxGeometry(50, 8, 1);
          const entranceSign = new THREE.Mesh(entranceSignGeometry, signMaterial);
          entranceSign.position.set(0, 8, 98);
          entranceSign.castShadow = true;
          this.scene.add(entranceSign);

          // "NEBRASKA FURNITURE MART" text on entrance
          const entranceText = "NEBRASKA FURNITURE MART";
          const entranceLetterWidth = 1.5;
          const entranceLetterSpacing = 1.8;
          const entranceTotalWidth = entranceText.length * entranceLetterSpacing;
          const entranceStartX = -entranceTotalWidth / 2 + entranceLetterSpacing / 2;

          for (let i = 0; i < entranceText.length; i++) {
            if (entranceText[i] !== ' ') {
              const letterGeometry = new THREE.BoxGeometry(entranceLetterWidth, 3, 0.2);
              const letter = new THREE.Mesh(letterGeometry, textMaterial);
              letter.position.set(
                entranceStartX + i * entranceLetterSpacing,
                8,
                98.51
              );
              this.scene.add(letter);
            }
          }

          // "SINCE 1937" sub-text
          const sinceTextGeometry = new THREE.BoxGeometry(8, 1, 0.1);
          const sinceText = new THREE.Mesh(sinceTextGeometry, textMaterial);
          sinceText.position.set(0, 5, 98.51);
          this.scene.add(sinceText);

          // Aisle markers
          const aisleMarkerMaterial = new THREE.MeshStandardMaterial({
            color: 0x4169e1,
            roughness: 0.5,
            metalness: 0.1,
            emissive: 0x4169e1,
            emissiveIntensity: 0.2,
          });

          for (let i = 1; i <= 12; i++) {
            const markerGeometry = new THREE.BoxGeometry(2, 2, 0.3);
            const marker = new THREE.Mesh(markerGeometry, aisleMarkerMaterial);
            marker.position.set(
              -60 + (i % 4) * 40,
              9,
              -60 + Math.floor((i-1) / 4) * 40
            );
            marker.castShadow = true;
            this.scene.add(marker);

            // Aisle number
            const numberGeometry = new THREE.BoxGeometry(1, 1.2, 0.1);
            const number = new THREE.Mesh(numberGeometry, textMaterial);
            number.position.set(
              -60 + (i % 4) * 40,
              9,
              -59.8 + Math.floor((i-1) / 4) * 40
            );
            this.scene.add(number);
          }
        }

        createPriceTags() {
          // Yellow sale tags with specific prices everywhere
          const tagMaterial = new THREE.MeshStandardMaterial({
            color: 0xffeb3b,
            roughness: 0.8,
            metalness: 0,
            emissive: 0xffeb3b,
            emissiveIntensity: 0.3,
          });

          // Large promotional banners
          const bannerMaterial = new THREE.MeshStandardMaterial({
            color: 0xc41e3a,
            roughness: 0.6,
            metalness: 0,
            emissive: 0xc41e3a,
            emissiveIntensity: 0.2,
          });

          // Floor standing sale signs
          for (let i = 0; i < 20; i++) {
            const standGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
            const standMaterial = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.8,
              metalness: 0.5,
            });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.set(
              (Math.random() - 0.5) * 160,
              1.5,
              (Math.random() - 0.5) * 140
            );
            stand.castShadow = true;
            this.scene.add(stand);

            const signGeometry = new THREE.BoxGeometry(3, 2, 0.1);
            const sign = new THREE.Mesh(signGeometry, tagMaterial);
            sign.position.copy(stand.position);
            sign.position.y = 3.5;
            sign.rotation.y = Math.random() * Math.PI * 2;
            sign.castShadow = true;
            this.scene.add(sign);

            // Price text (simulated)
            const priceGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.05);
            const priceMaterial = new THREE.MeshStandardMaterial({
              color: 0xc41e3a,
              roughness: 0.7,
              metalness: 0,
            });
            const price = new THREE.Mesh(priceGeometry, priceMaterial);
            price.position.copy(sign.position);
            price.position.z += 0.08;
            price.rotation.y = sign.rotation.y;
            this.scene.add(price);
          }

          // Hanging sale banners from ceiling
          for (let i = 0; i < 8; i++) {
            const bannerGeometry = new THREE.BoxGeometry(12, 4, 0.3);
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            banner.position.set(
              (Math.random() - 0.5) * 140,
              9,
              (Math.random() - 0.5) * 120
            );
            banner.rotation.y = Math.random() * Math.PI;
            banner.castShadow = true;
            this.scene.add(banner);

            // "SALE" text on banner
            const saleTextGeometry = new THREE.BoxGeometry(6, 2, 0.1);
            const saleTextMaterial = new THREE.MeshStandardMaterial({
              color: 0xffeb3b,
              roughness: 0.5,
              metalness: 0,
              emissive: 0xffeb3b,
              emissiveIntensity: 0.4,
            });
            const saleText = new THREE.Mesh(saleTextGeometry, saleTextMaterial);
            saleText.position.copy(banner.position);
            saleText.position.z += 0.21 * Math.cos(banner.rotation.y);
            saleText.position.x += 0.21 * Math.sin(banner.rotation.y);
            saleText.rotation.y = banner.rotation.y;
            this.scene.add(saleText);
          }

          // Small price tags on furniture
          for (let i = 0; i < 100; i++) {
            const smallTagGeometry = new THREE.BoxGeometry(1, 0.6, 0.05);
            const tag = new THREE.Mesh(smallTagGeometry, tagMaterial);
            tag.position.set(
              (Math.random() - 0.5) * 160,
              Math.random() * 3 + 1,
              (Math.random() - 0.5) * 140
            );
            tag.rotation.y = Math.random() * Math.PI;
            tag.rotation.z = (Math.random() - 0.5) * 0.2;
            this.scene.add(tag);
          }

          // "LOWEST PRICES GUARANTEED" wall signs
          const guaranteeSignMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.4,
            metalness: 0.1,
            emissive: 0x1a4d2e,
            emissiveIntensity: 0.2,
          });

          const wallSigns = [
            { pos: [-99, 8, 0], rotation: [0, Math.PI / 2, 0] },
            { pos: [99, 8, 0], rotation: [0, -Math.PI / 2, 0] },
            { pos: [0, 8, -99], rotation: [0, 0, 0] },
            { pos: [0, 8, 99], rotation: [0, Math.PI, 0] }
          ];

          wallSigns.forEach(sign => {
            const signGeometry = new THREE.BoxGeometry(30, 3, 0.5);
            const wallSign = new THREE.Mesh(signGeometry, guaranteeSignMaterial);
            wallSign.position.set(...sign.pos);
            wallSign.rotation.set(...sign.rotation);
            wallSign.castShadow = true;
            this.scene.add(wallSign);

            // Text on wall sign
            const textGeometry = new THREE.BoxGeometry(20, 1.5, 0.1);
            const wallText = new THREE.Mesh(textGeometry, textMaterial);
            wallText.position.set(...sign.pos);
            if (sign.rotation[1] === Math.PI / 2) {
              wallText.position.x += 0.31;
            } else if (sign.rotation[1] === -Math.PI / 2) {
              wallText.position.x -= 0.31;
            } else if (sign.rotation[1] === 0) {
              wallText.position.z += 0.31;
            } else {
              wallText.position.z -= 0.31;
            }
            wallText.rotation.set(...sign.rotation);
            this.scene.add(wallText);
          });
        }

        createNPCs() {
          this.npcs = [];
          
          // Create cashiers
          this.createCashiers();
          
          // Create shopping customers
          this.createCustomers();
          
          // Create sales associates
          this.createSalesAssociates();
          
          // Create greeters
          this.createGreeters();
          
          // Create stockers
          this.createStockers();
        }

        createCashiers() {
          // Cashier material
          const cashierBodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e, // Store uniform green
            roughness: 0.8,
            metalness: 0,
          });

          const skinMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdbac,
            roughness: 0.7,
            metalness: 0,
          });

          const hairColors = [0x000000, 0x8b4513, 0xdaa520, 0x696969];

          // Create 6 cashiers at checkout counters
          for (let i = 0; i < 6; i++) {
            const cashierGroup = new THREE.Group();
            
            // Body (uniform)
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 3, 8);
            const body = new THREE.Mesh(bodyGeometry, cashierBodyMaterial);
            body.position.y = 1.5;
            cashierGroup.add(body);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 6);
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.7, 2, 0);
            leftArm.rotation.z = Math.PI / 6;
            cashierGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.7, 2, 0);
            rightArm.rotation.z = -Math.PI / 6;
            cashierGroup.add(rightArm);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.5;
            cashierGroup.add(head);

            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.55, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({
              color: hairColors[i % hairColors.length],
              roughness: 0.9,
              metalness: 0,
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 3.6;
            hair.scale.y = 0.7;
            cashierGroup.add(hair);

            // Name tag
            const tagGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.05);
            const tagMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.5,
              metalness: 0,
            });
            const nameTag = new THREE.Mesh(tagGeometry, tagMaterial);
            nameTag.position.set(0.3, 2.5, 0.6);
            cashierGroup.add(nameTag);

            // Vest
            const vestGeometry = new THREE.BoxGeometry(1.3, 2, 0.1);
            const vest = new THREE.Mesh(vestGeometry, cashierBodyMaterial);
            vest.position.set(0, 2, 0.55);
            cashierGroup.add(vest);

            // Position at checkout counter
            cashierGroup.position.set(-25 + i * 10, 0, 76);
            cashierGroup.userData = {
              type: 'cashier',
              name: ['Sarah', 'Mike', 'Jennifer', 'Tom', 'Lisa', 'David'][i],
              animation: 'scanning',
              greeting: `Hi! Welcome to Nebraska Furniture Mart! I'm ${['Sarah', 'Mike', 'Jennifer', 'Tom', 'Lisa', 'David'][i]}. Did you find everything you were looking for today?`,
              scanSpeed: 0.5 + Math.random() * 0.3
            };

            this.npcs.push(cashierGroup);
            this.scene.add(cashierGroup);
          }
        }

        createCustomers() {
          // Various customer types
          const customerClothes = [
            { shirt: 0x4169e1, pants: 0x000080, skin: 0xffdbac }, // Blue shirt, jeans
            { shirt: 0xffc0cb, pants: 0x000000, skin: 0xdaa520 }, // Pink shirt, black pants
            { shirt: 0x228b22, pants: 0x8b4513, skin: 0xf4a460 }, // Green shirt, khakis
            { shirt: 0xff0000, pants: 0x000080, skin: 0xffe4b5 }, // Red shirt, jeans
            { shirt: 0x9370db, pants: 0x696969, skin: 0xcd853f }, // Purple shirt, gray pants
            { shirt: 0xffffff, pants: 0x000080, skin: 0xffdbac }, // White shirt, jeans
            { shirt: 0x000000, pants: 0x000000, skin: 0xf4a460 }, // All black
            { shirt: 0xffff00, pants: 0x000080, skin: 0xffe4b5 }, // Yellow shirt
          ];

          // Create 25 customers wandering the store
          for (let i = 0; i < 25; i++) {
            const customerGroup = new THREE.Group();
            const outfit = customerClothes[i % customerClothes.length];
            
            // Body/shirt
            const shirtMaterial = new THREE.MeshStandardMaterial({
              color: outfit.shirt,
              roughness: 0.8,
              metalness: 0,
            });
            
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.6, 2, 8);
            const body = new THREE.Mesh(bodyGeometry, shirtMaterial);
            body.position.y = 1.5;
            customerGroup.add(body);

            // Pants
            const pantsMaterial = new THREE.MeshStandardMaterial({
              color: outfit.pants,
              roughness: 0.9,
              metalness: 0,
            });
            
            const pantsGeometry = new THREE.CylinderGeometry(0.6, 0.4, 2, 8);
            const pants = new THREE.Mesh(pantsGeometry, pantsMaterial);
            pants.position.y = 0.5;
            customerGroup.add(pants);

            // Head
            const skinMaterial = new THREE.MeshStandardMaterial({
              color: outfit.skin,
              roughness: 0.7,
              metalness: 0,
            });
            
            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3;
            customerGroup.add(head);

            // Hair
            const hairColors = [0x000000, 0x8b4513, 0xdaa520, 0x696969, 0xd2691e];
            const hairGeometry = new THREE.SphereGeometry(0.45, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({
              color: hairColors[i % hairColors.length],
              roughness: 0.9,
              metalness: 0,
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 3.1;
            hair.scale.y = 0.6;
            customerGroup.add(hair);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 6);
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.6, 1.8, 0);
            leftArm.rotation.z = Math.PI / 8;
            customerGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.6, 1.8, 0);
            rightArm.rotation.z = -Math.PI / 8;
            customerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 6);
            const leftLeg = new THREE.Mesh(legGeometry, skinMaterial);
            leftLeg.position.set(-0.2, -0.5, 0);
            customerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, skinMaterial);
            rightLeg.position.set(0.2, -0.5, 0);
            customerGroup.add(rightLeg);

            // Shopping behavior
            const behaviors = ['browsing', 'testing', 'comparing', 'walking', 'sitting'];
            const interests = ['sofa', 'bed', 'tv', 'appliance', 'desk', 'lamp'];

            // Initial random position
            customerGroup.position.set(
              (Math.random() - 0.5) * 140,
              0,
              (Math.random() - 0.5) * 120
            );

            // Customer data
            customerGroup.userData = {
              type: 'customer',
              behavior: behaviors[i % behaviors.length],
              targetPosition: new THREE.Vector3(),
              speed: 0.02 + Math.random() * 0.03,
              idleTime: 0,
              maxIdleTime: 3 + Math.random() * 5,
              currentDepartment: null,
              interests: interests[Math.floor(Math.random() * interests.length)],
              animation: 'walking',
              hasCart: Math.random() > 0.7,
              path: [],
              pathIndex: 0
            };

            // Add shopping cart for some customers
            if (customerGroup.userData.hasCart) {
              const cartGeometry = new THREE.BoxGeometry(1.5, 1, 2);
              const cartMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.8,
                metalness: 0.5,
              });
              const cart = new THREE.Mesh(cartGeometry, cartMaterial);
              cart.position.set(1.5, 0.8, 0);
              customerGroup.add(cart);

              // Cart wheels
              const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
              const wheelPositions = [
                [1, 0.2, -0.8], [2, 0.2, -0.8], 
                [1, 0.2, 0.8], [2, 0.2, 0.8]
              ];
              wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, cartMaterial);
                wheel.position.set(...pos);
                wheel.rotation.z = Math.PI / 2;
                customerGroup.add(wheel);
              });
            }

            // Set initial target
            this.setNewCustomerTarget(customerGroup);

            this.npcs.push(customerGroup);
            this.scene.add(customerGroup);
          }
        }

        createSalesAssociates() {
          // Sales associates in each department
          const associateMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e, // Store uniform
            roughness: 0.8,
            metalness: 0,
          });

          const skinMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdbac,
            roughness: 0.7,
            metalness: 0,
          });

          const departments = [
            { name: 'Living Room', pos: [-40, 0, -25] },
            { name: 'Bedroom', pos: [35, 0, -25] },
            { name: 'Electronics', pos: [0, 0, -45] },
            { name: 'Appliances', pos: [-70, 0, 0] },
            { name: 'Office', pos: [70, 0, 25] },
            { name: 'Rugs', pos: [0, 0, 20] },
            { name: 'Mattresses', pos: [35, 0, 55] },
            { name: 'Kids', pos: [-50, 0, 55] }
          ];

          departments.forEach((dept, i) => {
            const associateGroup = new THREE.Group();
            
            // Body with vest
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 3, 8);
            const body = new THREE.Mesh(bodyGeometry, associateMaterial);
            body.position.y = 1.5;
            associateGroup.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.5;
            associateGroup.add(head);

            // Hair
            const hairColors = [0x000000, 0x8b4513, 0xdaa520, 0x696969];
            const hairGeometry = new THREE.SphereGeometry(0.55, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({
              color: hairColors[i % hairColors.length],
              roughness: 0.9,
              metalness: 0,
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 3.6;
            hair.scale.y = 0.7;
            associateGroup.add(hair);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 6);
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.7, 2, 0);
            leftArm.rotation.z = Math.PI / 8;
            associateGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.7, 2, 0);
            rightArm.rotation.z = -Math.PI / 8;
            associateGroup.add(rightArm);

            // Clipboard
            const clipboardGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.1);
            const clipboardMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b4513,
              roughness: 0.7,
              metalness: 0,
            });
            const clipboard = new THREE.Mesh(clipboardGeometry, clipboardMaterial);
            clipboard.position.set(0.5, 2, 0.5);
            clipboard.rotation.x = -Math.PI / 6;
            associateGroup.add(clipboard);

            // Name badge
            const badgeGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.05);
            const badgeMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.5,
              metalness: 0,
            });
            const badge = new THREE.Mesh(badgeGeometry, badgeMaterial);
            badge.position.set(0.3, 2.5, 0.6);
            associateGroup.add(badge);

            // Measuring tape on belt
            const tapeGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.2);
            const tapeMaterial = new THREE.MeshStandardMaterial({
              color: 0xffff00,
              roughness: 0.6,
              metalness: 0.2,
            });
            const tape = new THREE.Mesh(tapeGeometry, tapeMaterial);
            tape.position.set(-0.8, 1, 0);
            associateGroup.add(tape);

            // Position in department
            associateGroup.position.set(dept.pos[0], dept.pos[1], dept.pos[2]);
            associateGroup.userData = {
              type: 'associate',
              department: dept.name,
              animation: 'helping',
              dialogue: [
                `Welcome to the ${dept.name} department! What can I help you find today?`,
                `We have great deals on ${dept.name.toLowerCase()} furniture this week!`,
                `Let me know if you need any measurements or have questions!`,
                `I can show you our newest ${dept.name.toLowerCase()} arrivals.`,
                `We offer free delivery on all ${dept.name.toLowerCase()} purchases over $399!`
              ],
              currentDialogue: 0,
              basePosition: new THREE.Vector3(dept.pos[0], dept.pos[1], dept.pos[2]),
              wanderRadius: 10,
              isHelping: false,
              helpingCustomer: null
            };

            this.npcs.push(associateGroup);
            this.scene.add(associateGroup);
          });
        }

        createGreeters() {
          // Friendly greeters at entrance
          const greeterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.8,
            metalness: 0,
          });

          for (let i = 0; i < 2; i++) {
            const greeterGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.9, 3.5, 8);
            const body = new THREE.Mesh(bodyGeometry, greeterMaterial);
            body.position.y = 1.75;
            greeterGroup.add(body);

            // Head
            const skinMaterial = new THREE.MeshStandardMaterial({
              color: 0xffdbac,
              roughness: 0.7,
              metalness: 0,
            });
            
            const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 4;
            greeterGroup.add(head);

            // Friendly smile (simulated)
            const smileGeometry = new THREE.TorusGeometry(0.3, 0.05, 4, 8, Math.PI);
            const smileMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b0000,
              roughness: 0.8,
              metalness: 0,
            });
            const smile = new THREE.Mesh(smileGeometry, smileMaterial);
            smile.position.set(0, 3.8, 0.55);
            smile.rotation.z = Math.PI;
            greeterGroup.add(smile);

            // Waving arm
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 6);
            const wavingArm = new THREE.Mesh(armGeometry, skinMaterial);
            wavingArm.position.set(i === 0 ? -0.9 : 0.9, 2.5, 0);
            wavingArm.rotation.z = i === 0 ? Math.PI / 3 : -Math.PI / 3;
            greeterGroup.add(wavingArm);

            const otherArm = new THREE.Mesh(armGeometry, skinMaterial);
            otherArm.position.set(i === 0 ? 0.8 : -0.8, 2, 0);
            otherArm.rotation.z = i === 0 ? -Math.PI / 6 : Math.PI / 6;
            greeterGroup.add(otherArm);

            // Position at entrance
            greeterGroup.position.set(i === 0 ? -15 : 15, 0, 95);
            greeterGroup.rotation.y = Math.PI;
            greeterGroup.userData = {
              type: 'greeter',
              animation: 'waving',
              waveSpeed: 2,
              dialogue: [
                "Welcome to Nebraska Furniture Mart!",
                "Great to see you today!",
                "Let us know if you need any help!",
                "Check out our clearance section for amazing deals!",
                "Don't forget to ask about our financing options!"
              ],
              currentDialogue: 0,
              lastGreetTime: 0,
              greetCooldown: 5000
            };

            this.npcs.push(greeterGroup);
            this.scene.add(greeterGroup);
          }
        }

        createStockers() {
          // Stockers moving merchandise
          const stockerMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.8,
            metalness: 0,
          });

          for (let i = 0; i < 4; i++) {
            const stockerGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.7, 3, 8);
            const body = new THREE.Mesh(bodyGeometry, stockerMaterial);
            body.position.y = 1.5;
            stockerGroup.add(body);

            // Head
            const skinMaterial = new THREE.MeshStandardMaterial({
              color: 0xffdbac,
              roughness: 0.7,
              metalness: 0,
            });
            
            const headGeometry = new THREE.SphereGeometry(0.45, 8, 8);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.3;
            stockerGroup.add(head);

            // Cap
            const capGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8);
            const capMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a4d2e,
              roughness: 0.9,
              metalness: 0,
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 3.5;
            stockerGroup.add(cap);

            const visorGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const visor = new THREE.Mesh(visorGeometry, capMaterial);
            visor.position.set(0, 3.4, 0.4);
            stockerGroup.add(visor);

            // Dolly/hand truck
            const dollyMaterial = new THREE.MeshStandardMaterial({
              color: 0xff0000,
              roughness: 0.6,
              metalness: 0.4,
            });

            const dollyHandle = new THREE.BoxGeometry(0.1, 3, 0.1);
            const handle = new THREE.Mesh(dollyHandle, dollyMaterial);
            handle.position.set(1.5, 1.5, 0);
            stockerGroup.add(handle);

            const dollyBase = new THREE.BoxGeometry(1.5, 0.1, 1);
            const base = new THREE.Mesh(dollyBase, dollyMaterial);
            base.position.set(1.5, 0.05, 0);
            stockerGroup.add(base);

            const dollyBack = new THREE.BoxGeometry(0.1, 2, 1);
            const back = new THREE.Mesh(dollyBack, dollyMaterial);
            back.position.set(2.2, 1, 0);
            stockerGroup.add(back);

            // Boxes on dolly
            const boxMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b4513,
              roughness: 0.8,
              metalness: 0,
            });

            for (let j = 0; j < 3; j++) {
              const boxGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.8);
              const box = new THREE.Mesh(boxGeometry, boxMaterial);
              box.position.set(1.5, 0.5 + j * 0.8, 0);
              stockerGroup.add(box);
            }

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
            const wheelMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.5,
              metalness: 0.7,
            });

            const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel1.position.set(1, 0.2, 0.4);
            wheel1.rotation.z = Math.PI / 2;
            stockerGroup.add(wheel1);

            const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel2.position.set(1, 0.2, -0.4);
            wheel2.rotation.z = Math.PI / 2;
            stockerGroup.add(wheel2);

            // Position and path
            const startPositions = [
              { x: -80, z: -80 },
              { x: 80, z: -80 },
              { x: -80, z: 80 },
              { x: 80, z: 80 }
            ];

            const start = startPositions[i];
            stockerGroup.position.set(start.x, 0, start.z);
            
            stockerGroup.userData = {
              type: 'stocker',
              animation: 'pushing',
              path: this.generateStockerPath(start),
              pathIndex: 0,
              speed: 0.03,
              targetPosition: new THREE.Vector3(),
              restTime: 0,
              maxRestTime: 2,
              isResting: false
            };

            this.npcs.push(stockerGroup);
            this.scene.add(stockerGroup);
          }
        }

        generateStockerPath(start) {
          // Create a path through the store
          const path = [
            new THREE.Vector3(start.x, 0, start.z),
            new THREE.Vector3(start.x * 0.5, 0, start.z),
            new THREE.Vector3(start.x * 0.5, 0, 0),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(-start.x * 0.5, 0, 0),
            new THREE.Vector3(-start.x * 0.5, 0, -start.z),
            new THREE.Vector3(-start.x, 0, -start.z),
            new THREE.Vector3(-start.x, 0, 0),
            new THREE.Vector3(-start.x, 0, start.z),
            new THREE.Vector3(0, 0, start.z),
            new THREE.Vector3(start.x, 0, start.z)
          ];
          return path;
        }

        setNewCustomerTarget(customer) {
          const data = customer.userData;
          
          // Department areas with specific browsing spots
          const departments = {
            sofa: { x: -40, z: -25, radius: 20, spots: [
              { x: -45, z: -30 }, { x: -35, z: -20 }, { x: -40, z: -35 }
            ]},
            bed: { x: 35, z: -25, radius: 20, spots: [
              { x: 30, z: -30 }, { x: 40, z: -20 }, { x: 35, z: -35 }
            ]},
            tv: { x: 0, z: -45, radius: 15, spots: [
              { x: -5, z: -48 }, { x: 5, z: -42 }, { x: 0, z: -50 }
            ]},
            appliance: { x: -70, z: 0, radius: 20, spots: [
              { x: -75, z: -5 }, { x: -65, z: 5 }, { x: -70, z: 0 }
            ]},
            desk: { x: 70, z: 25, radius: 15, spots: [
              { x: 65, z: 20 }, { x: 75, z: 30 }, { x: 70, z: 25 }
            ]},
            lamp: { x: -25, z: 35, radius: 10, spots: [
              { x: -30, z: 35 }, { x: -20, z: 35 }, { x: -25, z: 40 }
            ]}
          };
          
          const dept = departments[data.interests];
          if (dept && Math.random() > 0.3) {
            // Go to interested department
            const spot = dept.spots[Math.floor(Math.random() * dept.spots.length)];
            data.targetPosition.set(spot.x, 0, spot.z);
          } else {
            // Random wandering
            data.targetPosition.set(
              (Math.random() - 0.5) * 140,
              0,
              (Math.random() - 0.5) * 120
            );
          }
          
          data.idleTime = 0;
          data.behavior = Math.random() > 0.5 ? 'browsing' : 'walking';
        }

        updateNPCs(time, delta) {
          if (!this.npcs) return;

          this.npcs.forEach(npc => {
            const data = npc.userData;

            if (data.type === 'cashier') {
              // Cashiers stay at registers but animate
              npc.rotation.y = Math.sin(time * 0.5) * 0.1;
              
              // Scanning animation
              const rightArm = npc.children.find(child => child.position.x > 0 && child.position.y === 2);
              if (rightArm) {
                rightArm.rotation.x = Math.sin(time * data.scanSpeed * 5) * 0.3;
              }
              
              // Check if player is near for interaction
              const distance = npc.position.distanceTo(this.camera.position);
              if (distance < 5 && !data.greeted) {
                console.log(data.greeting);
                data.greeted = true;
              } else if (distance > 10) {
                data.greeted = false;
              }

            } else if (data.type === 'customer') {
              // Customers wander around looking at furniture
              const direction = new THREE.Vector3()
                .subVectors(data.targetPosition, npc.position)
                .normalize();
              
              const distanceToTarget = npc.position.distanceTo(data.targetPosition);

              if (distanceToTarget > 1) {
                // Move towards target
                npc.position.add(direction.multiplyScalar(data.speed));
                
                // Face direction of movement
                npc.lookAt(data.targetPosition.x, npc.position.y, data.targetPosition.z);
                
                // Walking animation (bob up and down)
                npc.position.y = Math.abs(Math.sin(time * 10)) * 0.1;
                
                // Animate legs
                const leftLeg = npc.children.find(child => child.position.x < 0 && child.position.y === -0.5);
                const rightLeg = npc.children.find(child => child.position.x > 0 && child.position.y === -0.5);
                if (leftLeg && rightLeg) {
                  leftLeg.rotation.x = Math.sin(time * 8) * 0.3;
                  rightLeg.rotation.x = -Math.sin(time * 8) * 0.3;
                }
              } else {
                // Reached target, idle for a bit
                data.idleTime += delta;
                npc.position.y = 0;
                
                // Browsing animation (looking around)
                if (data.behavior === 'browsing') {
                  npc.rotation.y += Math.sin(time * 2) * 0.01;
                  
                  // Occasionally bend to look at price tags
                  if (Math.sin(time * 0.5) > 0.5) {
                    npc.rotation.x = 0.2;
                  } else {
                    npc.rotation.x = 0;
                  }
                }

                if (data.idleTime > data.maxIdleTime) {
                  this.setNewCustomerTarget(npc);
                }
              }

            } else if (data.type === 'associate') {
              // Sales associates patrol their departments
              const wanderAngle = time * 0.3;
              const offsetX = Math.sin(wanderAngle) * data.wanderRadius;
              const offsetZ = Math.cos(wanderAngle) * data.wanderRadius;
              
              if (!data.isHelping) {
                npc.position.x = data.basePosition.x + offsetX;
                npc.position.z = data.basePosition.z + offsetZ;
                
                // Look at center of department
                npc.lookAt(data.basePosition.x, npc.position.y, data.basePosition.z);
              }
              
              // Check if player is near
              const distance = npc.position.distanceTo(this.camera.position);
              if (distance < 8 && !data.hasGreeted) {
                console.log(data.dialogue[data.currentDialogue]);
                data.hasGreeted = true;
                data.currentDialogue = (data.currentDialogue + 1) % data.dialogue.length;
              } else if (distance > 15) {
                data.hasGreeted = false;
              }
              
              // Clipboard holding animation
              const clipboard = npc.children.find(child => child.geometry && child.geometry.parameters.width === 0.6 && child.geometry.parameters.height === 0.8);
              if (clipboard) {
                clipboard.rotation.x = -Math.PI / 6 + Math.sin(time * 2) * 0.1;
              }

            } else if (data.type === 'greeter') {
              // Greeters wave at entrance
              const wavingArm = npc.children.find(child => child.rotation.z !== 0 && Math.abs(child.rotation.z) > Math.PI / 4);
              if (wavingArm) {
                wavingArm.rotation.z = (wavingArm.position.x < 0 ? 1 : -1) * (Math.PI / 3 + Math.sin(time * data.waveSpeed) * 0.3);
              }
              
              // Check for nearby customers to greet
              const distance = npc.position.distanceTo(this.camera.position);
              if (distance < 10 && time - data.lastGreetTime > data.greetCooldown / 1000) {
                console.log(data.dialogue[Math.floor(Math.random() * data.dialogue.length)]);
                data.lastGreetTime = time;
              }
              
              // Slight swaying motion
              npc.rotation.y = Math.PI + Math.sin(time * 0.5) * 0.1;

            } else if (data.type === 'stocker') {
              // Stockers follow their path
              if (!data.isResting) {
                const target = data.path[data.pathIndex];
                const direction = new THREE.Vector3()
                  .subVectors(target, npc.position)
                  .normalize();
                
                const distanceToTarget = npc.position.distanceTo(target);
                
                if (distanceToTarget > 1) {
                  // Move towards target
                  npc.position.add(direction.multiplyScalar(data.speed));
                  
                  // Face direction of movement
                  npc.lookAt(target.x, npc.position.y, target.z);
                  
                  // Walking animation
                  npc.position.y = Math.abs(Math.sin(time * 8)) * 0.05;
                } else {
                  // Reached waypoint
                  data.pathIndex = (data.pathIndex + 1) % data.path.length;
                  
                  // Occasionally rest
                  if (Math.random() > 0.8) {
                    data.isResting = true;
                    data.restTime = 0;
                  }
                }
              } else {
                // Resting
                data.restTime += delta;
                if (data.restTime > data.maxRestTime) {
                  data.isResting = false;
                }
              }
            }
          });
        }

        updateSlidingDoors() {
          if (!this.leftDoor || !this.rightDoor) return;

          // Check if camera is in sensor zone
          const cameraInZone = this.doorSensorZone.containsPoint(this.camera.position);
          
          // Also check if any customer NPCs are near
          let npcNearDoor = false;
          this.npcs.forEach(npc => {
            if (npc.userData.type === 'customer' || npc.userData.type === 'stocker') {
              if (this.doorSensorZone.containsPoint(npc.position)) {
                npcNearDoor = true;
              }
            }
          });

          if ((cameraInZone || npcNearDoor) && !this.doorsOpen) {
            // Open doors
            this.doorsOpen = true;
          } else if (!cameraInZone && !npcNearDoor && this.doorsOpen) {
            // Close doors
            this.doorsOpen = false;
          }

          // Animate door positions
          const targetLeftX = this.doorsOpen ? -19 : -9.5;
          const targetRightX = this.doorsOpen ? 19 : 9.5;
          
          this.leftDoor.position.x += (targetLeftX - this.leftDoor.position.x) * 0.1;
          this.rightDoor.position.x += (targetRightX - this.rightDoor.position.x) * 0.1;
        }

        createEffects() {
          // Minimal particle effects for performance
          this.effects = [];

          // Dust particles floating in the air
          const particleGeometry = new THREE.BufferGeometry();
          const particleCount = 100;
          const positions = new Float32Array(particleCount * 3);

          for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 180;
            positions[i + 1] = Math.random() * 10 + 2;
            positions[i + 2] = (Math.random() - 0.5) * 180;
          }

          particleGeometry.setAttribute(
            "position",
            new THREE.BufferAttribute(positions, 3)
          );

          const particleMaterial = new THREE.PointsMaterial({
            size: 0.1,
            color: 0xcccccc,
            transparent: true,
            opacity: 0.5,
          });

          const particles = new THREE.Points(particleGeometry, particleMaterial);
          particles.update = function(time) {
            this.rotation.y = time * 0.05;
            
            // Make particles float up and down
            const positions = this.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
              positions[i] = (Math.sin(time + i) * 0.5 + 1) * 5 + 2;
            }
            this.geometry.attributes.position.needsUpdate = true;
          };
          this.effects.push(particles);
          this.scene.add(particles);

          // Fluorescent light flicker effect
          this.lightFlickerEffect = {
            lights: [],
            update: function(time) {
              this.lights.forEach((light, i) => {
                // Occasional flicker
                if (Math.random() > 0.995) {
                  light.intensity = light.userData.baseIntensity * 0.3;
                } else {
                  light.intensity = light.userData.baseIntensity;
                }
              });
            }
          };

          // Collect fluorescent lights for flicker effect
          this.scene.traverse((child) => {
            if (child.isRectAreaLight) {
              child.userData.baseIntensity = child.intensity;
              this.lightFlickerEffect.lights.push(child);
            }
          });

          this.effects.push(this.lightFlickerEffect);
        }

        createPortals() {
          // Place portals in the back storage area
          const numPortals = Math.min(this.worlds.length, 8);

          // Create storage area backdrop
          const storageWallGeometry = new THREE.BoxGeometry(60, 12, 2);
          const storageWallMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.8,
            metalness: 0.2,
          });
          const storageWall = new THREE.Mesh(storageWallGeometry, storageWallMaterial);
          storageWall.position.set(0, 6, -95);
          storageWall.castShadow = true;
          storageWall.receiveShadow = true;
          this.scene.add(storageWall);

          // "EMPLOYEES ONLY" sign
          const employeeSignGeometry = new THREE.BoxGeometry(15, 2, 0.2);
          const employeeSignMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            roughness: 0.6,
            metalness: 0,
            emissive: 0xffff00,
            emissiveIntensity: 0.2,
          });
          const employeeSign = new THREE.Mesh(employeeSignGeometry, employeeSignMaterial);
          employeeSign.position.set(0, 10, -94.8);
          this.scene.add(employeeSign);

          // Black text on yellow sign
          const employeeTextMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000,
            roughness: 0.8,
            metalness: 0,
          });
          const employeeText = new THREE.BoxGeometry(10, 1, 0.1);
          const textMesh = new THREE.Mesh(employeeText, employeeTextMaterial);
          textMesh.position.set(0, 10, -94.6);
          this.scene.add(textMesh);

          for (let i = 0; i < numPortals; i++) {
            const world = this.worlds[i];
            const portalX = -25 + (i % 4) * 17;
            const portalZ = -88 + Math.floor(i / 4) * 10;

            const portalGroup = new THREE.Group();

            // Industrial style portal frame
            const frameGeometry = new THREE.TorusGeometry(3, 0.3, 16, 32);
            const frameMaterial = new THREE.MeshStandardMaterial({
              color: 0x444444,
              emissive: 0x1a4d2e,
              emissiveIntensity: 0.3,
              metalness: 0.8,
              roughness: 0.2,
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);

            // Portal surface
            const portalGeometry = new THREE.CircleGeometry(2.7, 64);
            const portalMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(CURRENT_WORLD.portalColor1) },
                color2: { value: new THREE.Color(CURRENT_WORLD.portalColor2) },
                distortion: { value: 0 },
              },
              vertexShader: portalVertexShader,
              fragmentShader: portalFragmentShader,
              transparent: true,
              side: THREE.DoubleSide,
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.z = 0.1;

            portalGroup.add(frame);
            portalGroup.add(portal);

            // Portal particles
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);

            for (let j = 0; j < particleCount; j++) {
              const angle = (j / particleCount) * Math.PI * 2;
              const radius = 3.5 + Math.random() * 0.5;
              particlePositions[j * 3] = Math.cos(angle) * radius;
              particlePositions[j * 3 + 1] = Math.sin(angle) * radius;
              particlePositions[j * 3 + 2] = (Math.random() - 0.5) * 0.5;
            }

            particleGeometry.setAttribute(
              "position",
              new THREE.BufferAttribute(particlePositions, 3)
            );

            const particleMaterial = new THREE.PointsMaterial({
              color: 0xffffff,
              size: 0.1,
              transparent: true,
              opacity: 0.8,
              blending: THREE.AdditiveBlending,
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            portalGroup.add(particles);
            portalGroup.userData.particles = particles;

            portalGroup.position.set(portalX, 3, portalZ);

            // Portal label
            const labelGeometry = new THREE.BoxGeometry(4, 0.8, 0.2);
            const labelMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a4d2e,
              roughness: 0.6,
              metalness: 0.1,
            });
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(portalX, 6.5, portalZ);
            this.scene.add(label);

            const light = new THREE.PointLight(0x1a4d2e, 0.8, 10);
            light.position.copy(portalGroup.position);
            this.scene.add(light);

            portal.userData = {
              world: world,
              material: portalMaterial,
              light: light,
              url: world.url || world.raw_url,
              name: world.name,
              description: world.description || `Enter the ${world.name} world`,
              particles: portalGroup.userData.particles,
            };

            this.portals.push(portal);
            this.scene.add(portalGroup);

            // Caution stripes on floor
            const cautionGeometry = new THREE.BoxGeometry(6, 0.02, 6);
            const cautionMaterial = new THREE.MeshStandardMaterial({
              color: 0xffff00,
              roughness: 0.8,
              metalness: 0,
            });
            const cautionArea = new THREE.Mesh(cautionGeometry, cautionMaterial);
            cautionArea.position.set(portalX, 0.01, portalZ);
            cautionArea.receiveShadow = true;
            this.scene.add(cautionArea);

            // Black stripes
            for (let j = 0; j < 3; j++) {
              const stripeGeometry = new THREE.BoxGeometry(0.5, 0.03, 6);
              const stripeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.9,
                metalness: 0,
              });
              const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
              stripe.position.set(portalX - 2 + j * 2, 0.02, portalZ);
              this.scene.add(stripe);
            }
          }
        }

        buildInheritanceParams() {
          const params = new URLSearchParams();

          params.set(
            "from",
            window.location.pathname.split("/").pop() ||
              "nebraska_furniture_mart_90s.html"
          );
          params.set("fromName", CURRENT_WORLD.name);
          params.set("moveSpeed", this.moveSpeed.toString());
          params.set("lookSpeed", this.lookSpeed.toString());
          params.set(
            "ambientColor",
            CURRENT_WORLD.ambientColor.toString(16).padStart(6, "0")
          );
          params.set(
            "fogColor",
            CURRENT_WORLD.fogColor.toString(16).padStart(6, "0")
          );
          params.set(
            "portalColor1",
            CURRENT_WORLD.portalColor1.toString(16).padStart(6, "0")
          );
          params.set(
            "portalColor2",
            CURRENT_WORLD.portalColor2.toString(16).padStart(6, "0")
          );
          params.set("particleCount", CURRENT_WORLD.particleCount.toString());
          params.set("cameraHeight", this.camera.position.y.toString());
          params.set("fogNear", CURRENT_WORLD.fogNear.toString());
          params.set("fogFar", CURRENT_WORLD.fogFar.toString());

          return params.toString();
        }

        setupEventListeners() {
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });

          if (this.isMobile) {
            this.setupMobileControls();
          } else {
            this.setupDesktopControls();
          }
        }

        setupDesktopControls() {
          window.addEventListener("keydown", (e) => {
            const key = e.key.toLowerCase();
            if (key in this.keys) {
              this.keys[key] = true;
            }
            if (e.key === " ") {
              this.keys[" "] = true;
              e.preventDefault();
            }
          });

          window.addEventListener("keyup", (e) => {
            const key = e.key.toLowerCase();
            if (key in this.keys) {
              this.keys[key] = false;
            }
            if (e.key === " ") {
              this.keys[" "] = false;
            }
          });

          this.renderer.domElement.addEventListener("click", (e) => {
            if (!this.isPointerLocked) {
              this.renderer.domElement.requestPointerLock();
            } else {
              this.raycaster.setFromCamera(
                new THREE.Vector2(0, 0),
                this.camera
              );
              const intersects = this.raycaster.intersectObjects(this.portals);

              if (intersects.length > 0) {
                const portal = intersects[0].object;
                if (portal.userData.url) {
                  this.enterWorld(portal.userData.url);
                }
              }
            }
          });

          document.addEventListener("pointerlockchange", () => {
            this.isPointerLocked =
              document.pointerLockElement === this.renderer.domElement;
          });

          document.addEventListener("mousemove", (e) => {
            if (this.isPointerLocked) {
              this.rotation.y -= e.movementX * this.lookSpeed;
              this.rotation.x -= e.movementY * this.lookSpeed;
              this.rotation.x = Math.max(
                -Math.PI / 2,
                Math.min(Math.PI / 2, this.rotation.x)
              );
            }
          });
        }

        setupMobileControls() {
          const lookArea = document.getElementById("look-area");

          lookArea.addEventListener(
            "touchstart",
            (e) => {
              const touch = e.touches[0];
              const rect = this.renderer.domElement.getBoundingClientRect();
              const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
              const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

              this.raycaster.setFromCamera(
                new THREE.Vector2(x, y),
                this.camera
              );
              const intersects = this.raycaster.intersectObjects(this.portals);

              if (intersects.length > 0) {
                const portal = intersects[0].object;
                if (portal.userData.url) {
                  e.preventDefault();
                  this.enterWorld(portal.userData.url);
                  return;
                }
              }

              this.lookTouch = {
                id: touch.identifier,
                startX: touch.clientX,
                startY: touch.clientY,
                currentX: touch.clientX,
                currentY: touch.clientY,
              };
            },
            { passive: true }
          );

          lookArea.addEventListener(
            "touchmove",
            (e) => {
              if (!this.lookTouch) return;

              for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                if (touch.identifier === this.lookTouch.id) {
                  const deltaX = touch.clientX - this.lookTouch.currentX;
                  const deltaY = touch.clientY - this.lookTouch.currentY;

                  this.rotation.y -= deltaX * this.lookSpeed * 2;
                  this.rotation.x -= deltaY * this.lookSpeed * 2;
                  this.rotation.x = Math.max(
                    -Math.PI / 2,
                    Math.min(Math.PI / 2, this.rotation.x)
                  );

                  this.lookTouch.currentX = touch.clientX;
                  this.lookTouch.currentY = touch.clientY;

                  e.preventDefault();
                  break;
                }
              }
            },
            { passive: false }
          );

          lookArea.addEventListener(
            "touchend",
            (e) => {
              for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                  this.lookTouch = null;
                  break;
                }
              }
            },
            { passive: true }
          );

          const joystick = document.getElementById("movement-joystick");
          const handle = document.getElementById("movement-handle");

          joystick.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              e.stopPropagation();

              const touch = e.touches[0];
              this.joystickTouch = {
                id: touch.identifier,
              };

              this.joystickActive = true;
              this.updateJoystick(touch, joystick, handle);
            },
            { passive: false }
          );

          joystick.addEventListener(
            "touchmove",
            (e) => {
              if (!this.joystickActive || !this.joystickTouch) return;

              e.preventDefault();
              e.stopPropagation();

              for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                if (touch.identifier === this.joystickTouch.id) {
                  this.updateJoystick(touch, joystick, handle);
                  break;
                }
              }
            },
            { passive: false }
          );

          joystick.addEventListener(
            "touchend",
            (e) => {
              for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (
                  this.joystickTouch &&
                  touch.identifier === this.joystickTouch.id
                ) {
                  this.joystickActive = false;
                  this.joystickTouch = null;
                  this.joystickVector.set(0, 0);
                  handle.style.transform = "translate(-50%, -50%)";

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }
              }
            },
            { passive: false }
          );

          window.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            return false;
          });
        }

        updateJoystick(touch, joystick, handle) {
          const rect = joystick.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          let deltaX = touch.clientX - centerX;
          let deltaY = touch.clientY - centerY;

          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const maxDistance = rect.width / 2 - 25;

          if (distance > maxDistance) {
            deltaX = (deltaX / distance) * maxDistance;
            deltaY = (deltaY / distance) * maxDistance;
          }

          handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

          this.joystickVector.x = deltaX / maxDistance;
          this.joystickVector.y = -deltaY / maxDistance;
        }

        updateMovement() {
          const forward = new THREE.Vector3();
          const right = new THREE.Vector3();

          this.camera.getWorldDirection(forward);
          forward.y = 0;
          forward.normalize();

          right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

          // Apply damping
          if (CURRENT_WORLD.enablePhysics) {
            this.velocity.x *= 0.9;
            this.velocity.z *= 0.9;
          }

          if (this.isMobile) {
            if (this.joystickActive) {
              const moveForward = forward.multiplyScalar(
                this.joystickVector.y * this.moveSpeed
              );
              const moveRight = right.multiplyScalar(
                this.joystickVector.x * this.moveSpeed
              );

              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(moveForward);
                this.velocity.add(moveRight);
              } else {
                this.camera.position.add(moveForward);
                this.camera.position.add(moveRight);
              }
            }
          } else {
            if (this.keys.w) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(forward.multiplyScalar(this.moveSpeed));
              } else {
                this.camera.position.add(
                  forward.multiplyScalar(this.moveSpeed)
                );
              }
            }
            if (this.keys.s) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(forward.multiplyScalar(-this.moveSpeed));
              } else {
                this.camera.position.add(
                  forward.multiplyScalar(-this.moveSpeed)
                );
              }
            }
            if (this.keys.a) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(right.multiplyScalar(-this.moveSpeed));
              } else {
                this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
              }
            }
            if (this.keys.d) {
              if (CURRENT_WORLD.enablePhysics) {
                this.velocity.add(right.multiplyScalar(this.moveSpeed));
              } else {
                this.camera.position.add(right.multiplyScalar(this.moveSpeed));
              }
            }

            // Vertical movement
            if (CURRENT_WORLD.enableFlying) {
              if (this.keys.q) this.camera.position.y -= this.moveSpeed;
              if (this.keys.e) this.camera.position.y += this.moveSpeed;
            }

            // Jumping
            if (CURRENT_WORLD.enablePhysics && this.keys[" "] && this.canJump) {
              this.velocity.y = CURRENT_WORLD.jumpForce;
              this.canJump = false;
            }
          }

          // Apply physics
          if (CURRENT_WORLD.enablePhysics) {
            this.velocity.y -= CURRENT_WORLD.gravity * 0.01;
            this.camera.position.add(this.velocity);

            // Ground collision
            if (this.camera.position.y < CURRENT_WORLD.cameraHeight) {
              this.camera.position.y = CURRENT_WORLD.cameraHeight;
              this.velocity.y = 0;
              this.canJump = true;
            }
          }

          // Keep camera within store bounds (extended for parking lot)
          this.camera.position.x = Math.max(-150, Math.min(150, this.camera.position.x));
          this.camera.position.z = Math.max(-95, Math.min(395, this.camera.position.z));

          this.camera.rotation.order = "YXZ";
          this.camera.rotation.y = this.rotation.y;
          this.camera.rotation.x = this.rotation.x;
        }

        updateHover() {
          this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
          const intersects = this.raycaster.intersectObjects(this.portals);

          if (intersects.length > 0) {
            const portal = intersects[0].object;

            if (portal !== this.hoveredPortal) {
              this.hoveredPortal = portal;

              this.tooltipTitle.textContent = portal.userData.name;
              this.tooltipDescription.textContent = portal.userData.description;
              this.tooltip.classList.add("visible");

              const vector = new THREE.Vector3();
              portal.getWorldPosition(vector);
              vector.project(this.camera);

              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

              this.tooltip.style.left = `${Math.min(
                x + 20,
                window.innerWidth - 320
              )}px`;
              this.tooltip.style.top = `${Math.min(
                y - 50,
                window.innerHeight - 200
              )}px`;
            }
          } else {
            if (this.hoveredPortal) {
              this.hoveredPortal = null;
              this.tooltip.classList.remove("visible");
            }
          }
        }

        async enterWorld(url) {
          try {
            document.getElementById("loading").style.display = "block";
            document.getElementById("loading").innerHTML =
              "Quantum tunneling...";

            // Transition effect
            const transitionDuration = 1500;
            const startTime = Date.now();

            const transitionEffect = setInterval(() => {
              const elapsed = Date.now() - startTime;
              const progress = elapsed / transitionDuration;

              if (progress >= 1) {
                clearInterval(transitionEffect);
                this.loadNewWorld(url);
              } else {
                this.renderer.domElement.style.filter = `hue-rotate(${
                  progress * 360
                }deg) blur(${progress * 10}px)`;
                this.renderer.domElement.style.opacity = 1 - progress * 0.5;
              }
            }, 16);
          } catch (error) {
            console.error("Error entering world:", error);
            document.getElementById("loading").innerHTML =
              "Portal malfunction. Please try again.";
            setTimeout(() => {
              document.getElementById("loading").style.display = "none";
            }, 3000);
          }
        }

        async loadNewWorld(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Failed to load world (${response.status})`);
            }

            let htmlContent = await response.text();

            const inheritanceParams = this.buildInheritanceParams();

            sessionStorage.setItem(
              "worldInheritanceParams",
              "?" + inheritanceParams
            );

            const inheritanceData = {
              params: inheritanceParams,
              timestamp: Date.now(),
            };
            localStorage.setItem(
              "worldTransition",
              JSON.stringify(inheritanceData)
            );

            const paramScript = `<script>
                        window.INJECTED_PARAMS = '?${inheritanceParams}';
                        sessionStorage.setItem('worldInheritanceParams', '?${inheritanceParams}');
                        console.log('Injected params:', window.INJECTED_PARAMS);
                    <\/script>`;

            htmlContent = htmlContent.replace("<body>", `<body>${paramScript}`);

            const blob = new Blob([htmlContent], { type: "text/html" });
            const blobUrl = URL.createObjectURL(blob);

            window.location.href = blobUrl;
          } catch (error) {
            console.error("Error loading world:", error);
            document.getElementById("loading").innerHTML =
              "Failed to establish connection.";
            this.renderer.domElement.style.filter = "none";
            this.renderer.domElement.style.opacity = "1";
            setTimeout(() => {
              document.getElementById("loading").style.display = "none";
            }, 3000);
          }
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          const time = this.clock.getElapsedTime();
          const delta = this.clock.getDelta();

          this.updateMovement();
          this.updateHover();
          
          // Update NPCs
          this.updateNPCs(time, delta);
          
          // Check for door sensor
          this.updateSlidingDoors();

          // Animate portals
          this.portals.forEach((portal, index) => {
            if (portal.userData.material) {
              portal.userData.material.uniforms.time.value = time;

              const intensity = 0.5 + Math.sin(time * 2 + index) * 0.3;
              portal.userData.light.intensity = intensity;

              if (portal.userData.particles) {
                portal.userData.particles.rotation.z = time * 0.5;
              }
            }

            portal.rotation.z = Math.sin(time * 0.5 + index) * 0.1;
          });

          // Animate particles
          if (this.particles) {
            this.particles.rotation.y = time * 0.05;

            if (this.particleSystem) {
              this.particleSystem.update(delta);
            }
          }

          // Animate structures
          if (this.structures) {
            this.structures.forEach((structure, i) => {
              if (structure.userData.animation === "rotate") {
                structure.rotation.y =
                  time * (structure.userData.animationSpeed || 1);
              } else if (structure.userData.animation === "float") {
                structure.position.y =
                  structure.userData.baseY +
                  Math.sin(time * (structure.userData.animationSpeed || 1)) * 2;
              } else if (structure.userData.animation === "pulse") {
                const scale =
                  1 +
                  Math.sin(
                    time * (structure.userData.animationSpeed || 1) * 2
                  ) *
                    0.1;
                structure.scale.setScalar(scale);
              }
            });
          }

          // Animate effects
          if (this.effects) {
            this.effects.forEach((effect, i) => {
              if (effect.update) {
                effect.update(time, delta);
              }
            });
          }

          // Animate lights
          this.scene.traverse((child) => {
            if (
              child.isLight &&
              child.type === "PointLight" &&
              child.userData.animationType
            ) {
              const time = this.clock.getElapsedTime();
              const animType = child.userData.animationType;

              if (animType === "pulse") {
                child.intensity =
                  child.userData.baseIntensity *
                  (0.5 + Math.sin(time * 2) * 0.5);
              } else if (animType === "orbit") {
                const angle = time * 0.5;
                const radius = 10;
                child.position.x =
                  child.userData.basePosition.x + Math.cos(angle) * radius;
                child.position.z =
                  child.userData.basePosition.z + Math.sin(angle) * radius;
              } else if (animType === "flicker") {
                child.intensity =
                  child.userData.baseIntensity * (0.8 + Math.random() * 0.2);
              }
            }
          });

          this.renderer.render(this.scene, this.camera);
        }
      }

      // Initialize world
      window.addEventListener("DOMContentLoaded", () => {
        const navigator = new WorldNavigator();
        navigator.init();
      });

      // Prevent pull-to-refresh on mobile
      let lastY = 0;
      window.addEventListener(
        "touchstart",
        (e) => {
          lastY = e.touches[0].clientY;
        },
        { passive: true }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          const y = e.touches[0].clientY;
          const scrollingUp = y > lastY;
          const atTop = window.pageYOffset === 0;

          if (scrollingUp && atTop) {
            e.preventDefault();
          }
          lastY = y;
        },
        { passive: false }
      );
    </script>
  </body>
</html>