<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Companion - Interactive Learning Loop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Split Screen Layout */
        .split-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            pointer-events: none;
            z-index: 100;
        }

        .split-panel {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .split-panel:last-child {
            border-right: none;
        }

        .panel-title {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-weight: bold;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .panel-title.user {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.5);
            color: #60a5fa;
        }

        .panel-title.ai {
            background: rgba(131, 56, 236, 0.2);
            border-color: rgba(131, 56, 236, 0.5);
            color: #a78bfa;
        }

        .panel-title.agents {
            background: rgba(255, 106, 0, 0.2);
            border-color: rgba(255, 106, 0, 0.5);
            color: #fb923c;
        }

        /* User Avatar Display */
        .user-avatar {
            position: fixed;
            top: 80px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
            animation: userPulse 2s infinite;
            z-index: 101;
        }

        @keyframes userPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(59, 130, 246, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(59, 130, 246, 0.7); }
        }

        .user-status {
            position: fixed;
            top: 170px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            z-index: 101;
        }

        /* Command Preview */
        .command-preview {
            position: fixed;
            bottom: 100px;
            left: 20px;
            right: 20px;
            max-width: 300px;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid rgba(59, 130, 246, 0.5);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 101;
            pointer-events: auto;
        }

        .command-preview.active {
            display: block;
            animation: slideInUp 0.3s ease;
        }

        @keyframes slideInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .command-preview h4 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .command-preview p {
            font-size: 13px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Simulated Commands Queue */
        .commands-queue {
            position: fixed;
            top: 220px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 15px;
            padding: 15px;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            z-index: 101;
            display: none;
        }

        .commands-queue.active {
            display: block;
        }

        .commands-queue h4 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .command-item {
            background: rgba(59, 130, 246, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .command-item:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: translateX(5px);
        }

        .command-item.active {
            background: rgba(59, 130, 246, 0.3);
            border-left: 3px solid #3b82f6;
        }

        /* Interaction Flow Visualization */
        .interaction-flow {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 102;
        }

        .flow-arrow {
            position: absolute;
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #3b82f6, transparent);
            opacity: 0;
            animation: flowPulse 2s infinite;
        }

        .flow-arrow.user-to-ai {
            top: 0;
            left: -300px;
            transform: rotate(-10deg);
        }

        .flow-arrow.ai-to-agents {
            top: 0;
            right: -300px;
            transform: rotate(10deg);
            background: linear-gradient(90deg, transparent, #8338ec, transparent);
        }

        .flow-arrow.active {
            opacity: 1;
        }

        @keyframes flowPulse {
            0% { transform: scaleX(0); opacity: 0; }
            50% { transform: scaleX(1); opacity: 1; }
            100% { transform: scaleX(0); opacity: 0; }
        }

        /* Enhanced AI Chat Interface */
        .ai-chat-interface {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 500px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .ai-chat-interface.active {
            display: flex;
        }

        /* Message styling with role indicators */
        .ai-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 85%;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
        }

        .ai-message.user {
            background: rgba(59, 130, 246, 0.2);
            margin-left: auto;
            text-align: right;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .ai-message.simulated-user {
            background: rgba(59, 130, 246, 0.3);
            margin-right: auto;
            border: 1px solid rgba(59, 130, 246, 0.5);
        }

        .ai-message.simulated-user::before {
            content: "ü§ñ Simulated User";
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 11px;
            color: #60a5fa;
            font-weight: bold;
        }

        /* Scenario Controls */
        .scenario-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 1004;
            pointer-events: auto;
        }

        .scenario-controls h3 {
            color: #06ffa5;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .scenario-button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin: 8px 0;
            background: rgba(6, 255, 165, 0.1);
            border: 1px solid rgba(6, 255, 165, 0.3);
            border-radius: 10px;
            color: #06ffa5;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            text-align: left;
        }

        .scenario-button:hover {
            background: rgba(6, 255, 165, 0.2);
            transform: translateX(5px);
        }

        .scenario-button.active {
            background: rgba(6, 255, 165, 0.3);
            border-color: #06ffa5;
        }

        /* Speed Control */
        .speed-control {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .speed-control label {
            display: block;
            color: #06ffa5;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .speed-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #06ffa5;
            cursor: pointer;
        }

        .speed-value {
            text-align: center;
            margin-top: 5px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* All existing styles from the original file remain... */
        /* (Learning Mode Indicator, AI State Display, Task Panel, etc.) */
        
        /* Additional styles for user simulation */
        .simulation-status {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1005;
            border: 1px solid rgba(6, 255, 165, 0.5);
        }

        .simulation-status.active {
            display: flex;
        }

        .simulation-status span {
            color: #06ffa5;
            font-size: 14px;
            font-weight: bold;
        }

        /* Rest of the original styles continue here... */
        .learning-mode-indicator {
            position: fixed;
            top: 20px;
            right: 350px;
            background: rgba(0, 255, 0, 0.2);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid rgba(0, 255, 0, 0.5);
            display: none;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
        }

        .ai-state-display {
            position: fixed;
            top: 130px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            display: none;
            max-width: 300px;
        }

        .task-panel {
            position: fixed;
            bottom: 100px;
            right: 370px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            z-index: 1002;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.3);
            display: none;
            pointer-events: auto;
        }

        /* Continue with all other original styles... */
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <!-- Split Screen Overlay -->
    <div class="split-screen">
        <div class="split-panel">
            <div class="panel-title user">User Environment</div>
        </div>
        <div class="split-panel">
            <div class="panel-title ai">AI Companion</div>
        </div>
        <div class="split-panel">
            <div class="panel-title agents">Agent Workspace</div>
        </div>
    </div>

    <!-- User Avatar -->
    <div class="user-avatar">üë§</div>
    <div class="user-status" id="user-status">Idle</div>

    <!-- Commands Queue -->
    <div class="commands-queue" id="commands-queue">
        <h4>üìã Command Queue</h4>
        <div id="command-list"></div>
    </div>

    <!-- Command Preview -->
    <div class="command-preview" id="command-preview">
        <h4>Next Command</h4>
        <p id="command-text"></p>
    </div>

    <!-- Scenario Controls -->
    <div class="scenario-controls">
        <h3>üé¨ Simulation Scenarios</h3>
        <button class="scenario-button" onclick="simulationManager.startScenario('business-analysis')">
            üìä Business Analysis Workflow
        </button>
        <button class="scenario-button" onclick="simulationManager.startScenario('code-review')">
            üíª Code Review Session
        </button>
        <button class="scenario-button" onclick="simulationManager.startScenario('research-task')">
            üîç Research Task
        </button>
        <button class="scenario-button" onclick="simulationManager.startScenario('creative-writing')">
            ‚úçÔ∏è Creative Writing
        </button>
        <button class="scenario-button" onclick="simulationManager.pauseSimulation()">
            ‚è∏Ô∏è Pause Simulation
        </button>
        
        <div class="speed-control">
            <label for="speed-slider">Simulation Speed</label>
            <input type="range" id="speed-slider" class="speed-slider" min="0.5" max="3" step="0.5" value="1">
            <div class="speed-value" id="speed-value">1x</div>
        </div>
    </div>

    <!-- Simulation Status -->
    <div class="simulation-status" id="simulation-status">
        <span>üé≠ Simulation Running:</span>
        <span id="scenario-name">Business Analysis</span>
    </div>

    <!-- Interaction Flow Visualization -->
    <div class="interaction-flow">
        <div class="flow-arrow user-to-ai" id="user-to-ai-flow"></div>
        <div class="flow-arrow ai-to-agents" id="ai-to-agents-flow"></div>
    </div>

    <!-- All original UI elements continue here... -->
    <div class="learning-mode-indicator" id="learning-mode-indicator">
        <span id="learning-mode-text">AI is learning from you</span>
    </div>

    <div class="ai-state-display" id="ai-state-display">
        <div class="ai-state">
            <div class="ai-state-icon" id="state-icon"></div>
            <span id="state-text">Idle</span>
        </div>
    </div>

    <!-- AI Chat Interface (centered) -->
    <div class="ai-chat-interface active" id="ai-chat-interface">
        <div class="ai-chat-header">
            <div class="ai-chat-title">AI Companion</div>
            <div class="tts-controls">
                <button class="tts-button" id="tts-toggle" title="Toggle Text-to-Speech">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                    </svg>
                </button>
            </div>
            <button class="close-btn" onclick="document.getElementById('ai-chat-interface').classList.remove('active')">√ó</button>
        </div>
        
        <select class="voice-select" id="voice-select">
            <option value="en-US-JennyNeural">Jenny (Female)</option>
            <option value="en-US-GuyNeural">Guy (Male)</option>
            <option value="en-US-AriaNeural">Aria (Female)</option>
            <option value="en-US-DavisNeural">Davis (Male)</option>
        </select>

        <div class="ai-chat-messages" id="ai-chat-messages"></div>
        <div class="loading hidden" id="loading">Processing...</div>
        
        <div class="ai-chat-input-container">
            <input type="text" class="ai-chat-input" id="ai-chat-input" placeholder="Type a message..." 
                   onkeypress="if(event.key==='Enter') aiManager.sendMessage()">
            <button class="ai-chat-send" onclick="aiManager.sendMessage()">Send</button>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Azure Speech SDK for TTS -->
    <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>

    <script>
        // Simulation Manager for User Interactions
        class SimulationManager {
            constructor(aiManager, visualManager) {
                this.aiManager = aiManager;
                this.visualManager = visualManager;
                this.isRunning = false;
                this.currentScenario = null;
                this.commandQueue = [];
                this.currentCommandIndex = 0;
                this.simulationSpeed = 1;
                
                this.scenarios = {
                    'business-analysis': [
                        { delay: 2000, command: "Hello AI! I need help analyzing our Q4 sales data." },
                        { delay: 15000, command: "Can you check what our top performing products were?" },
                        { delay: 20000, command: "Compare this with last year's Q4 performance." },
                        { delay: 25000, command: "What insights can you provide about customer trends?" },
                        { delay: 30000, command: "Generate a summary report of these findings." }
                    ],
                    'code-review': [
                        { delay: 2000, command: "I need you to review this Python function for optimization." },
                        { delay: 12000, command: "def calculate_fibonacci(n):\n    if n <= 1:\n        return n\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)" },
                        { delay: 20000, command: "Can you suggest performance improvements?" },
                        { delay: 25000, command: "Show me the optimized version with memoization." },
                        { delay: 30000, command: "Explain the time complexity difference." }
                    ],
                    'research-task': [
                        { delay: 2000, command: "Research the latest trends in renewable energy." },
                        { delay: 15000, command: "Focus on solar panel efficiency improvements in 2024." },
                        { delay: 25000, command: "What are the top companies innovating in this space?" },
                        { delay: 35000, command: "Compare costs with traditional energy sources." },
                        { delay: 40000, command: "Summarize the key findings in bullet points." }
                    ],
                    'creative-writing': [
                        { delay: 2000, command: "Help me write a short story about AI and humans working together." },
                        { delay: 12000, command: "Set it in the year 2050 in a space colony." },
                        { delay: 20000, command: "The main character should be an AI researcher." },
                        { delay: 28000, command: "Add some conflict about trust between humans and AI." },
                        { delay: 35000, command: "Give it a hopeful ending." }
                    ]
                };
                
                this.userStates = [
                    "Thinking...",
                    "Typing...",
                    "Reading response...",
                    "Analyzing results...",
                    "Formulating question..."
                ];
                
                this.setupEventListeners();
                this.createUserVisualization();
            }

            setupEventListeners() {
                const speedSlider = document.getElementById('speed-slider');
                const speedValue = document.getElementById('speed-value');
                
                speedSlider.addEventListener('input', (e) => {
                    this.simulationSpeed = parseFloat(e.target.value);
                    speedValue.textContent = `${this.simulationSpeed}x`;
                });
            }

            createUserVisualization() {
                // Create a 3D representation of the user in the left panel
                const userGroup = new THREE.Group();
                
                // User avatar (simple character)
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3b82f6,
                    metalness: 0.3,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xfdbcb4,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                userGroup.add(body);
                userGroup.add(head);
                
                // Position in left third of screen
                userGroup.position.set(-8, 0, 0);
                scene.add(userGroup);
                
                this.userAvatar = userGroup;
                
                // Add typing animation capability
                this.createTypingAnimation();
            }

            createTypingAnimation() {
                // Create hands/typing indicators
                const handGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
                const handMaterial = new THREE.MeshStandardMaterial({ color: 0xfdbcb4 });
                
                this.leftHand = new THREE.Mesh(handGeometry, handMaterial);
                this.rightHand = new THREE.Mesh(handGeometry, handMaterial);
                
                this.leftHand.position.set(-0.3, 0.5, 0.5);
                this.rightHand.position.set(0.3, 0.5, 0.5);
                
                this.userAvatar.add(this.leftHand);
                this.userAvatar.add(this.rightHand);
            }

            animateTyping(isTyping) {
                if (!this.leftHand || !this.rightHand) return;
                
                const animateHands = () => {
                    if (!isTyping) {
                        this.leftHand.position.y = 0.5;
                        this.rightHand.position.y = 0.5;
                        return;
                    }
                    
                    const time = Date.now() * 0.005;
                    this.leftHand.position.y = 0.5 + Math.sin(time) * 0.05;
                    this.rightHand.position.y = 0.5 + Math.cos(time) * 0.05;
                    
                    if (isTyping) {
                        requestAnimationFrame(animateHands);
                    }
                };
                
                animateHands();
            }

            startScenario(scenarioName) {
                if (!this.scenarios[scenarioName]) return;
                
                // Reset state
                this.stopSimulation();
                this.currentScenario = scenarioName;
                this.commandQueue = [...this.scenarios[scenarioName]];
                this.currentCommandIndex = 0;
                this.isRunning = true;
                
                // Update UI
                document.getElementById('simulation-status').classList.add('active');
                document.getElementById('scenario-name').textContent = this.formatScenarioName(scenarioName);
                document.getElementById('commands-queue').classList.add('active');
                
                // Highlight active button
                document.querySelectorAll('.scenario-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                // Show command queue
                this.updateCommandQueue();
                
                // Start first command
                this.executeNextCommand();
                
                // Show initial user state
                this.updateUserStatus('Ready to interact');
            }

            formatScenarioName(name) {
                return name.split('-').map(word => 
                    word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
            }

            updateCommandQueue() {
                const commandList = document.getElementById('command-list');
                commandList.innerHTML = '';
                
                this.commandQueue.forEach((cmd, index) => {
                    const cmdEl = document.createElement('div');
                    cmdEl.className = 'command-item';
                    if (index === this.currentCommandIndex) {
                        cmdEl.classList.add('active');
                    }
                    cmdEl.textContent = cmd.command.substring(0, 50) + '...';
                    commandList.appendChild(cmdEl);
                });
            }

            executeNextCommand() {
                if (!this.isRunning || this.currentCommandIndex >= this.commandQueue.length) {
                    this.completeScenario();
                    return;
                }
                
                const command = this.commandQueue[this.currentCommandIndex];
                
                // Show command preview
                this.showCommandPreview(command.command);
                
                // Update user status
                this.updateUserStatus('Thinking...');
                
                // Simulate typing delay
                setTimeout(() => {
                    this.updateUserStatus('Typing...');
                    this.animateTyping(true);
                    
                    // Show typing animation
                    setTimeout(() => {
                        this.sendSimulatedCommand(command.command);
                        this.animateTyping(false);
                        this.currentCommandIndex++;
                        this.updateCommandQueue();
                        
                        // Schedule next command
                        if (this.currentCommandIndex < this.commandQueue.length) {
                            const nextDelay = this.commandQueue[this.currentCommandIndex].delay / this.simulationSpeed;
                            setTimeout(() => this.executeNextCommand(), nextDelay);
                        }
                    }, 2000 / this.simulationSpeed);
                }, 1000 / this.simulationSpeed);
            }

            showCommandPreview(command) {
                const preview = document.getElementById('command-preview');
                const commandText = document.getElementById('command-text');
                
                commandText.textContent = command;
                preview.classList.add('active');
                
                // Hide after a few seconds
                setTimeout(() => {
                    preview.classList.remove('active');
                }, 3000 / this.simulationSpeed);
            }

            sendSimulatedCommand(command) {
                // Update user status
                this.updateUserStatus('Waiting for response...');
                
                // Show flow animation
                this.showInteractionFlow('user-to-ai');
                
                // Add message to chat as simulated user
                const messageDiv = this.aiManager.addMessage(command, 'simulated-user');
                
                // Send to AI
                this.aiManager.processSimulatedMessage(command);
            }

            updateUserStatus(status) {
                document.getElementById('user-status').textContent = status;
                
                // Animate user avatar based on status
                if (this.userAvatar) {
                    const light = new THREE.PointLight(0x3b82f6, 2, 5);
                    light.position.copy(this.userAvatar.position);
                    light.position.y += 2;
                    
                    if (status.includes('Typing')) {
                        light.intensity = 3;
                    } else if (status.includes('Thinking')) {
                        light.intensity = 2;
                    } else {
                        light.intensity = 1;
                    }
                    
                    // Add temporary light effect
                    scene.add(light);
                    setTimeout(() => scene.remove(light), 1000);
                }
            }

            showInteractionFlow(type) {
                const flowEl = document.getElementById(`${type}-flow`);
                flowEl.classList.add('active');
                
                setTimeout(() => {
                    flowEl.classList.remove('active');
                }, 2000);
            }

            pauseSimulation() {
                this.isRunning = false;
                document.getElementById('simulation-status').classList.remove('active');
                this.updateUserStatus('Paused');
                event.target.textContent = '‚ñ∂Ô∏è Resume Simulation';
                event.target.onclick = () => this.resumeSimulation();
            }

            resumeSimulation() {
                if (!this.currentScenario) return;
                
                this.isRunning = true;
                document.getElementById('simulation-status').classList.add('active');
                this.executeNextCommand();
                event.target.textContent = '‚è∏Ô∏è Pause Simulation';
                event.target.onclick = () => this.pauseSimulation();
            }

            stopSimulation() {
                this.isRunning = false;
                this.currentScenario = null;
                this.commandQueue = [];
                this.currentCommandIndex = 0;
                
                document.getElementById('simulation-status').classList.remove('active');
                document.getElementById('commands-queue').classList.remove('active');
                document.getElementById('command-preview').classList.remove('active');
                
                this.updateUserStatus('Idle');
                this.animateTyping(false);
            }

            completeScenario() {
                this.updateUserStatus('Scenario complete');
                document.getElementById('simulation-status').classList.remove('active');
                
                setTimeout(() => {
                    this.stopSimulation();
                }, 3000);
            }
        }

        // Enhanced AI Manager with simulation support
        class AIManager {
            constructor(visualManager) {
                this.visualManager = visualManager;
                this.apiKey = null;
                this.endpoint = 'https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function';
                this.isActive = true; // Start active for simulation
                this.conversationHistory = [];
                this.learningMode = false;
                
                // TTS properties
                this.ttsEnabled = false;
                this.speechConfig = null;
                this.synthesizer = null;
                this.azureKey = 'd7drbPhJ5IlXpMnDL35jJFMJjW2L7ZIidcb1EqKRu52MrHWwvTksJQQJ99BDACHYHv6XJ3w3AAAAACOGFGu8';
                this.azureRegion = 'eastus2';
                this.selectedVoice = 'en-US-JennyNeural';
                
                // UI elements
                this.chatInterface = document.getElementById('ai-chat-interface');
                this.chatMessages = document.getElementById('ai-chat-messages');
                this.chatInput = document.getElementById('ai-chat-input');
                this.loadingIndicator = document.getElementById('loading');
                this.ttsButton = document.getElementById('tts-toggle');
                this.voiceSelect = document.getElementById('voice-select');
                
                // 3D companion
                this.companion = null;
                this.thinkingAnimation = null;
                
                this.setupEventListeners();
                this.setupTTS();
                this.createCompanion();
            }

            processSimulatedMessage(message) {
                // Store in conversation history
                this.conversationHistory.push({ role: 'user', content: message });
                
                // Show AI thinking
                this.setAIState('thinking', 'Processing request...');
                
                // Simulate API call delay
                setTimeout(() => {
                    // Generate a simulated response based on the command
                    const response = this.generateSimulatedResponse(message);
                    
                    this.addMessage(response, 'ai');
                    this.conversationHistory.push({ role: 'assistant', content: response });
                    
                    // Show agent activity if relevant
                    if (message.toLowerCase().includes('analyze') || 
                        message.toLowerCase().includes('check') ||
                        message.toLowerCase().includes('research')) {
                        
                        // Show flow to agents
                        simulationManager.showInteractionFlow('ai-to-agents');
                        
                        // Simulate agent calls
                        const agents = this.selectRelevantAgents(message);
                        agents.forEach((agent, index) => {
                            setTimeout(() => {
                                this.visualManager.showAgentCall(agent, false, `Processed: ${message.substring(0, 30)}...`);
                                this.addMessage(`Called ${agent} agent`, 'system');
                            }, 1000 * (index + 1));
                        });
                    }
                    
                    this.setAIState('idle', 'Ready');
                    
                    // Update user status
                    simulationManager.updateUserStatus('Reading response...');
                    
                }, 2000);
            }

            generateSimulatedResponse(message) {
                // Generate contextual responses based on the command
                const lowerMessage = message.toLowerCase();
                
                if (lowerMessage.includes('analyze') && lowerMessage.includes('sales')) {
                    return "I'll analyze the Q4 sales data for you. Based on the available information, I can see strong performance in the technology and healthcare sectors. Let me pull up the specific metrics...";
                } else if (lowerMessage.includes('top performing products')) {
                    return "The top performing products in Q4 were:\n1. Cloud Analytics Suite - 145% of target\n2. AI Integration Tools - 132% of target\n3. Security Framework Pro - 128% of target\n\nThese products showed significant growth compared to Q3.";
                } else if (lowerMessage.includes('compare') && lowerMessage.includes('last year')) {
                    return "Comparing with last year's Q4:\n- Overall revenue: +23% YoY\n- Product sales: +31% YoY\n- Service revenue: +18% YoY\n\nThe growth is primarily driven by enterprise adoption.";
                } else if (lowerMessage.includes('customer trends')) {
                    return "Key customer trends identified:\n- 65% increase in enterprise subscriptions\n- Average deal size up 40%\n- Customer retention at 94%\n- Strong demand for AI-powered features";
                } else if (lowerMessage.includes('fibonacci')) {
                    return "I see you have a recursive Fibonacci implementation. This has exponential time complexity O(2^n). Here's my analysis:\n\nCurrent issues:\n- Redundant calculations\n- Stack overflow risk for large n\n- Time complexity: O(2^n)";
                } else if (lowerMessage.includes('optimization') || lowerMessage.includes('improve')) {
                    return "Here's an optimized version using memoization:\n\n```python\ndef fibonacci_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)\n    return memo[n]\n```\n\nThis reduces complexity to O(n).";
                } else if (lowerMessage.includes('renewable energy')) {
                    return "I'll research the latest renewable energy trends for you. The sector is experiencing rapid innovation, particularly in solar panel efficiency and energy storage solutions.";
                } else if (lowerMessage.includes('short story')) {
                    return "I'll help you craft a compelling short story about AI-human collaboration in a 2050 space colony. Let's start with setting the scene:\n\n'The year is 2050. Dr. Sarah Chen gazes through the reinforced glass dome of Mars Colony Alpha, where humans and AI work in perfect harmony...'";
                } else {
                    return "I understand your request. Let me process this information and provide you with a comprehensive response. I'll utilize the appropriate tools and agents to ensure accuracy.";
                }
            }

            selectRelevantAgents(message) {
                const lowerMessage = message.toLowerCase();
                const agents = [];
                
                if (lowerMessage.includes('sales') || lowerMessage.includes('revenue')) {
                    agents.push('Dynamics365CRUD');
                }
                if (lowerMessage.includes('analyze') || lowerMessage.includes('trend')) {
                    agents.push('DataAnalysis');
                }
                if (lowerMessage.includes('email') || lowerMessage.includes('draft')) {
                    agents.push('EmailDrafting');
                }
                if (lowerMessage.includes('code') || lowerMessage.includes('function')) {
                    agents.push('CodeReview');
                }
                if (lowerMessage.includes('research') || lowerMessage.includes('wiki')) {
                    agents.push('WikipediaAgent');
                }
                if (lowerMessage.includes('news') || lowerMessage.includes('latest')) {
                    agents.push('HackerNewsAgent');
                }
                if (lowerMessage.includes('time') || lowerMessage.includes('schedule')) {
                    agents.push('LocalTimeAgent');
                }
                if (lowerMessage.includes('presentation') || lowerMessage.includes('powerpoint')) {
                    agents.push('PowerPoint');
                }
                
                // Default to ManageMemory if no specific agents selected
                if (agents.length === 0) {
                    agents.push('ManageMemory');
                }
                
                return agents;
            }

            // All other original AI Manager methods remain the same...
            setupEventListeners() {
                this.ttsButton.addEventListener('click', () => {
                    this.toggleTTS();
                });

                this.voiceSelect.addEventListener('change', (e) => {
                    this.selectedVoice = e.target.value;
                    if (this.speechConfig) {
                        this.speechConfig.speechSynthesisVoiceName = this.selectedVoice;
                    }
                });
            }

            setupTTS() {
                if (window.SpeechSDK) {
                    try {
                        this.speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                            this.azureKey,
                            this.azureRegion
                        );
                        this.speechConfig.speechSynthesisVoiceName = this.selectedVoice;
                        
                        const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();
                        this.synthesizer = new window.SpeechSDK.SpeechSynthesizer(
                            this.speechConfig,
                            audioConfig
                        );
                        
                        console.log('TTS initialized successfully');
                    } catch (error) {
                        console.error('Failed to initialize TTS:', error);
                    }
                }
            }

            toggleTTS() {
                this.ttsEnabled = !this.ttsEnabled;
                this.ttsButton.classList.toggle('active', this.ttsEnabled);
                
                if (this.ttsEnabled) {
                    this.addMessage('TTS enabled', 'system');
                    this.speakAction('Voice enabled');
                } else {
                    this.addMessage('TTS disabled', 'system');
                }
            }

            setAIState(state, text) {
                const stateDisplay = document.getElementById('ai-state-display');
                const stateIcon = document.getElementById('state-icon');
                const stateText = document.getElementById('state-text');
                
                stateDisplay.classList.add('active');
                stateIcon.className = `ai-state-icon ${state}`;
                stateText.textContent = text;
                
                // Update companion visual state
                if (this.companion) {
                    this.updateCompanionState(state);
                }
            }

            updateCompanionState(state) {
                if (!this.companion) return;
                
                // Clear existing thinking particles
                if (this.thinkingAnimation) {
                    this.companion.group.remove(this.thinkingAnimation);
                    this.thinkingAnimation = null;
                }
                
                switch(state) {
                    case 'thinking':
                        // Create thinking particles around head
                        this.createThinkingParticles();
                        this.companion.light.color = new THREE.Color(0xffeb3b);
                        break;
                    case 'processing':
                        this.companion.light.color = new THREE.Color(0x2196f3);
                        this.companion.light.intensity = 3;
                        break;
                    case 'learning':
                        this.companion.light.color = new THREE.Color(0x4caf50);
                        break;
                    case 'error':
                        this.companion.light.color = new THREE.Color(0xf44336);
                        break;
                    default:
                        this.companion.light.color = new THREE.Color(0x8338ec);
                        this.companion.light.intensity = 2;
                }
            }

            createThinkingParticles() {
                const particleCount = 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    const angle = (i / 3) * (Math.PI * 2 / particleCount);
                    positions[i] = Math.cos(angle) * 1.5;
                    positions[i + 1] = 3;
                    positions[i + 2] = Math.sin(angle) * 1.5;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0xffeb3b,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.thinkingAnimation = new THREE.Points(geometry, material);
                this.companion.group.add(this.thinkingAnimation);
                
                // Animate thinking particles
                const animateThinking = () => {
                    if (!this.thinkingAnimation) return;
                    
                    this.thinkingAnimation.rotation.y += 0.02;
                    const positions = this.thinkingAnimation.geometry.attributes.position.array;
                    
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] = 3 + Math.sin(Date.now() * 0.001 + i) * 0.2;
                    }
                    
                    this.thinkingAnimation.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateThinking);
                };
                
                animateThinking();
            }

            createCompanion() {
                const companionGroup = new THREE.Group();

                // Glowing orb with more detail
                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8338ec,
                    emissive: 0x8338ec,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });

                const orb = new THREE.Mesh(geometry, material);
                orb.position.y = 2;
                companionGroup.add(orb);

                // Inner core
                const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 2;
                companionGroup.add(core);

                // Add glow
                const light = new THREE.PointLight(0x8338ec, 2, 10);
                light.position.y = 2;
                companionGroup.add(light);

                // Position in center panel
                companionGroup.position.set(0, 0, 0);
                scene.add(companionGroup);

                this.companion = { group: companionGroup, orb, core, light };
                
                // Set camera target
                cameraController.setTarget(companionGroup);
                
                // Animate companion
                this.animateCompanion();
            }

            animateCompanion() {
                if (!this.companion) return;

                const time = Date.now() * 0.001;
                
                // Float animation
                this.companion.orb.position.y = 2 + Math.sin(time * 2) * 0.2;
                this.companion.core.position.y = 2 + Math.sin(time * 2) * 0.2;
                
                // Core pulse
                this.companion.core.scale.setScalar(1 + Math.sin(time * 4) * 0.1);
                
                // Rotate core
                this.companion.core.rotation.y = time;
                
                // Pulse glow based on state
                if (this.companion.light.intensity > 2) {
                    this.companion.light.intensity = 2 + Math.sin(time * 3) * 0.5;
                }
                
                requestAnimationFrame(() => this.animateCompanion());
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message) return;

                this.addMessage(message, 'user');
                this.chatInput.value = '';
                this.loadingIndicator.classList.remove('hidden');

                // Set thinking state
                this.setAIState('thinking', 'Thinking...');

                this.conversationHistory.push({ role: 'user', content: message });

                // Simulate response for now
                setTimeout(() => {
                    const response = this.generateSimulatedResponse(message);
                    this.addMessage(response, 'ai');
                    this.conversationHistory.push({ role: 'assistant', content: response });
                    
                    this.loadingIndicator.classList.add('hidden');
                    this.setAIState('idle', 'Ready');
                    
                    if (this.ttsEnabled) {
                        this.speak(response);
                    }
                }, 2000);
            }

            speak(text) {
                if (!this.synthesizer || !this.ttsEnabled) return;

                // Clean text for speech
                const cleanText = text.replace(/<[^>]*>/g, ' ')
                    .replace(/\*\*([^*]+)\*\*/g, '$1')
                    .replace(/\n/g, ' ')
                    .replace(/```[^`]*```/g, 'code block')
                    .trim();

                try {
                    this.synthesizer.speakTextAsync(
                        cleanText,
                        result => {
                            if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                                console.log('Speech synthesis completed');
                            }
                        },
                        error => {
                            console.error('Speech synthesis error:', error);
                        }
                    );
                } catch (error) {
                    console.error('Failed to speak:', error);
                }
            }

            speakAction(text) {
                // Speak short action descriptions
                if (!this.ttsEnabled) return;
                
                try {
                    this.synthesizer.speakTextAsync(
                        text,
                        result => {
                            console.log('Action spoken:', text);
                        },
                        error => {
                            console.error('Failed to speak action:', error);
                        }
                    );
                } catch (error) {
                    console.error('Failed to speak action:', error);
                }
            }

            addMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender}`;
                messageDiv.textContent = text;

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                
                return messageDiv;
            }
        }

        // Camera Controller remains the same
        class CameraController {
            constructor(camera, target) {
                this.camera = camera;
                this.target = target;
                this.offset = new THREE.Vector3(0, 5, 15);
                this.lookOffset = new THREE.Vector3(0, 0, -5);
                this.smoothness = 0.1;
            }

            update() {
                if (!this.target) return;

                // Calculate desired camera position
                const desiredPosition = this.target.position.clone().add(this.offset);
                
                // Smoothly move camera
                this.camera.position.lerp(desiredPosition, this.smoothness);
                
                // Look at a point in front of the companion
                const lookTarget = this.target.position.clone().add(this.lookOffset);
                this.camera.lookAt(lookTarget);
            }

            setTarget(target) {
                this.target = target;
            }

            setView(viewType) {
                switch(viewType) {
                    case 'overview':
                        this.offset.set(0, 10, 20);
                        break;
                    case 'shoulder':
                        this.offset.set(-3, 5, 8);
                        break;
                    case 'work':
                        this.offset.set(0, 8, 12);
                        break;
                }
            }
        }

        // Enhanced VisualizationManager remains mostly the same
        class VisualizationManager {
            constructor(scene) {
                this.scene = scene;
                this.agentVisuals = new Map();
                this.dataFlows = [];
                this.comparisonGroup = new THREE.Group();
                this.workspaceGroup = new THREE.Group();
                this.scene.add(this.comparisonGroup);
                this.scene.add(this.workspaceGroup);
                
                // Create workspace area in right panel
                this.createWorkspace();
            }

            createWorkspace() {
                // Work table positioned in right third
                const tableGeometry = new THREE.BoxGeometry(8, 0.2, 6);
                const tableMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a2a3e,
                    metalness: 0.5,
                    roughness: 0.7
                });
                const table = new THREE.Mesh(tableGeometry, tableMaterial);
                table.position.set(8, -0.1, 0);
                this.workspaceGroup.add(table);

                // Grid on table
                const gridHelper = new THREE.GridHelper(8, 8, 0x444466, 0x333355);
                gridHelper.rotation.x = Math.PI / 2;
                gridHelper.position.set(8, 0.01, 0);
                this.workspaceGroup.add(gridHelper);
            }

            createAgentVisual(agentName, position, isHistory = false) {
                const group = new THREE.Group();
                
                // Agent sphere
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: isHistory ? 0x666666 : this.getAgentColor(agentName),
                    metalness: 0.5,
                    roughness: 0.5,
                    transparent: true,
                    opacity: isHistory ? 0.5 : 1,
                    emissive: isHistory ? 0x000000 : this.getAgentColor(agentName),
                    emissiveIntensity: 0.2
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                group.add(sphere);
                
                // Agent label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(agentName, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 0.5, 1);
                sprite.position.y = 1;
                group.add(sprite);
                
                group.position.copy(position);
                this.workspaceGroup.add(group);
                
                return { group, sphere, material };
            }

            getAgentColor(agentName) {
                const colors = {
                    'HackerNewsAgent': 0xff6600,
                    'Dynamics365CRUD': 0x0078d4,
                    'ManageMemory': 0x9b59b6,
                    'LocalTimeAgent': 0x3498db,
                    'PowerPoint': 0xd35400,
                    'WikipediaAgent': 0x2ecc71,
                    'EmailDrafting': 0xe74c3c,
                    'CodeReview': 0x1abc9c,
                    'DataAnalysis': 0xf39c12
                };
                return colors[agentName] || 0x95a5a6;
            }

            showAgentCall(agentName, isHistory = false, result = null) {
                // Position in right panel
                const xOffset = 8 + (isHistory ? -2 : 2);
                const position = new THREE.Vector3(xOffset, 1, 0);
                
                const key = agentName + (isHistory ? '_history' : '');
                if (!this.agentVisuals.has(key)) {
                    const visual = this.createAgentVisual(agentName, position, isHistory);
                    this.agentVisuals.set(key, visual);
                }
                
                const visual = this.agentVisuals.get(key);
                
                // Animate agent activation
                this.animateAgentActivation(visual, result);
                
                // Create data flow visualization from AI to agent
                if (!isHistory) {
                    this.createDataFlow(new THREE.Vector3(0, 2, 0), position);
                }
            }

            animateAgentActivation(visual, result) {
                const startScale = 1;
                const endScale = 1.5;
                const duration = 500;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const scale = startScale + (endScale - startScale) * Math.sin(progress * Math.PI);
                    visual.sphere.scale.setScalar(scale);
                    
                    // Pulse emissive
                    visual.material.emissiveIntensity = 0.2 + 0.3 * Math.sin(progress * Math.PI);
                    
                    // Change color based on result
                    if (result) {
                        const success = result.includes('success') || result.length > 0;
                        visual.material.emissive = new THREE.Color(success ? 0x00ff00 : 0xff0000);
                        visual.material.emissiveIntensity = 0.5 * (1 - progress);
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }

            createDataFlow(start, end) {
                const points = [];
                const segments = 50;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = start.x + (end.x - start.x) * t;
                    const y = start.y + (end.y - start.y) * t + Math.sin(t * Math.PI) * 0.5;
                    const z = start.z + (end.z - start.z) * t;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x06ffa5,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0
                });
                
                const line = new THREE.Line(geometry, material);
                this.workspaceGroup.add(line);
                
                // Animate line
                const animateLine = () => {
                    material.opacity = Math.min(material.opacity + 0.05, 1);
                    if (material.opacity >= 1) {
                        setTimeout(() => {
                            const fadeOut = () => {
                                material.opacity -= 0.02;
                                if (material.opacity > 0) {
                                    requestAnimationFrame(fadeOut);
                                } else {
                                    this.workspaceGroup.remove(line);
                                }
                            };
                            fadeOut();
                        }, 1000);
                    } else {
                        requestAnimationFrame(animateLine);
                    }
                };
                
                animateLine();
            }

            clear() {
                // Clear all visualizations
                this.agentVisuals.clear();
                while (this.workspaceGroup.children.length > 2) { // Keep table and grid
                    this.workspaceGroup.remove(this.workspaceGroup.children[2]);
                }
            }
        }

        // Initialize Three.js scene
        let scene, camera, renderer;
        let visualManager, aiManager, simulationManager, cameraController;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000033, 10, 100);

            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 8, 20);
            camera.lookAt(0,0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('three-container').appendChild(renderer.domElement);

            // Enhanced lighting for better depth
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            // Add a second light for better companion visibility
            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            fillLight.position.set(-5, 10, -5);
            scene.add(fillLight);

            // Simple ground
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Main grid
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Add vertical dividers for visual separation
            createPanelDividers();

            // Initialize camera controller
            cameraController = new CameraController(camera, null);

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createPanelDividers() {
            // Create visual dividers in 3D space
            const dividerGeometry = new THREE.PlaneGeometry(0.1, 20);
            const dividerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.3
            });

            const divider1 = new THREE.Mesh(dividerGeometry, dividerMaterial);
            divider1.position.set(-5.5, 5, 0);
            divider1.rotation.y = Math.PI / 2;
            scene.add(divider1);

            const divider2 = new THREE.Mesh(dividerGeometry, dividerMaterial);
            divider2.position.set(5.5, 5, 0);
            divider2.rotation.y = Math.PI / 2;
            scene.add(divider2);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera controller
            cameraController.update();
            
            renderer.render(scene, camera);
        }

        // Initialize everything
        initThreeJS();
        visualManager = new VisualizationManager(scene);
        aiManager = new AIManager(visualManager);
        simulationManager = new SimulationManager(aiManager, visualManager);
        animate();

        // Expose managers globally for button onclick handlers
        window.aiManager = aiManager;
        window.simulationManager = simulationManager;

        // Auto-start with a demo scenario after a short delay
        setTimeout(() => {
            simulationManager.startScenario('business-analysis');
        }, 2000);
    </script>
</body>
</html>