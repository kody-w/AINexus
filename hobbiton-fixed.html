<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Hobbiton Trailer Park</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #8B7355, #228B22, #FFD700);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
        }

        @keyframes shimmer {
            0%, 100% { 
                background-position: 0% 50%; 
                filter: hue-rotate(0deg);
            }
            50% { 
                background-position: 100% 50%;
                filter: hue-rotate(30deg);
            }
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        .portal-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid transparent;
            border-image: linear-gradient(45deg, #8B7355, #228B22, #FFD700) 1;
            border-radius: 15px;
            padding: 20px;
            max-width: 300px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .portal-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FFD700, #228B22);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #90EE90;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(139, 115, 85, 0.5);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
            box-shadow: 0 0 20px rgba(139, 115, 85, 0.5);
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #8B7355, #654321);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 100px;
            height: 100px;
            margin: 30px auto;
            border: 2px solid transparent;
            border-top-color: #228B22;
            border-radius: 50%;
            animation: quantum-spin 1s ease-in-out infinite;
        }

        @keyframes quantum-spin {
            0% { 
                transform: rotate(0deg) scale(1);
                border-top-color: #228B22;
            }
            50% { 
                transform: rotate(180deg) scale(1.2);
                border-top-color: #FFD700;
            }
            100% { 
                transform: rotate(360deg) scale(1);
                border-top-color: #228B22;
            }
        }

        .info-panel {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 250px;
        }

        .info-title {
            color: #FFD700;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .info-content {
            font-size: 0.85em;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;
            }
            
            .world-description {
                font-size: 1em;
                max-width: 300px;
            }

            .info-panel {
                display: none;
            }
        }

        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                height: 100vh;
                height: -webkit-fill-available;
            }
            
            #three-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div class="look-area" id="look-area"></div>
    
    <div class="world-ui">
        <h1 class="world-title" id="world-title">HOBBITON TRAILER PARK</h1>
        <p class="world-description" id="world-description">Where the Shire meets Route 66. Home to Garrett Califano and his merry band of hobbit-trailer dwellers.</p>
    </div>
    
    <div class="info-panel" id="info-panel">
        <div class="info-title">Welcome, Traveler!</div>
        <div class="info-content">
            Explore our unique community where Middle-earth charm meets American road culture. Visit Garrett's tower, warm yourself by the campfires, or discover the hidden hobbit holes!
        </div>
    </div>
    
    <div class="controls-hint" id="controls-hint">WASD: Move | Mouse: Look | Click: Travel | Space: Jump</div>
    
    <div class="mobile-controls" id="mobile-controls">
        <div class="controls-container">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
    </div>
    
    <div class="portal-tooltip" id="portal-tooltip">
        <h3 class="tooltip-title"></h3>
        <p class="tooltip-description"></p>
        <p class="tooltip-instruction">Click to enter</p>
    </div>
    
    <div class="loading" id="loading">Materializing the magical trailer park...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration
        const REPO_OWNER = 'yourusername';
        const REPO_NAME = 'nexus-worlds';
        const BRANCH = 'main';
        
        // World configuration
        const WORLD_CONFIG = {
            name: "Hobbiton Trailer Park",
            description: "Where the Shire meets Route 66. Home to Garrett Califano and his merry band of hobbit-trailer dwellers.",
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            cameraHeight: 1.8,
            gravity: 0.02,
            jumpForce: 0.35
        };
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
        
        class HobbitonTrailerPark {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.portals = [];
                this.signs = [];
                this.worlds = [];
                this.clock = new THREE.Clock();
                this.raycaster = new THREE.Raycaster();
                
                // Movement
                this.moveSpeed = WORLD_CONFIG.moveSpeed;
                this.lookSpeed = WORLD_CONFIG.lookSpeed;
                this.keys = { w: false, a: false, s: false, d: false, ' ': false };
                this.rotation = { x: 0, y: 0 };
                this.velocity = new THREE.Vector3();
                this.canJump = true;
                
                // Mobile
                this.isMobile = isMobile;
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;
                
                // UI
                this.hoveredPortal = null;
                this.tooltip = document.getElementById('portal-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
                this.isPointerLocked = false;
            }
            
            async init() {
                this.setupRenderer();
                this.setupScene();
                this.setupLighting();
                await this.loadWorlds();
                this.createTerrain();
                this.createStructures();
                this.createEffects();
                this.createPortals();
                this.setupControls();
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
                
                if (this.isMobile) {
                    document.getElementById('controls-hint').textContent = 'Touch & drag to look, Use joystick to move';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                this.animate();
            }
            
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.BasicShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0xE0D5B7, 10, 300);
                
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    400
                );
                this.camera.position.set(0, WORLD_CONFIG.cameraHeight, 10);
            }
            
            setupLighting() {
                // Warm ambient light
                const ambient = new THREE.AmbientLight(0xF5DEB3, 0.65);
                this.scene.add(ambient);
                
                // Directional light (warm sun)
                const sun = new THREE.DirectionalLight(0xFFE4B5, 0.8);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.camera.left = -50;
                sun.shadow.camera.right = 50;
                sun.shadow.camera.top = 50;
                sun.shadow.camera.bottom = -50;
                sun.shadow.mapSize.width = 1024;
                sun.shadow.mapSize.height = 1024;
                this.scene.add(sun);
                
                // Hemisphere light with warm colors
                const hemi = new THREE.HemisphereLight(0xFFE4B5, 0x8B7355, 0.4);
                this.scene.add(hemi);
            }
            
            async loadWorlds() {
                try {
                    const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    this.worlds = data.tree
                        .filter(item => 
                            item.type === 'blob' && 
                            item.path.endsWith('.html') && 
                            !item.path.includes('/') &&
                            !item.path.toLowerCase().includes('index') &&
                            !item.path.toLowerCase().includes('readme') &&
                            !item.path.toLowerCase().includes('hobbiton_trailer_park')
                        )
                        .map(item => ({
                            name: this.formatWorldName(item.path),
                            url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`
                        }));
                    
                    // Add hub
                    this.worlds.unshift({
                        name: "Nexus Hub",
                        description: "Return to the central hub",
                        url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/index.html`
                    });
                    
                } catch (error) {
                    console.error("Error loading worlds:", error);
                    this.worlds = [
                        { name: "Nexus Hub", description: "Return to the central hub" },
                        { name: "Crystal Caves", description: "Mystical underground realm" },
                        { name: "Sky Islands", description: "Floating paradise" },
                        { name: "Neon City", description: "Cyberpunk metropolis" }
                    ];
                }
            }
            
            formatWorldName(filename) {
                return filename
                    .replace('.html', '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
            
            createTerrain() {
                // Flat green ground with very subtle variation
                const groundGeometry = new THREE.PlaneGeometry(300, 300, 30, 30);
                const vertices = groundGeometry.attributes.position.array;
                
                // Add very subtle variation
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const y = vertices[i + 1];
                    // Much smaller height variation
                    vertices[i + 2] = Math.sin(x * 0.01) * Math.cos(y * 0.01) * 0.3 + 
                                     Math.sin(x * 0.03) * Math.cos(y * 0.03) * 0.2;
                }
                groundGeometry.computeVertexNormals();
                
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x7CFC00,
                    side: THREE.DoubleSide
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Sky dome
                const skyGeometry = new THREE.SphereGeometry(200, 16, 12);
                const skyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x87CEEB,
                    side: THREE.BackSide,
                    fog: false
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);
                
                // Add some clouds (simple spheres)
                const cloudPositions = [
                    [50, 60, -80], [-70, 50, -60], [80, 55, 40], 
                    [-60, 65, 70], [30, 70, -50], [-40, 45, -40]
                ];
                
                cloudPositions.forEach(pos => {
                    const cloudGroup = new THREE.Group();
                    
                    // Create cloud from multiple spheres
                    for (let i = 0; i < 4; i++) {
                        const cloudPart = new THREE.Mesh(
                            new THREE.SphereGeometry(8 + Math.random() * 4, 6, 4),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xFFFFFF,
                                opacity: 0.8,
                                transparent: true
                            })
                        );
                        cloudPart.position.set(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 10
                        );
                        cloudPart.scale.set(
                            1 + Math.random() * 0.5,
                            0.6 + Math.random() * 0.3,
                            1 + Math.random() * 0.5
                        );
                        cloudGroup.add(cloudPart);
                    }
                    
                    cloudGroup.position.set(pos[0], pos[1], pos[2]);
                    cloudGroup.userData = { 
                        baseY: pos[1],
                        speed: 0.1 + Math.random() * 0.1 
                    };
                    this.clouds = this.clouds || [];
                    this.clouds.push(cloudGroup);
                    this.scene.add(cloudGroup);
                });
                
                // Add distant mountains (simple cones)
                const mountainPositions = [
                    [-120, 0, -100], [130, 0, -90], [-100, 0, -120], [110, 0, -110]
                ];
                
                mountainPositions.forEach((pos, i) => {
                    const mountain = new THREE.Mesh(
                        new THREE.ConeGeometry(30 + i * 5, 40 + i * 10, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x8B7D6B,
                            fog: true
                        })
                    );
                    mountain.position.set(pos[0], 20, pos[2]);
                    mountain.receiveShadow = true;
                    mountain.castShadow = true;
                    this.scene.add(mountain);
                });
                
                // Add some grass patches for visual interest
                for (let i = 0; i < 20; i++) {
                    const patchGeometry = new THREE.PlaneGeometry(
                        Math.random() * 5 + 2, 
                        Math.random() * 5 + 2
                    );
                    const patchMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(0.25, 0.6, 0.4 + Math.random() * 0.1),
                        side: THREE.DoubleSide
                    });
                    const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                    patch.position.set(
                        (Math.random() - 0.5) * 100,
                        0.01,
                        (Math.random() - 0.5) * 100
                    );
                    patch.rotation.x = -Math.PI / 2;
                    patch.receiveShadow = true;
                    this.scene.add(patch);
                }
                
                // Add dirt patches near structures
                const dirtPositions = [
                    [0, -10], [20, 10], [-25, -15], [10, -25]
                ];
                
                dirtPositions.forEach(pos => {
                    const dirtGeometry = new THREE.CircleGeometry(5, 8);
                    const dirtMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xD2691E,
                        side: THREE.DoubleSide
                    });
                    const dirt = new THREE.Mesh(dirtGeometry, dirtMaterial);
                    dirt.position.set(pos[0], 0.005, pos[1]);
                    dirt.rotation.x = -Math.PI / 2;
                    dirt.receiveShadow = true;
                    this.scene.add(dirt);
                });
                
                // Add trees
                const treePositions = [
                    [-30, 0, 20], [40, 0, -20], [-20, 0, -40], [30, 0, 30],
                    [-45, 0, -10], [25, 0, -35], [-35, 0, 35], [45, 0, 15]
                ];
                
                treePositions.forEach(pos => {
                    // Trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 5, 6);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(pos[0], 2.5, pos[2]);
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    this.scene.add(trunk);
                    
                    // Leaves with warmer green
                    const leavesGeometry = new THREE.ConeGeometry(5, 8, 6);
                    const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x6B8E23 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(pos[0], 8, pos[2]);
                    leaves.castShadow = true;
                    leaves.receiveShadow = true;
                    this.scene.add(leaves);
                });
            }
            
            createStructures() {
                // 1. Garrett's Tower (simplified)
                const towerGroup = new THREE.Group();
                
                // Base
                const baseGeometry = new THREE.CylinderGeometry(5, 6, 4, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 2;
                base.castShadow = true;
                base.receiveShadow = true;
                towerGroup.add(base);
                
                // Top with hobbit green
                const topGeometry = new THREE.ConeGeometry(5, 5, 8);
                const topMaterial = new THREE.MeshLambertMaterial({ color: 0x6B8E23 });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 6.5;
                top.castShadow = true;
                towerGroup.add(top);
                
                // Light
                const towerLight = new THREE.PointLight(0xFFD700, 1, 20);
                towerLight.position.y = 5;
                towerGroup.add(towerLight);
                
                towerGroup.position.set(0, 0, -10);
                this.scene.add(towerGroup);
                
                // 2. Multiple Trailers
                const trailerPositions = [
                    { pos: [20, 0, 10], rot: -0.3, color: 0xC0C0C0 },
                    { pos: [35, 0, 20], rot: 0.4, color: 0xFFE4C4 },
                    { pos: [15, 0, 35], rot: -0.8, color: 0x87CEEB },
                    { pos: [-10, 0, 30], rot: 1.2, color: 0xDDA0DD },
                    { pos: [45, 0, 5], rot: -0.5, color: 0x98FB98 }
                ];
                
                trailerPositions.forEach((trailerData, index) => {
                    const trailerGroup = new THREE.Group();
                    
                    const trailerBody = new THREE.Mesh(
                        new THREE.BoxGeometry(8 + Math.random() * 2, 3, 4),
                        new THREE.MeshLambertMaterial({ color: trailerData.color })
                    );
                    trailerBody.position.y = 1.5;
                    trailerBody.castShadow = true;
                    trailerBody.receiveShadow = true;
                    trailerGroup.add(trailerBody);
                    
                    // Wheels
                    const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
                    for (let x = -2.5; x <= 2.5; x += 5) {
                        const wheel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8),
                            wheelMaterial
                        );
                        wheel.position.set(x, 0.5, 2.2);
                        wheel.rotation.z = Math.PI / 2;
                        trailerGroup.add(wheel);
                        
                        const wheel2 = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8),
                            wheelMaterial
                        );
                        wheel2.position.set(x, 0.5, -2.2);
                        wheel2.rotation.z = Math.PI / 2;
                        trailerGroup.add(wheel2);
                    }
                    
                    // Windows with warm glow
                    const windowMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFE4B5,
                        emissive: 0xFFD700,
                        emissiveIntensity: 0.3
                    });
                    
                    const windowCount = 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < windowCount; i++) {
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 0.1),
                            windowMaterial
                        );
                        window.position.set(-2 + i * 2, 2, 2.05);
                        trailerGroup.add(window);
                    }
                    
                    // Door
                    const doorMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2, 0.1),
                        new THREE.MeshLambertMaterial({ color: 0x654321 })
                    );
                    doorMesh.position.set(3, 1.5, 2.05);
                    trailerGroup.add(doorMesh);
                    
                    // Awning
                    if (index % 2 === 0) {
                        const awningGeometry = new THREE.BoxGeometry(6, 0.1, 3);
                        const awningMaterial = new THREE.MeshLambertMaterial({ 
                            color: [0xFF6347, 0x4682B4, 0x32CD32][index % 3]
                        });
                        const awning = new THREE.Mesh(awningGeometry, awningMaterial);
                        awning.position.set(0, 3.1, 3);
                        awning.rotation.x = -0.3;
                        trailerGroup.add(awning);
                        
                        // Awning poles
                        for (let x = -2.5; x <= 2.5; x += 5) {
                            const pole = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                                new THREE.MeshLambertMaterial({ color: 0x696969 })
                            );
                            pole.position.set(x, 2, 4.5);
                            trailerGroup.add(pole);
                        }
                    }
                    
                    // Propane tank
                    const tank = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 1, 8),
                        new THREE.MeshLambertMaterial({ color: 0xF0F0F0 })
                    );
                    tank.position.set(-4.5, 0.5, 0);
                    trailerGroup.add(tank);
                    
                    trailerGroup.position.set(trailerData.pos[0], trailerData.pos[1], trailerData.pos[2]);
                    trailerGroup.rotation.y = trailerData.rot;
                    this.scene.add(trailerGroup);
                });
                
                // 3. Multiple Hobbit Holes - Built INTO hillsides
                const hobbitHolePositions = [
                    { pos: [-25, 0, -15], color: 0x6B8E23, name: "Bag End" },
                    { pos: [-35, 0, 5], color: 0x228B22, name: "Green Dragon Inn" },
                    { pos: [-20, 0, 25], color: 0x32CD32, name: "Sandyman's Mill" },
                    { pos: [40, 0, -35], color: 0x006400, name: "Proudfoot Residence" }
                ];
                
                hobbitHolePositions.forEach((holeData, index) => {
                    const hobbitGroup = new THREE.Group();
                    
                    // Create a hillside that rises from the ground
                    const hillGeometry = new THREE.SphereGeometry(8, 16, 12);
                    const vertices = hillGeometry.attributes.position.array;
                    
                    // Modify vertices to create a hillside effect
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const y = vertices[i + 1];
                        const z = vertices[i + 2];
                        
                        // Flatten the front and sink the back into ground
                        if (z > 0) {
                            vertices[i + 1] *= 0.3; // Flatten front
                        }
                        if (y < 0) {
                            vertices[i + 1] = 0; // Cut off bottom
                        }
                    }
                    hillGeometry.computeVertexNormals();
                    
                    const hillMaterial = new THREE.MeshLambertMaterial({ color: 0x7CFC00 });
                    const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                    hill.scale.set(1.5, 1, 1.2);
                    hill.position.y = 0;
                    hill.castShadow = true;
                    hill.receiveShadow = true;
                    hobbitGroup.add(hill);
                    
                    // Add dirt/earth texture around the door area
                    const earthPatch = new THREE.Mesh(
                        new THREE.CircleGeometry(3, 12),
                        new THREE.MeshLambertMaterial({ color: 0x8B7355 })
                    );
                    earthPatch.rotation.x = -Math.PI / 2 + 0.3;
                    earthPatch.position.set(0, 0.1, 6);
                    hobbitGroup.add(earthPatch);
                    
                    // Door inset into the hill
                    const doorGroup = new THREE.Group();
                    
                    // Door recess (dark interior)
                    const recessGeometry = new THREE.CircleGeometry(2.2, 16);
                    const recess = new THREE.Mesh(
                        recessGeometry,
                        new THREE.MeshLambertMaterial({ color: 0x2F4F2F })
                    );
                    recess.position.z = -0.2;
                    doorGroup.add(recess);
                    
                    // Wooden door frame
                    const doorFrame = new THREE.Mesh(
                        new THREE.TorusGeometry(2, 0.3, 8, 16),
                        new THREE.MeshLambertMaterial({ color: 0x654321 })
                    );
                    doorFrame.castShadow = true;
                    doorGroup.add(doorFrame);
                    
                    // Main door
                    const door = new THREE.Mesh(
                        new THREE.CircleGeometry(1.8, 16),
                        new THREE.MeshLambertMaterial({ color: holeData.color })
                    );
                    door.position.z = 0.1;
                    door.castShadow = true;
                    doorGroup.add(door);
                    
                    // Door details
                    const doorDetail = new THREE.Mesh(
                        new THREE.RingGeometry(0.9, 1.2, 16),
                        new THREE.MeshLambertMaterial({ color: 0x4B5320 })
                    );
                    doorDetail.position.z = 0.15;
                    doorGroup.add(doorDetail);
                    
                    // Door knob
                    const knob = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xFFD700,
                            emissive: 0xFFD700,
                            emissiveIntensity: 0.3
                        })
                    );
                    knob.position.set(0.7, 0, 0.3);
                    knob.castShadow = true;
                    doorGroup.add(knob);
                    
                    // Position door embedded in the hill
                    doorGroup.position.set(0, 1.5, 4.5);
                    hobbitGroup.add(doorGroup);
                    
                    // Round windows on the side
                    if (index % 2 === 0) {
                        const windowGroup = new THREE.Group();
                        
                        const windowRecess = new THREE.Mesh(
                            new THREE.CircleGeometry(0.8, 12),
                            new THREE.MeshLambertMaterial({ color: 0x2F4F2F })
                        );
                        windowGroup.add(windowRecess);
                        
                        const windowFrame = new THREE.Mesh(
                            new THREE.TorusGeometry(0.8, 0.15, 8, 12),
                            new THREE.MeshLambertMaterial({ color: 0x654321 })
                        );
                        windowFrame.position.z = 0.1;
                        windowGroup.add(windowFrame);
                        
                        const windowGlass = new THREE.Mesh(
                            new THREE.CircleGeometry(0.65, 12),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFFFFE0,
                                emissive: 0xFFD700,
                                emissiveIntensity: 0.4
                            })
                        );
                        windowGlass.position.z = 0.15;
                        windowGroup.add(windowGlass);
                        
                        windowGroup.position.set(3, 2, 3);
                        windowGroup.rotation.y = -0.3;
                        hobbitGroup.add(windowGroup);
                    }
                    
                    // Path stones leading to door
                    for (let i = 0; i < 5; i++) {
                        const stone = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4 + Math.random() * 0.2, 0.4 + Math.random() * 0.2, 0.1, 8),
                            new THREE.MeshLambertMaterial({ color: 0x696969 })
                        );
                        stone.position.set(
                            (Math.random() - 0.5) * 2,
                            0.05,
                            7 + i * 1.5
                        );
                        stone.rotation.y = Math.random() * Math.PI;
                        stone.castShadow = true;
                        hobbitGroup.add(stone);
                    }
                    
                    // Small garden
                    for (let i = 0; i < 10; i++) {
                        const flower = new THREE.Mesh(
                            new THREE.SphereGeometry(0.2, 6, 6),
                            new THREE.MeshLambertMaterial({ 
                                color: [0xFF69B4, 0xFFFF00, 0xFF6347, 0xDA70D6][Math.floor(Math.random() * 4)]
                            })
                        );
                        const angle = Math.random() * Math.PI - Math.PI / 2;
                        const dist = 4 + Math.random() * 3;
                        flower.position.set(
                            Math.cos(angle) * dist,
                            0.2,
                            Math.sin(angle) * dist + 3
                        );
                        hobbitGroup.add(flower);
                    }
                    
                    hobbitGroup.position.set(holeData.pos[0], holeData.pos[1], holeData.pos[2]);
                    hobbitGroup.rotation.y = Math.random() * Math.PI * 2;
                    hobbitGroup.userData = { name: holeData.name };
                    this.scene.add(hobbitGroup);
                });
                
                // 4. Campfire
                const campfireGroup = new THREE.Group();
                
                // Fire pit
                const pitGeometry = new THREE.CylinderGeometry(2, 1.5, 0.5, 8);
                const pitMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const pit = new THREE.Mesh(pitGeometry, pitMaterial);
                pit.position.y = 0.25;
                campfireGroup.add(pit);
                
                // Fire (simple warm glow)
                const fireGeometry = new THREE.ConeGeometry(1, 3, 6);
                const fireMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF8C00,
                    emissive: 0xFF6347,
                    emissiveIntensity: 0.8
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.y = 1.5;
                campfireGroup.add(fire);
                
                // Fire light with warm orange
                const fireLight = new THREE.PointLight(0xFF8C00, 2, 15);
                fireLight.position.y = 2;
                campfireGroup.add(fireLight);
                
                // Logs
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const log = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.5, 0.5),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    log.position.x = Math.cos(angle) * 4;
                    log.position.z = Math.sin(angle) * 4;
                    log.position.y = 0.25;
                    log.rotation.y = angle;
                    log.castShadow = true;
                    log.receiveShadow = true;
                    campfireGroup.add(log);
                }
                
                campfireGroup.position.set(10, 0, -25);
                this.scene.add(campfireGroup);
                
                // 5. Information Signs throughout the park
                const signPositions = [
                    { 
                        pos: [0, 0, 20], 
                        title: "Welcome to Hobbiton Trailer Park",
                        description: "Where the Shire meets Route 66. Founded by Garrett Califano, this unique community blends hobbit charm with American road culture."
                    },
                    { 
                        pos: [5, 0, -5], 
                        title: "Garrett's Tower",
                        description: "Home of Park Manager & Wizard Extraordinaire Garrett Califano. Office hours: Sunrise to Sunset, or whenever the stars align."
                    },
                    { 
                        pos: [-30, 0, -5], 
                        title: "Historic Hobbit Holes",
                        description: "Established 1937. Traditional hobbit dwellings preserved in their original state. No admittance except on party business!"
                    },
                    { 
                        pos: [25, 0, 25], 
                        title: "Trailer Village",
                        description: "Modern accommodations with full hookups. Monthly rates available. Pet-friendly! See Garrett for availability."
                    },
                    { 
                        pos: [10, 0, -30], 
                        title: "Community Campfire",
                        description: "Gather 'round for stories and s'mores! Nightly at 8pm. BYO marshmallows. Fire-breathing dragons welcome."
                    },
                    { 
                        pos: [-10, 0, 15], 
                        title: "Community Gardens",
                        description: "Plots available for rent. Prize-winning vegetables grown here! See Samwise for gardening tips and plot assignments."
                    }
                ];
                
                this.signs = []; // Store signs for hover detection
                
                signPositions.forEach((signData, index) => {
                    const signGroup = new THREE.Group();
                    
                    // Sign post
                    const post = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.15, 3, 8),
                        new THREE.MeshLambertMaterial({ color: 0x654321 })
                    );
                    post.position.y = 1.5;
                    post.castShadow = true;
                    signGroup.add(post);
                    
                    // Sign board (interactive)
                    const signBoard = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 2, 0.2),
                        new THREE.MeshLambertMaterial({ color: 0xDEB887 })
                    );
                    signBoard.position.y = 3;
                    signBoard.castShadow = true;
                    signBoard.receiveShadow = true;
                    
                    // Store sign data for tooltip
                    signBoard.userData = {
                        title: signData.title,
                        description: signData.description,
                        isSign: true
                    };
                    
                    // Add decorative frame
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(4.2, 2.2, 0.1),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    frame.position.y = 3;
                    frame.position.z = -0.1;
                    signGroup.add(frame);
                    signGroup.add(signBoard);
                    
                    // Visual indicator (small text representation)
                    const textIndicator = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.3, 0.05),
                        new THREE.MeshLambertMaterial({ color: 0x2F4F2F })
                    );
                    textIndicator.position.y = 3;
                    textIndicator.position.z = 0.15;
                    signGroup.add(textIndicator);
                    
                    // Add to signs array for hover detection
                    this.signs.push(signBoard);
                    
                    signGroup.position.set(signData.pos[0], signData.pos[1], signData.pos[2]);
                    signGroup.rotation.y = Math.atan2(signData.pos[0], signData.pos[2]);
                    this.scene.add(signGroup);
                });
                
                // Add a windmill in the distance
                const windmillGroup = new THREE.Group();
                
                // Windmill tower
                const windmillTower = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 3, 15, 6),
                    new THREE.MeshLambertMaterial({ color: 0x8B7355 })
                );
                windmillTower.position.y = 7.5;
                windmillGroup.add(windmillTower);
                
                // Windmill blades
                const bladeGroup = new THREE.Group();
                for (let i = 0; i < 4; i++) {
                    const blade = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 8, 0.2),
                        new THREE.MeshLambertMaterial({ color: 0xDEB887 })
                    );
                    blade.position.y = 4;
                    blade.rotation.z = (i / 4) * Math.PI * 2;
                    bladeGroup.add(blade);
                }
                bladeGroup.position.y = 15;
                windmillGroup.add(bladeGroup);
                
                windmillGroup.position.set(-50, 0, -70);
                windmillGroup.userData = { blades: bladeGroup };
                this.windmill = windmillGroup;
                this.scene.add(windmillGroup);
                
                // Add a small pond
                const pond = new THREE.Mesh(
                    new THREE.CircleGeometry(8, 16),
                    new THREE.MeshLambertMaterial({ 
                        color: 0x4682B4,
                        opacity: 0.8,
                        transparent: true
                    })
                );
                pond.rotation.x = -Math.PI / 2;
                pond.position.set(35, 0.1, -30);
                pond.receiveShadow = true;
                this.scene.add(pond);
                
                // Add some flowers around structures
                const flowerColors = [0xFF69B4, 0xFFFF00, 0xFF6347, 0xDA70D6];
                for (let i = 0; i < 30; i++) {
                    const flower = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 4, 4),
                        new THREE.MeshLambertMaterial({ 
                            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                        })
                    );
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 15 + Math.random() * 30;
                    flower.position.set(
                        Math.cos(angle) * dist,
                        0.3,
                        Math.sin(angle) * dist
                    );
                    this.scene.add(flower);
                }
                
                // Add Hobbit NPCs
                const hobbitNames = ["Frodo", "Sam", "Merry", "Pippin", "Bilbo", "Rosie", "Fatty"];
                const hobbitPositions = [
                    { pos: [-20, 0, -10], path: "circle", radius: 5 },
                    { pos: [25, 0, 15], path: "line", length: 10 },
                    { pos: [-30, 0, 10], path: "circle", radius: 8 },
                    { pos: [8, 0, -20], path: "wander", range: 15 },
                    { pos: [35, 0, 25], path: "line", length: 15 },
                    { pos: [-15, 0, 20], path: "circle", radius: 6 },
                    { pos: [15, 0, -5], path: "wander", range: 10 }
                ];
                
                this.hobbits = [];
                
                hobbitPositions.forEach((hobbitData, index) => {
                    const hobbitGroup = new THREE.Group();
                    
                    // Body (rounder for hobbits)
                    const bodyColors = [0x4682B4, 0x228B22, 0x8B4513, 0x6B8E23, 0xDAA520];
                    const body = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5, 8, 8),
                        new THREE.MeshLambertMaterial({ color: bodyColors[index % bodyColors.length] })
                    );
                    body.scale.set(1, 1.2, 1);
                    body.position.y = 0.8;
                    hobbitGroup.add(body);
                    
                    // Head
                    const head = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0xFFE4C4 })
                    );
                    head.position.y = 1.6;
                    hobbitGroup.add(head);
                    
                    // Hair (curly hobbit hair)
                    const hairColors = [0x8B4513, 0xD2691E, 0x654321, 0xA0522D];
                    const hair = new THREE.Mesh(
                        new THREE.SphereGeometry(0.35, 6, 6),
                        new THREE.MeshLambertMaterial({ color: hairColors[index % hairColors.length] })
                    );
                    hair.position.y = 1.7;
                    hair.scale.set(1.1, 0.8, 1.1);
                    hobbitGroup.add(hair);
                    
                    // Big hobbit feet
                    const footMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    for (let x = -0.2; x <= 0.2; x += 0.4) {
                        const foot = new THREE.Mesh(
                            new THREE.BoxGeometry(0.25, 0.15, 0.4),
                            footMaterial
                        );
                        foot.position.set(x, 0.1, 0.1);
                        hobbitGroup.add(foot);
                    }
                    
                    // Arms
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFE4C4 });
                    for (let side = -1; side <= 1; side += 2) {
                        const arm = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, 0.6, 6),
                            armMaterial
                        );
                        arm.position.set(side * 0.4, 1, 0);
                        arm.rotation.z = side * 0.3;
                        hobbitGroup.add(arm);
                    }
                    
                    // Give some hobbits items
                    if (index % 3 === 0) {
                        // Pipe
                        const pipe = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.08, 0.3, 6),
                            new THREE.MeshLambertMaterial({ color: 0x654321 })
                        );
                        pipe.position.set(0.3, 1.4, 0.3);
                        pipe.rotation.z = -0.5;
                        hobbitGroup.add(pipe);
                    } else if (index % 3 === 1) {
                        // Walking stick
                        const stick = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6),
                            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                        );
                        stick.position.set(0.4, 0.75, 0);
                        hobbitGroup.add(stick);
                    }
                    
                    hobbitGroup.position.set(hobbitData.pos[0], 0, hobbitData.pos[2]);
                    hobbitGroup.userData = {
                        name: hobbitNames[index % hobbitNames.length],
                        startPos: new THREE.Vector3(hobbitData.pos[0], 0, hobbitData.pos[2]),
                        pathType: hobbitData.path,
                        pathData: hobbitData,
                        angle: Math.random() * Math.PI * 2,
                        speed: 0.002 + Math.random() * 0.003,
                        wanderTarget: null
                    };
                    
                    this.hobbits.push(hobbitGroup);
                    this.scene.add(hobbitGroup);
                });
            }
            
            createEffects() {
                // Fireflies (simple particles)
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i + 1] = Math.random() * 20 + 1;
                    positions[i + 2] = (Math.random() - 0.5) * 100;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0xFFFF00,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.fireflies = new THREE.Points(geometry, material);
                this.scene.add(this.fireflies);
            }
            
            createPortals() {
                const portalCount = Math.min(this.worlds.length, 6);
                const radius = 50;
                
                for (let i = 0; i < portalCount; i++) {
                    const angle = (i / portalCount) * Math.PI * 2;
                    const world = this.worlds[i];
                    
                    // Portal structure
                    const portalGroup = new THREE.Group();
                    
                    // Platform (flush with ground)
                    const platform = new THREE.Mesh(
                        new THREE.CylinderGeometry(4, 4, 0.2, 8),
                        new THREE.MeshLambertMaterial({ color: 0x696969 })
                    );
                    platform.position.y = 0.1;
                    platform.receiveShadow = true;
                    platform.castShadow = true;
                    portalGroup.add(platform);
                    
                    // Pillars
                    const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
                    for (let side = -1; side <= 1; side += 2) {
                        const pillar = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 6, 1),
                            pillarMaterial
                        );
                        pillar.position.set(side * 3, 3, 0);
                        pillar.castShadow = true;
                        portalGroup.add(pillar);
                    }
                    
                    // Portal with warm green glow
                    const portal = new THREE.Mesh(
                        new THREE.CircleGeometry(3, 16),
                        new THREE.MeshLambertMaterial({
                            color: 0xADFF2F,
                            emissive: 0xADFF2F,
                            emissiveIntensity: 0.5,
                            side: THREE.DoubleSide
                        })
                    );
                    portal.position.y = 3.5;
                    portal.userData = {
                        world: world,
                        url: world.url,
                        name: world.name,
                        description: world.description || `Enter ${world.name}`
                    };
                    
                    portalGroup.add(portal);
                    this.portals.push(portal);
                    
                    // Position
                    portalGroup.position.x = Math.cos(angle) * radius;
                    portalGroup.position.z = Math.sin(angle) * radius;
                    portalGroup.rotation.y = -angle + Math.PI;
                    
                    this.scene.add(portalGroup);
                }
            }
            
            setupControls() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
            }
            
            setupDesktopControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys) this.keys[key] = true;
                    if (e.key === ' ') {
                        this.keys[' '] = true;
                        e.preventDefault();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys) this.keys[key] = false;
                    if (e.key === ' ') this.keys[' '] = false;
                });
                
                // Mouse
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    } else {
                        this.checkPortalClick();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }
            
            setupMobileControls() {
                const lookArea = document.getElementById('look-area');
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                // Look controls
                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    
                    // Check for portal tap
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.portals);
                    
                    if (intersects.length > 0) {
                        const portal = intersects[0].object;
                        if (portal.userData.url) {
                            this.enterPortal(portal.userData.url);
                            return;
                        }
                    }
                    
                    this.lookTouch = {
                        id: touch.identifier,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                });
                
                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;
                            
                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                            
                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;
                            
                            e.preventDefault();
                            break;
                        }
                    }
                });
                
                lookArea.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (this.lookTouch && e.changedTouches[i].identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                });
                
                // Joystick controls
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.joystickTouch = { id: touch.identifier };
                    this.joystickActive = true;
                    this.updateJoystick(touch, joystick, handle);
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive) return;
                    e.preventDefault();
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === this.joystickTouch.id) {
                            this.updateJoystick(e.touches[i], joystick, handle);
                            break;
                        }
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (this.joystickTouch && e.changedTouches[i].identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';
                            e.preventDefault();
                            break;
                        }
                    }
                });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                // Damping
                this.velocity.x *= 0.85;
                this.velocity.z *= 0.85;
                
                // Input
                if (this.isMobile && this.joystickActive) {
                    this.velocity.x += (forward.x * this.joystickVector.y + right.x * this.joystickVector.x) * this.moveSpeed;
                    this.velocity.z += (forward.z * this.joystickVector.y + right.z * this.joystickVector.x) * this.moveSpeed;
                } else {
                    if (this.keys.w) {
                        this.velocity.x += forward.x * this.moveSpeed;
                        this.velocity.z += forward.z * this.moveSpeed;
                    }
                    if (this.keys.s) {
                        this.velocity.x -= forward.x * this.moveSpeed;
                        this.velocity.z -= forward.z * this.moveSpeed;
                    }
                    if (this.keys.a) {
                        this.velocity.x -= right.x * this.moveSpeed;
                        this.velocity.z -= right.z * this.moveSpeed;
                    }
                    if (this.keys.d) {
                        this.velocity.x += right.x * this.moveSpeed;
                        this.velocity.z += right.z * this.moveSpeed;
                    }
                }
                
                // Jump
                if (this.keys[' '] && this.canJump) {
                    this.velocity.y = WORLD_CONFIG.jumpForce;
                    this.canJump = false;
                }
                
                // Gravity
                this.velocity.y -= WORLD_CONFIG.gravity;
                
                // Apply movement
                this.camera.position.add(this.velocity);
                
                // Ground check
                if (this.camera.position.y < WORLD_CONFIG.cameraHeight) {
                    this.camera.position.y = WORLD_CONFIG.cameraHeight;
                    this.velocity.y = 0;
                    this.canJump = true;
                }
                
                // Apply rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            checkPortalClick() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.portals);
                
                if (intersects.length > 0) {
                    const portal = intersects[0].object;
                    if (portal.userData.url) {
                        this.enterPortal(portal.userData.url);
                    }
                }
            }
            
            updateHover() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                
                // Check portals
                const portalIntersects = this.raycaster.intersectObjects(this.portals);
                
                // Check signs
                const signIntersects = this.signs ? this.raycaster.intersectObjects(this.signs) : [];
                
                // Combine and sort by distance
                const allIntersects = [...portalIntersects, ...signIntersects].sort((a, b) => a.distance - b.distance);
                
                if (allIntersects.length > 0) {
                    const object = allIntersects[0].object;
                    
                    if (object !== this.hoveredPortal) {
                        this.hoveredPortal = object;
                        
                        // Update tooltip content based on object type
                        if (object.userData.isSign) {
                            this.tooltipTitle.textContent = object.userData.title;
                            this.tooltipDescription.textContent = object.userData.description;
                            this.tooltip.querySelector('.tooltip-instruction').style.display = 'none';
                        } else {
                            // Portal
                            this.tooltipTitle.textContent = object.userData.name;
                            this.tooltipDescription.textContent = object.userData.description;
                            this.tooltip.querySelector('.tooltip-instruction').style.display = 'block';
                        }
                        
                        this.tooltip.classList.add('visible');
                        
                        const vector = new THREE.Vector3();
                        object.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 320)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 200)}px`;
                    }
                } else {
                    if (this.hoveredPortal) {
                        this.hoveredPortal = null;
                        this.tooltip.classList.remove('visible');
                        this.tooltip.querySelector('.tooltip-instruction').style.display = 'block';
                    }
                }
            }
            
            async enterPortal(url) {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = 'Activating portal...';
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Failed to load world');
                    
                    let htmlContent = await response.text();
                    
                    const params = new URLSearchParams();
                    params.set('from', 'hobbiton_trailer_park.html');
                    params.set('fromName', WORLD_CONFIG.name);
                    
                    const paramScript = `<script>
                        window.INJECTED_PARAMS = '?${params.toString()}';
                    <\/script>`;
                    
                    htmlContent = htmlContent.replace('<body>', `<body>${paramScript}`);
                    
                    const blob = new Blob([htmlContent], { type: 'text/html' });
                    const blobUrl = URL.createObjectURL(blob);
                    
                    setTimeout(() => {
                        window.location.href = blobUrl;
                    }, 500);
                    
                } catch (error) {
                    console.error('Portal error:', error);
                    document.getElementById('loading').innerHTML = 'Portal malfunction!';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 2000);
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = this.clock.getElapsedTime();
                
                this.updateMovement();
                this.updateHover();
                
                // Animate Hobbits
                if (this.hobbits) {
                    this.hobbits.forEach(hobbit => {
                        const userData = hobbit.userData;
                        
                        switch(userData.pathType) {
                            case 'circle':
                                userData.angle += userData.speed;
                                hobbit.position.x = userData.startPos.x + Math.sin(userData.angle) * userData.pathData.radius;
                                hobbit.position.z = userData.startPos.z + Math.cos(userData.angle) * userData.pathData.radius;
                                hobbit.rotation.y = -userData.angle + Math.PI;
                                break;
                                
                            case 'line':
                                userData.angle += userData.speed;
                                const lineOffset = Math.sin(userData.angle) * userData.pathData.length;
                                hobbit.position.x = userData.startPos.x + lineOffset * 0.7;
                                hobbit.position.z = userData.startPos.z + lineOffset * 0.3;
                                hobbit.rotation.y = lineOffset > 0 ? 0 : Math.PI;
                                break;
                                
                            case 'wander':
                                // Set new wander target if needed
                                if (!userData.wanderTarget || Math.random() < 0.01) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const dist = Math.random() * userData.pathData.range;
                                    userData.wanderTarget = new THREE.Vector3(
                                        userData.startPos.x + Math.cos(angle) * dist,
                                        0,
                                        userData.startPos.z + Math.sin(angle) * dist
                                    );
                                }
                                
                                // Move towards target
                                const dir = new THREE.Vector3().subVectors(userData.wanderTarget, hobbit.position);
                                if (dir.length() > 0.5) {
                                    dir.normalize();
                                    hobbit.position.x += dir.x * userData.speed * 10;
                                    hobbit.position.z += dir.z * userData.speed * 10;
                                    hobbit.rotation.y = Math.atan2(dir.x, dir.z);
                                } else {
                                    userData.wanderTarget = null;
                                }
                                break;
                        }
                        
                        // Bobbing motion while walking
                        hobbit.position.y = Math.abs(Math.sin(time * 8 + userData.angle)) * 0.1;
                        
                        // Arm swing
                        if (hobbit.children[3] && hobbit.children[4]) {
                            hobbit.children[3].rotation.x = Math.sin(time * 6 + userData.angle) * 0.3;
                            hobbit.children[4].rotation.x = -Math.sin(time * 6 + userData.angle) * 0.3;
                        }
                    });
                }
                
                // Animate fireflies
                if (this.fireflies) {
                    this.fireflies.rotation.y = time * 0.05;
                    const positions = this.fireflies.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + i) * 0.01;
                    }
                    this.fireflies.geometry.attributes.position.needsUpdate = true;
                }
                
                // Animate clouds
                if (this.clouds) {
                    this.clouds.forEach(cloud => {
                        cloud.position.x += cloud.userData.speed;
                        cloud.position.y = cloud.userData.baseY + Math.sin(time * 0.5) * 2;
                        
                        // Wrap clouds around
                        if (cloud.position.x > 150) {
                            cloud.position.x = -150;
                        }
                    });
                }
                
                // Animate portals
                this.portals.forEach((portal, i) => {
                    portal.rotation.z = time * 0.5;
                    portal.material.emissiveIntensity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                });
                
                // Animate windmill
                if (this.windmill && this.windmill.userData.blades) {
                    this.windmill.userData.blades.rotation.z = time * 0.3;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            const world = new HobbitonTrailerPark();
            world.init();
        });
    </script>
</body>
</html>