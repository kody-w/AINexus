<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Costco Dimension</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #0060A9, #E31837, #0060A9);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 40px rgba(227, 24, 55, 0.5);
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.9);
            max-width: 400px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .membership-card {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: linear-gradient(135deg, #0060A9, #005090);
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 0.9em;
            color: #fff;
            z-index: 1001;
            box-shadow: 0 4px 20px rgba(0, 96, 169, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .member-label {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.8);
        }

        .member-number {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        .portal-return {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 96, 169, 0.8);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: #fff;
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .portal-return:hover {
            background: rgba(227, 24, 55, 0.8);
            border-color: rgba(255, 255, 255, 0.8);
            transform: translateX(-50%) scale(1.05);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: #0060A9;
            z-index: 2000;
            font-weight: bold;
        }

        /* Mobile controls */
        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(0, 96, 169, 0.2);
            border: 2px solid rgba(0, 96, 169, 0.5);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(227, 24, 55, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        .sample-counter {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 100px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(227, 24, 55, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1em;
            color: #fff;
            z-index: 1001;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div class="look-area" id="look-area"></div>
    
    <div class="world-ui">
        <h1 class="world-title">COSTCO DIMENSION</h1>
        <p class="world-description">Welcome to the infinite warehouse. Everything comes in bulk here, even reality itself.</p>
    </div>
    
    <div class="membership-card">
        <div class="member-label">EXECUTIVE MEMBER</div>
        <div class="member-number">âˆž-424-867-5309</div>
    </div>
    
    <div class="sample-counter" id="sample-counter">
        <span>Free Samples Collected: </span><span id="sample-count">0</span>
    </div>
    
    <div class="portal-return" id="portal-return" onclick="returnToNexus()">Exit Through Gift Shop</div>
    
    <div class="mobile-controls" id="mobile-controls">
        <div class="joystick-container" id="movement-joystick">
            <div class="joystick-handle" id="movement-handle"></div>
        </div>
    </div>
    
    <div class="loading" id="loading">Checking your membership...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // World configuration
        const WORLD_CONFIG = {
            name: "Costco Dimension",
            description: "The infinite warehouse of bulk reality",
            ambientColor: 0xffffff,
            fogColor: 0xf0f0f0,
            groundColor: 0xe0e0e0,
            skyColor: 0xffffff,
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            portalColor1: 0x0060A9,
            portalColor2: 0xE31837,
            particleCount: 500,
            cameraHeight: 2,
            fogNear: 20,
            fogFar: 150
        };

        // Parse inherited attributes
        function parseInheritedAttributes() {
            let paramString = window.INJECTED_PARAMS || window.location.search;
            
            if (window.location.protocol === 'blob:') {
                const storedParams = sessionStorage.getItem('worldInheritanceParams');
                if (storedParams) {
                    paramString = storedParams;
                }
            }
            
            const params = new URLSearchParams(paramString);
            const inherited = {};
            
            if (params.has('moveSpeed')) inherited.moveSpeed = parseFloat(params.get('moveSpeed'));
            if (params.has('lookSpeed')) inherited.lookSpeed = parseFloat(params.get('lookSpeed'));
            
            return inherited;
        }

        const inheritedAttributes = parseInheritedAttributes();
        const CURRENT_WORLD = { ...WORLD_CONFIG, ...inheritedAttributes };

        class CostcoWorld {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.shelves = [];
                this.products = [];
                this.sampleStations = [];
                this.clock = new THREE.Clock();
                this.sampleCount = 0;
                
                this.moveSpeed = CURRENT_WORLD.moveSpeed;
                this.lookSpeed = CURRENT_WORLD.lookSpeed;
                this.keys = { w: false, a: false, s: false, d: false };
                this.rotation = { x: 0, y: 0 };
                
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;
                
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
            }

            async init() {
                this.setupScene();
                this.setupLighting();
                this.createWarehouse();
                this.createShelving();
                this.createProducts();
                this.createSampleStations();
                this.createCheckoutArea();
                this.createSignage();
                this.setupEventListeners();
                
                if (this.isMobile) {
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
                
                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(CURRENT_WORLD.fogColor, CURRENT_WORLD.fogNear, CURRENT_WORLD.fogFar);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, CURRENT_WORLD.cameraHeight, 20);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0xf5f5f5);
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                // Bright warehouse lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);
                
                // Overhead fluorescent lights
                for (let i = 0; i < 10; i++) {
                    for (let j = 0; j < 5; j++) {
                        const light = new THREE.RectAreaLight(0xffffff, 2, 4, 1);
                        light.position.set(i * 20 - 90, 15, j * 30 - 60);
                        light.lookAt(i * 20 - 90, 0, j * 30 - 60);
                        this.scene.add(light);
                    }
                }
                
                // Main directional light
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(50, 50, 50);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 200;
                dirLight.shadow.camera.left = -100;
                dirLight.shadow.camera.right = 100;
                dirLight.shadow.camera.top = 100;
                dirLight.shadow.camera.bottom = -100;
                this.scene.add(dirLight);
            }

            createWarehouse() {
                // Concrete floor
                const floorGeometry = new THREE.PlaneGeometry(300, 300);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Warehouse walls
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0,
                    roughness: 0.9
                });
                
                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(300, 30),
                    wallMaterial
                );
                backWall.position.z = -150;
                backWall.position.y = 15;
                this.scene.add(backWall);
                
                // Side walls
                const leftWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(300, 30),
                    wallMaterial
                );
                leftWall.rotation.y = Math.PI / 2;
                leftWall.position.x = -150;
                leftWall.position.y = 15;
                this.scene.add(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(300, 30),
                    wallMaterial
                );
                rightWall.rotation.y = -Math.PI / 2;
                rightWall.position.x = 150;
                rightWall.position.y = 15;
                this.scene.add(rightWall);
                
                // Ceiling
                const ceilingGeometry = new THREE.PlaneGeometry(300, 300);
                const ceilingMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 1,
                    metalness: 0
                });
                const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.y = 30;
                this.scene.add(ceiling);
            }

            createShelving() {
                const shelfMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.7,
                    roughness: 0.3
                });
                
                // Create aisles of shelving
                for (let aisle = 0; aisle < 6; aisle++) {
                    for (let section = 0; section < 8; section++) {
                        const shelfGroup = new THREE.Group();
                        
                        // Shelf uprights
                        for (let i = 0; i < 2; i++) {
                            const upright = new THREE.Mesh(
                                new THREE.BoxGeometry(0.2, 12, 0.2),
                                shelfMaterial
                            );
                            upright.position.x = i * 4 - 2;
                            upright.position.y = 6;
                            shelfGroup.add(upright);
                        }
                        
                        // Shelf levels
                        for (let level = 0; level < 4; level++) {
                            const shelf = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 0.2, 3),
                                shelfMaterial
                            );
                            shelf.position.y = level * 3 + 1.5;
                            shelf.receiveShadow = true;
                            shelf.castShadow = true;
                            shelfGroup.add(shelf);
                        }
                        
                        shelfGroup.position.x = aisle * 25 - 62.5;
                        shelfGroup.position.z = section * 15 - 52.5;
                        
                        this.shelves.push(shelfGroup);
                        this.scene.add(shelfGroup);
                    }
                }
            }

            createProducts() {
                const productTypes = [
                    { name: 'Toilet Paper Mega Pack', color: 0xffffff, scale: 2 },
                    { name: 'Giant Cereal Box', color: 0xff6600, scale: 1.5 },
                    { name: 'Bulk Water Bottles', color: 0x0099ff, scale: 1.8 },
                    { name: 'Enormous Ketchup', color: 0xff0000, scale: 1.2 },
                    { name: 'TV Bundle', color: 0x333333, scale: 2.5 },
                    { name: 'Mega Snack Pack', color: 0xffcc00, scale: 1.6 }
                ];
                
                this.shelves.forEach((shelf, shelfIndex) => {
                    // Add products to each shelf level
                    for (let level = 0; level < 4; level++) {
                        const productType = productTypes[Math.floor(Math.random() * productTypes.length)];
                        
                        for (let i = 0; i < 3; i++) {
                            const productGeometry = new THREE.BoxGeometry(
                                1 * productType.scale,
                                1.5 * productType.scale,
                                1 * productType.scale
                            );
                            const productMaterial = new THREE.MeshStandardMaterial({
                                color: productType.color,
                                roughness: 0.7
                            });
                            
                            const product = new THREE.Mesh(productGeometry, productMaterial);
                            product.position.x = shelf.position.x + (i - 1) * 1.3;
                            product.position.y = level * 3 + 2.5;
                            product.position.z = shelf.position.z;
                            product.castShadow = true;
                            product.receiveShadow = true;
                            
                            product.userData = {
                                type: productType.name,
                                originalY: product.position.y
                            };
                            
                            this.products.push(product);
                            this.scene.add(product);
                        }
                    }
                });
            }

            createSampleStations() {
                const stationPositions = [
                    { x: -30, z: 0 },
                    { x: 30, z: -30 },
                    { x: 0, z: 30 },
                    { x: -50, z: -50 }
                ];
                
                stationPositions.forEach((pos, index) => {
                    const stationGroup = new THREE.Group();
                    
                    // Table
                    const tableGeometry = new THREE.BoxGeometry(4, 1, 3);
                    const tableMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.8
                    });
                    const table = new THREE.Mesh(tableGeometry, tableMaterial);
                    table.position.y = 1.5;
                    table.castShadow = true;
                    table.receiveShadow = true;
                    stationGroup.add(table);
                    
                    // Sample dome
                    const domeGeometry = new THREE.SphereGeometry(1, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const domeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                    dome.position.y = 2;
                    stationGroup.add(dome);
                    
                    // Food samples (small cubes)
                    for (let i = 0; i < 8; i++) {
                        const sampleGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.3);
                        const sampleMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6)
                        });
                        const sample = new THREE.Mesh(sampleGeometry, sampleMaterial);
                        
                        const angle = (i / 8) * Math.PI * 2;
                        sample.position.x = Math.cos(angle) * 0.8;
                        sample.position.z = Math.sin(angle) * 0.8;
                        sample.position.y = 2.1;
                        
                        sample.userData = {
                            isSample: true,
                            collected: false,
                            stationIndex: index
                        };
                        
                        stationGroup.add(sample);
                    }
                    
                    // Sign
                    const signGeometry = new THREE.PlaneGeometry(2, 1);
                    const signMaterial = new THREE.MeshBasicMaterial({
                        color: 0xE31837,
                        side: THREE.DoubleSide
                    });
                    const sign = new THREE.Mesh(signGeometry, signMaterial);
                    sign.position.y = 4;
                    sign.position.z = 0.1;
                    stationGroup.add(sign);
                    
                    stationGroup.position.set(pos.x, 0, pos.z);
                    this.sampleStations.push(stationGroup);
                    this.scene.add(stationGroup);
                });
            }

            createCheckoutArea() {
                // Checkout counters
                for (let i = 0; i < 6; i++) {
                    const checkoutGroup = new THREE.Group();
                    
                    // Counter
                    const counterGeometry = new THREE.BoxGeometry(3, 1.5, 8);
                    const counterMaterial = new THREE.MeshStandardMaterial({
                        color: 0x444444,
                        metalness: 0.5,
                        roughness: 0.5
                    });
                    const counter = new THREE.Mesh(counterGeometry, counterMaterial);
                    counter.position.y = 0.75;
                    checkoutGroup.add(counter);
                    
                    // Conveyor belt
                    const beltGeometry = new THREE.BoxGeometry(2.5, 0.1, 7);
                    const beltMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        roughness: 0.8
                    });
                    const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                    belt.position.y = 1.55;
                    checkoutGroup.add(belt);
                    
                    // Register
                    const registerGeometry = new THREE.BoxGeometry(1, 1, 1);
                    const registerMaterial = new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        metalness: 0.7
                    });
                    const register = new THREE.Mesh(registerGeometry, registerMaterial);
                    register.position.y = 2;
                    register.position.z = -3;
                    checkoutGroup.add(register);
                    
                    checkoutGroup.position.x = i * 8 - 20;
                    checkoutGroup.position.z = 80;
                    
                    this.scene.add(checkoutGroup);
                }
            }

            createSignage() {
                // Department signs
                const departments = [
                    { text: 'ELECTRONICS', x: -50, z: -70 },
                    { text: 'GROCERIES', x: 0, z: -70 },
                    { text: 'CLOTHING', x: 50, z: -70 },
                    { text: 'HOME & GARDEN', x: -50, z: 0 }
                ];
                
                departments.forEach(dept => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 128;
                    const context = canvas.getContext('2d');
                    
                    context.fillStyle = '#0060A9';
                    context.fillRect(0, 0, 512, 128);
                    
                    context.fillStyle = '#ffffff';
                    context.font = 'bold 48px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(dept.text, 256, 64);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const signMaterial = new THREE.MeshBasicMaterial({ map: texture });
                    const signGeometry = new THREE.PlaneGeometry(10, 2.5);
                    const sign = new THREE.Mesh(signGeometry, signMaterial);
                    
                    sign.position.set(dept.x, 12, dept.z);
                    this.scene.add(sign);
                });
                
                // Giant Costco logo
                const logoGeometry = new THREE.PlaneGeometry(20, 5);
                const logoMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0060A9,
                    side: THREE.DoubleSide
                });
                const logo = new THREE.Mesh(logoGeometry, logoMaterial);
                logo.position.set(0, 20, -140);
                this.scene.add(logo);
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
                
                // Sample collection
                this.renderer.domElement.addEventListener('click', () => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.collectSample();
                    }
                });
            }

            setupDesktopControls() {
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                this.renderer.domElement.addEventListener('click', () => {
                    this.renderer.domElement.requestPointerLock();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }

            setupMobileControls() {
                const lookArea = document.getElementById('look-area');
                
                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.lookTouch = {
                        id: touch.identifier,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                    
                    // Check for sample collection on tap
                    this.collectSample();
                }, { passive: true });
                
                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;
                            
                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                            
                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;
                            
                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });
                
                lookArea.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                }, { passive: true });
                
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.joystickTouch = { id: touch.identifier };
                    this.joystickActive = true;
                    this.updateJoystick(touch, joystick, handle);
                }, { passive: false });
                
                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive || !this.joystickTouch) return;
                    
                    e.preventDefault();
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.joystickTouch.id) {
                            this.updateJoystick(touch, joystick, handle);
                            break;
                        }
                    }
                }, { passive: false });
                
                joystick.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.joystickTouch && touch.identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickTouch = null;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';
                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });
            }

            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }

            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                // Keep camera in bounds
                this.camera.position.x = Math.max(-140, Math.min(140, this.camera.position.x));
                this.camera.position.z = Math.max(-140, Math.min(140, this.camera.position.z));
                this.camera.position.y = CURRENT_WORLD.cameraHeight;
                
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }

            collectSample() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                
                const allObjects = [];
                this.sampleStations.forEach(station => {
                    station.traverse(child => {
                        if (child.userData.isSample && !child.userData.collected) {
                            allObjects.push(child);
                        }
                    });
                });
                
                const intersects = this.raycaster.intersectObjects(allObjects);
                
                if (intersects.length > 0) {
                    const sample = intersects[0].object;
                    const distance = intersects[0].distance;
                    
                    if (distance < 5) { // Close enough to collect
                        sample.userData.collected = true;
                        sample.visible = false;
                        this.sampleCount++;
                        document.getElementById('sample-count').textContent = this.sampleCount;
                        
                        // Create particle effect
                        this.createCollectionEffect(sample.getWorldPosition(new THREE.Vector3()));
                    }
                }
            }

            createCollectionEffect(position) {
                const particleCount = 20;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
                        transparent: true
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    
                    particle.position.copy(position);
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            Math.random() * 0.3,
                            (Math.random() - 0.5) * 0.2
                        ),
                        lifetime: 1
                    };
                    
                    particles.push(particle);
                    this.scene.add(particle);
                }
                
                // Animate particles
                const animateParticles = () => {
                    particles.forEach((particle, index) => {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.lifetime -= 0.02;
                        particle.material.opacity = particle.userData.lifetime;
                        
                        if (particle.userData.lifetime <= 0) {
                            this.scene.remove(particle);
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (particles.length > 0) {
                        requestAnimationFrame(animateParticles);
                    }
                };
                
                animateParticles();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = this.clock.getElapsedTime();
                
                this.updateMovement();
                
                // Animate products (floating effect)
                this.products.forEach((product, i) => {
                    product.position.y = product.userData.originalY + Math.sin(time * 0.5 + i * 0.1) * 0.1;
                    product.rotation.y = Math.sin(time * 0.3 + i * 0.2) * 0.1;
                });
                
                // Rotate sample station domes
                this.sampleStations.forEach((station, i) => {
                    station.rotation.y = time * 0.5 + i;
                });
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        function returnToNexus() {
            window.location.href = 'index.html';
        }

        window.addEventListener('DOMContentLoaded', () => {
            const world = new CostcoWorld();
            world.init();
        });
    </script>
</body>
</html>